
                  
  
# xir module

icraft xir python interface

**class ACos(*args, **kwargs)[#](#xir.ACos)**

Overloaded function.

- 
__init__(self: xir.ACos) -> None

默认构造函数

- 
__init__(self: xir.ACos, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ACos, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ACos](#xir.ACos)[#](#xir.ACos.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ACos](#xir.ACos), depth: int = 1) → [xir.ACos](#xir.ACos)[#](#xir.ACos.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ACosh(*args, **kwargs)[#](#xir.ACosh)**

Overloaded function.

- 
__init__(self: xir.ACosh) -> None

默认构造函数

- 
__init__(self: xir.ACosh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ACosh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ACosh](#xir.ACosh)[#](#xir.ACosh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ACosh](#xir.ACosh), depth: int = 1) → [xir.ACosh](#xir.ACosh)[#](#xir.ACosh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ASin(*args, **kwargs)[#](#xir.ASin)**

Overloaded function.

- 
__init__(self: xir.ASin) -> None

默认构造函数

- 
__init__(self: xir.ASin, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ASin, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ASin](#xir.ASin)[#](#xir.ASin.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ASin](#xir.ASin), depth: int = 1) → [xir.ASin](#xir.ASin)[#](#xir.ASin.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ASinh(*args, **kwargs)[#](#xir.ASinh)**

Overloaded function.

- 
__init__(self: xir.ASinh) -> None

默认构造函数

- 
__init__(self: xir.ASinh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ASinh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ASinh](#xir.ASinh)[#](#xir.ASinh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ASinh](#xir.ASinh), depth: int = 1) → [xir.ASinh](#xir.ASinh)[#](#xir.ASinh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ATan(*args, **kwargs)[#](#xir.ATan)**

Overloaded function.

- 
__init__(self: xir.ATan) -> None

默认构造函数

- 
__init__(self: xir.ATan, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ATan, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ATan](#xir.ATan)[#](#xir.ATan.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ATan](#xir.ATan), depth: int = 1) → [xir.ATan](#xir.ATan)[#](#xir.ATan.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ATanh(*args, **kwargs)[#](#xir.ATanh)**

Overloaded function.

- 
__init__(self: xir.ATanh) -> None

默认构造函数

- 
__init__(self: xir.ATanh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.ATanh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ATanh](#xir.ATanh)[#](#xir.ATanh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ATanh](#xir.ATanh), depth: int = 1) → [xir.ATanh](#xir.ATanh)[#](#xir.ATanh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Abs(*args, **kwargs)[#](#xir.Abs)**

Overloaded function.

- 
__init__(self: xir.Abs) -> None

默认构造函数

- 
__init__(self: xir.Abs, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Abs, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Abs](#xir.Abs)[#](#xir.Abs.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Abs](#xir.Abs), depth: int = 1) → [xir.Abs](#xir.Abs)[#](#xir.Abs.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Add(*args, **kwargs)[#](#xir.Add)**

Overloaded function.

- 
__init__(self: xir.Add) -> None

默认构造函数

- 
__init__(self: xir.Add, lhs: xir.Value, rhs: xir.Value, alpha: xir.ScalarImm, beta: xir.ScalarImm) -> None

构造函数（兼容标量输入）
:param  lhs:            左操作数
:param  rhs:            右操作数
:param  alpha:          左操作数的系数
:param  beta:           右操作数的系数

- 
__init__(self: xir.Add, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs:            左操作数
:param  rhs:            右操作数

- 
__init__(self: xir.Add, lhs: xir.Value, rhs: xir.Value, alpha: List[xir.ScalarImm], beta: List[xir.ScalarImm]) -> None

构造函数
:param  lhs:            左操作数
:param  rhs:            右操作数
:param  alpha:          左操作数的系数
:param  beta:           右操作数的系数

- 
__init__(self: xir.Add, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Add](#xir.Add)[#](#xir.Add.Init)**

创建一个初始化(非空)对象

**property alpha[#](#xir.Add.alpha)**

左操作数的系数

**property beta[#](#xir.Add.beta)**

右操作数的系数

**clone(self: [xir.Add](#xir.Add), depth: int = 1) → [xir.Add](#xir.Add)[#](#xir.Add.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class AlignAxis(*args, **kwargs)[#](#xir.AlignAxis)**

Overloaded function.

- 
__init__(self: xir.AlignAxis) -> None

默认构造函数

- 
__init__(self: xir.AlignAxis, input: xir.Value, aligned_units: List[xir.AlignedUnit]) -> None

构造函数
:param  input:                  输入
:param  aligned_units:  对齐的维度和单位

- 
__init__(self: xir.AlignAxis, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AlignAxis](#xir.AlignAxis)[#](#xir.AlignAxis.Init)**

创建一个初始化(非空)对象

**property aligned_units[#](#xir.AlignAxis.aligned_units)**

对齐的维度和单位

**clone(self: [xir.AlignAxis](#xir.AlignAxis), depth: int = 1) → [xir.AlignAxis](#xir.AlignAxis)[#](#xir.AlignAxis.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class AlignedUnit(*args, **kwargs)[#](#xir.AlignedUnit)**

Overloaded function.

- 
__init__(self: xir.AlignedUnit) -> None

默认构造函数.

- 
__init__(self: xir.AlignedUnit, index: icraft::xir::Array<__int64>, unit: icraft::xir::Array<__int64>) -> None

构造函数
:param  index:          维度索引
:param  unit:           对齐的单位

- 
__init__(self: xir.AlignedUnit, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AlignedUnit](#xir.AlignedUnit)[#](#xir.AlignedUnit.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AlignedUnit](#xir.AlignedUnit), depth: int = 1) → [xir.AlignedUnit](#xir.AlignedUnit)[#](#xir.AlignedUnit.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property index[#](#xir.AlignedUnit.index)**

维度索引

**property unit[#](#xir.AlignedUnit.unit)**

对齐的单位

**Anycards() → [xir.AnycardsPattern](#xir.AnycardsPattern)[#](#xir.Anycards)**

构造一个通配符模式，匹配任意数量输入

**class AnycardsPattern(*args, **kwargs)[#](#xir.AnycardsPattern)**

表示模式匹配的通配符

Overloaded function.

- 
__init__(self: xir.AnycardsPattern) -> None

默认构造函数

- 
__init__(self: xir.AnycardsPattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AnycardsPattern](#xir.AnycardsPattern)[#](#xir.AnycardsPattern.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AnycardsPattern](#xir.AnycardsPattern), depth: int = 1) → [xir.AnycardsPattern](#xir.AnycardsPattern)[#](#xir.AnycardsPattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Argmax(*args, **kwargs)[#](#xir.Argmax)**

Overloaded function.

- 
__init__(self: xir.Argmax) -> None

默认构造函数

- 
__init__(self: xir.Argmax, input: xir.Value, dim: Optional[xir.IntImm] = None, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求最大值索引的维度（支持负数索引）
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Argmax, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Argmax](#xir.Argmax)[#](#xir.Argmax.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Argmax](#xir.Argmax), depth: int = 1) → [xir.Argmax](#xir.Argmax)[#](#xir.Argmax.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Argmax.dim)**

进行求最大值索引的维度（支持负数索引）

**property keepdim[#](#xir.Argmax.keepdim)**

是否保持维度不变

**class Argmin(*args, **kwargs)[#](#xir.Argmin)**

Overloaded function.

- 
__init__(self: xir.Argmin) -> None

默认构造函数

- 
__init__(self: xir.Argmin, input: xir.Value, dim: Optional[xir.IntImm] = None, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求最小值索引的维度（支持负数索引）
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Argmin, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Argmin](#xir.Argmin)[#](#xir.Argmin.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Argmin](#xir.Argmin), depth: int = 1) → [xir.Argmin](#xir.Argmin)[#](#xir.Argmin.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Argmin.dim)**

进行求最小值索引的维度（支持负数索引）

**property keepdim[#](#xir.Argmin.keepdim)**

是否保持维度不变

**class AttrPattern(*args, **kwargs)[#](#xir.AttrPattern)**

表示匹配算子属性的模式

Overloaded function.

- 
__init__(self: xir.AttrPattern) -> None

默认构造函数

- 
__init__(self: xir.AttrPattern, arg0: str, arg1: Union[xir.ObjectRef, int, int, int, bool, float, str]) -> None

- 
__init__(self: xir.AttrPattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AttrPattern](#xir.AttrPattern)[#](#xir.AttrPattern.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AttrPattern](#xir.AttrPattern), depth: int = 1) → [xir.AttrPattern](#xir.AttrPattern)[#](#xir.AttrPattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property key[#](#xir.AttrPattern.key)**

属性的键

**property value[#](#xir.AttrPattern.value)**

属性的值

**class AvgPool1d(*args, **kwargs)[#](#xir.AvgPool1d)**

Overloaded function.

- 
__init__(self: xir.AvgPool1d) -> None

默认构造函数

- 
__init__(self: xir.AvgPool1d, input: xir.Value, pool_width: int, stride_width: int, pad_left: int, pad_right: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_width:                             池化窗口宽度
:param  stride_width:                   池化滑动宽度
:param  stride_height:                  池化滑动高度
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AvgPool1d](#xir.AvgPool1d)[#](#xir.AvgPool1d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AvgPool1d](#xir.AvgPool1d), depth: int = 1) → [xir.AvgPool1d](#xir.AvgPool1d)[#](#xir.AvgPool1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property count_include_pad[#](#xir.AvgPool1d.count_include_pad)**

平均时是否包含pad数据，默认不包含

**property divisor_override[#](#xir.AvgPool1d.divisor_override)**

覆盖池化的除数，默认为0表示不覆盖

**property pad_left[#](#xir.AvgPool1d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.AvgPool1d.pad_right)**

池化右方Pad，默认为0

**property pool_width[#](#xir.AvgPool1d.pool_width)**

池化窗口宽度

**property stride_width[#](#xir.AvgPool1d.stride_width)**

池化滑动宽度，默认为1

**class AvgPool2d(*args, **kwargs)[#](#xir.AvgPool2d)**

Overloaded function.

- 
__init__(self: xir.AvgPool2d) -> None

默认构造函数

- 
__init__(self: xir.AvgPool2d, input: xir.Value, pool_width: int, pool_height: int, stride_width: int, stride_height: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_width:                             池化窗口宽度
:param  pool_height:                    池化窗口高度
:param  stride_width:                   池化滑动宽度
:param  stride_height:                  池化滑动高度
:param  pad_top:                                池化上方Pad
:param  pad_bottom:                             池化下方Pad
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool2d, input: xir.Value, pool_size: int, stride: int, pad_top_bottom: int, pad_left_right: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，高度和宽度相同
:param  stride:                                 池化滑动长度，高度和宽度相同
:param  pad_top_bottom:                 池化上下方Pad
:param  pad_left_right:                 池化左右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool2d, input: xir.Value, pool_size: int, stride: int, pad: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，高度和宽度相同
:param  stride:                                 池化滑动长度，高度和宽度相同
:param  pad:                                    池化上下左右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AvgPool2d](#xir.AvgPool2d)[#](#xir.AvgPool2d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AvgPool2d](#xir.AvgPool2d), depth: int = 1) → [xir.AvgPool2d](#xir.AvgPool2d)[#](#xir.AvgPool2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property count_include_pad[#](#xir.AvgPool2d.count_include_pad)**

平均时是否包含pad数据，默认不包含

**property divisor_override[#](#xir.AvgPool2d.divisor_override)**

覆盖池化的除数，默认为0表示不覆盖

**property pad_bottom[#](#xir.AvgPool2d.pad_bottom)**

池化下方Pad，默认为0

**property pad_left[#](#xir.AvgPool2d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.AvgPool2d.pad_right)**

池化右方Pad，默认为0

**property pad_top[#](#xir.AvgPool2d.pad_top)**

池化上方Pad，默认为0

**property pool_height[#](#xir.AvgPool2d.pool_height)**

池化窗口高度

**property pool_width[#](#xir.AvgPool2d.pool_width)**

池化窗口宽度

**property stride_height[#](#xir.AvgPool2d.stride_height)**

池化滑动高度，默认为1

**property stride_width[#](#xir.AvgPool2d.stride_width)**

池化滑动宽度，默认为1

**class AvgPool3d(*args, **kwargs)[#](#xir.AvgPool3d)**

Overloaded function.

- 
__init__(self: xir.AvgPool3d) -> None

默认构造函数

- 
__init__(self: xir.AvgPool3d, input: xir.Value, pool_depth: int, pool_width: int, pool_height: int, stride_depth: int, stride_width: int, stride_height: int, pad_front: int, pad_back: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_depth:                             池化窗口深度
:param  pool_width:                             池化窗口宽度
:param  pool_height:                    池化窗口高度
:param  stride_depth:                   池化滑动深度
:param  stride_width:                   池化滑动宽度
:param  stride_height:                  池化滑动高度
:param  pad_front:                              池化前方Pad
:param  pad_back:                               池化后方Pad
:param  pad_top:                                池化上方Pad
:param  pad_bottom:                             池化下方Pad
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool3d, input: xir.Value, pool_size: int, stride: int, pad_front_top_bottom: int, pad_back_left_right: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，深度、高度和宽度相同
:param  stride:                                 池化滑动长度，深度、高度和宽度相同
:param  pad_front_top_bottom:   池化前上下方Pad
:param  pad_back_left_right:    池化后左右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool3d, input: xir.Value, pool_size: int, stride: int, pad: int, count_include_pad: bool = False, divisor_override: int = 0) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，深度、高度和宽度相同
:param  stride:                                 池化滑动长度，深度、高度和宽度相同
:param  pad:                                    池化前后上下左右方Pad
:param  count_include_pad:              覆盖池化的除数，默认为0不覆盖
:param  divisor_override:               平均时是否包含pads数据，默认为false

- 
__init__(self: xir.AvgPool3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AvgPool3d](#xir.AvgPool3d)[#](#xir.AvgPool3d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AvgPool3d](#xir.AvgPool3d), depth: int = 1) → [xir.AvgPool3d](#xir.AvgPool3d)[#](#xir.AvgPool3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property count_include_pad[#](#xir.AvgPool3d.count_include_pad)**

平均时是否包含pad数据，默认不包含

**property divisor_override[#](#xir.AvgPool3d.divisor_override)**

覆盖池化的除数，默认为0表示不覆盖

**property pad_back[#](#xir.AvgPool3d.pad_back)**

池化后方Pad，默认为0

**property pad_bottom[#](#xir.AvgPool3d.pad_bottom)**

池化下方Pad，默认为0

**property pad_front[#](#xir.AvgPool3d.pad_front)**

池化前方Pad，默认为0

**property pad_left[#](#xir.AvgPool3d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.AvgPool3d.pad_right)**

池化右方Pad，默认为0

**property pad_top[#](#xir.AvgPool3d.pad_top)**

池化上方Pad，默认为0

**property pool_depth[#](#xir.AvgPool3d.pool_depth)**

池化窗口深度

**property pool_height[#](#xir.AvgPool3d.pool_height)**

池化窗口高度

**property pool_width[#](#xir.AvgPool3d.pool_width)**

池化窗口宽度

**property stride_depth[#](#xir.AvgPool3d.stride_depth)**

池化滑动深度，默认为1

**property stride_height[#](#xir.AvgPool3d.stride_height)**

池化滑动高度，默认为1

**property stride_width[#](#xir.AvgPool3d.stride_width)**

池化滑动宽度，默认为1

**Avgpool[#](#xir.Avgpool)**

[AvgPool2d](#xir.AvgPool2d) 的别名

**class AxisName(*args, **kwargs)[#](#xir.AxisName)**

表示Layout中的一个大写坐标轴

Overloaded function.

- 
__init__(self: xir.AxisName) -> None

默认构造函数

- 
__init__(self: xir.AxisName, name: str) -> None

构造函数
:param name:            坐标轴的名字

- 
__init__(self: xir.AxisName, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AxisName](#xir.AxisName)[#](#xir.AxisName.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AxisName](#xir.AxisName), depth: int = 1) → [xir.AxisName](#xir.AxisName)[#](#xir.AxisName.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property name[#](#xir.AxisName.name)**

坐标轴的名字

**class AxisUnit(*args, **kwargs)[#](#xir.AxisUnit)**

表示Layout中的一个小写坐标轴

Overloaded function.

- 
__init__(self: xir.AxisUnit) -> None

默认构造函数

- 
__init__(self: xir.AxisUnit, name: str, unit: int) -> None

构造函数
:param name:            坐标轴的名字
:param unit:            坐标轴的单位长度

- 
__init__(self: xir.AxisUnit, name: str) -> None

构造函数(默认单位长度为0)
:param name:            坐标轴的名字

- 
__init__(self: xir.AxisUnit, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.AxisUnit](#xir.AxisUnit)[#](#xir.AxisUnit.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.AxisUnit](#xir.AxisUnit), depth: int = 1) → [xir.AxisUnit](#xir.AxisUnit)[#](#xir.AxisUnit.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**setUnit(self: [xir.AxisUnit](#xir.AxisUnit), unit: int) → [xir.AxisUnit](#xir.AxisUnit)[#](#xir.AxisUnit.setUnit)**

构造函数(默认单位长度为0)
:param unit:            单位长度

**property unit[#](#xir.AxisUnit.unit)**

坐标轴的单位长度

**class BaseQuantizedType(self: [xir.BaseQuantizedType](#xir.BaseQuantizedType), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.BaseQuantizedType)**

表示基本的量化类型

将父类强制转换为子类（该类型）

**clone(self: [xir.BaseQuantizedType](#xir.BaseQuantizedType), depth: int = 1) → [xir.BaseQuantizedType](#xir.BaseQuantizedType)[#](#xir.BaseQuantizedType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property expressed_dtype[#](#xir.BaseQuantizedType.expressed_dtype)**

表达类型，即数据的原始类型

**property storage_dtype[#](#xir.BaseQuantizedType.storage_dtype)**

存储类型，即量化的目标类型

**class BatchNorm1d(*args, **kwargs)[#](#xir.BatchNorm1d)**

Overloaded function.

- 
__init__(self: xir.BatchNorm1d) -> None

默认构造函数

- 
__init__(self: xir.BatchNorm1d, input: xir.Value, variance: xir.Params, mean: xir.Params) -> None

构造函数
:param  input:          输入
:param  variance:       乘数因子
:param  mean:           加数因子

- 
__init__(self: xir.BatchNorm1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.BatchNorm1d](#xir.BatchNorm1d)[#](#xir.BatchNorm1d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.BatchNorm1d](#xir.BatchNorm1d), depth: int = 1) → [xir.BatchNorm1d](#xir.BatchNorm1d)[#](#xir.BatchNorm1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property mean[#](#xir.BatchNorm1d.mean)**

Batchnorm加数因子

**property variance[#](#xir.BatchNorm1d.variance)**

Batchnorm的乘数因子

**class BatchNorm2d(*args, **kwargs)[#](#xir.BatchNorm2d)**

Overloaded function.

- 
__init__(self: xir.BatchNorm2d) -> None

默认构造函数

- 
__init__(self: xir.BatchNorm2d, input: xir.Value, variance: xir.Params, mean: xir.Params) -> None

构造函数
:param  input:          输入
:param  variance:       乘数因子
:param  mean:           加数因子

- 
__init__(self: xir.BatchNorm2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.BatchNorm2d](#xir.BatchNorm2d)[#](#xir.BatchNorm2d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.BatchNorm2d](#xir.BatchNorm2d), depth: int = 1) → [xir.BatchNorm2d](#xir.BatchNorm2d)[#](#xir.BatchNorm2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property mean[#](#xir.BatchNorm2d.mean)**

Batchnorm加数因子

**property variance[#](#xir.BatchNorm2d.variance)**

Batchnorm的乘数因子

**class BatchNorm3d(*args, **kwargs)[#](#xir.BatchNorm3d)**

Overloaded function.

- 
__init__(self: xir.BatchNorm3d) -> None

默认构造函数

- 
__init__(self: xir.BatchNorm3d, input: xir.Value, variance: xir.Params, mean: xir.Params) -> None

构造函数
:param  input:          输入
:param  variance:       乘数因子
:param  mean:           加数因子

- 
__init__(self: xir.BatchNorm3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.BatchNorm3d](#xir.BatchNorm3d)[#](#xir.BatchNorm3d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.BatchNorm3d](#xir.BatchNorm3d), depth: int = 1) → [xir.BatchNorm3d](#xir.BatchNorm3d)[#](#xir.BatchNorm3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property mean[#](#xir.BatchNorm3d.mean)**

BatchNorm3d加数因子

**property variance[#](#xir.BatchNorm3d.variance)**

BatchNorm3d的乘数因子

**Batchnorm[#](#xir.Batchnorm)**

[BatchNorm2d](#xir.BatchNorm2d) 的别名

**class Bool(*args, **kwargs)[#](#xir.Bool)**

表示布尔值立即数

Overloaded function.

- 
__init__(self: xir.Bool) -> None

默认构造函数

- 
__init__(self: xir.Bool, arg0: bool) -> None

构造函数

- 
__init__(self: xir.Bool, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Bool](#xir.Bool)[#](#xir.Bool.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Bool](#xir.Bool), depth: int = 1) → [xir.Bool](#xir.Bool)[#](#xir.Bool.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class BoolType(*args, **kwargs)[#](#xir.BoolType)**

表示布尔数据类型的类型

Overloaded function.

- 
__init__(self: xir.BoolType) -> None

默认构造函数

- 
__init__(self: xir.BoolType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.BoolType](#xir.BoolType)[#](#xir.BoolType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.BoolType](#xir.BoolType), depth: int = 1) → [xir.BoolType](#xir.BoolType)[#](#xir.BoolType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**BuildTime() → str[#](#xir.BuildTime)**

获取编译时间

**class BuyiTarget(self: [xir.BuyiTarget](#xir.BuyiTarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.BuyiTarget)**

表示Buyi编译目标的类型

将父类强制转换为子类（该类型）

**static Init() → [xir.BuyiTarget](#xir.BuyiTarget)[#](#xir.BuyiTarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.BuyiTarget](#xir.BuyiTarget), depth: int = 1) → [xir.BuyiTarget](#xir.BuyiTarget)[#](#xir.BuyiTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class CalibratedType(*args, **kwargs)[#](#xir.CalibratedType)**

表示校准后的数据类型

Overloaded function.

- 
__init__(self: xir.CalibratedType) -> None

默认构造函数

- 
__init__(self: xir.CalibratedType, min: float, max: float, sat: float, storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1C1B0>) -> None

构造函数
:param min:                                     统计最小值
:param max:                                     统计最大值
:param sat:                                     统计饱和点
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.CalibratedType, min: List[float], max: List[float], sat: List[float], storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1F5F0>) -> None

构造函数
:param min:                                     统计最小值
:param max:                                     统计最大值
:param sat:                                     统计饱和点
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.CalibratedType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.CalibratedType](#xir.CalibratedType)[#](#xir.CalibratedType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.CalibratedType](#xir.CalibratedType), depth: int = 1) → [xir.CalibratedType](#xir.CalibratedType)[#](#xir.CalibratedType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property max[#](#xir.CalibratedType.max)**

统计的最大值

**property min[#](#xir.CalibratedType.min)**

统计的最小值

**property sat[#](#xir.CalibratedType.sat)**

统计的饱和点

**class Cast(*args, **kwargs)[#](#xir.Cast)**

Overloaded function.

- 
__init__(self: xir.Cast) -> None

默认构造函数

- 
__init__(self: xir.Cast, input: xir.Value, target_dtype: xir.TensorType) -> None

构造函数
:param  input:                  输入
:param  target_dtype:   目标数据类型

- 
__init__(self: xir.Cast, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Cast](#xir.Cast)[#](#xir.Cast.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Cast](#xir.Cast), depth: int = 1) → [xir.Cast](#xir.Cast)[#](#xir.Cast.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property target_dtype[#](#xir.Cast.target_dtype)**

目标数据类型

**class ChannelShuffle(*args, **kwargs)[#](#xir.ChannelShuffle)**

Overloaded function.

- 
__init__(self: xir.ChannelShuffle) -> None

默认构造函数

- 
__init__(self: xir.ChannelShuffle, input: xir.Value, groups: int) -> None

构造函数
:param  input:          输入
:param  groups:         要把通道分成的组数

- 
__init__(self: xir.ChannelShuffle, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ChannelShuffle](#xir.ChannelShuffle)[#](#xir.ChannelShuffle.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ChannelShuffle](#xir.ChannelShuffle), depth: int = 1) → [xir.ChannelShuffle](#xir.ChannelShuffle)[#](#xir.ChannelShuffle.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property groups[#](#xir.ChannelShuffle.groups)**

要把通道分成的组数

**class ChunkMem(*args, **kwargs)[#](#xir.ChunkMem)**

Overloaded function.

- 
__init__(self: xir.ChunkMem) -> None

默认构造函数

- 
__init__(self: xir.ChunkMem, chunk_id: int, offset: int) -> None

构造函数，从地址构造
:param chunk_id:        Chunk ID
:param offset:          Chunk上的偏移

- 
__init__(self: xir.ChunkMem, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ChunkMem](#xir.ChunkMem)[#](#xir.ChunkMem.Init)**

创建一个初始化(非空)对象

**property chunk_id[#](#xir.ChunkMem.chunk_id)**

Chunk ID

**clone(self: [xir.ChunkMem](#xir.ChunkMem), depth: int = 1) → [xir.ChunkMem](#xir.ChunkMem)[#](#xir.ChunkMem.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property offset[#](#xir.ChunkMem.offset)**

Chunk上的偏移

**setAddr(self: [xir.ChunkMem](#xir.ChunkMem), chunk_id: int, offset: int) → [xir.ChunkMem](#xir.ChunkMem)[#](#xir.ChunkMem.setAddr)**

设置地址
:param chunk_id:        Chunk ID
:param offset:          Chunk上的偏移

**class ClampScalar(*args, **kwargs)[#](#xir.ClampScalar)**

Overloaded function.

- 
__init__(self: xir.ClampScalar) -> None

默认构造函数

- 
__init__(self: xir.ClampScalar, input: xir.Value, min: float = -inf, max: float = inf) -> None

构造函数
:param  input:          输入
:param  min:            裁剪的下限，默认负无穷
:param  max:            裁剪的上限，默认正无穷

- 
__init__(self: xir.ClampScalar, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ClampScalar](#xir.ClampScalar)[#](#xir.ClampScalar.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ClampScalar](#xir.ClampScalar), depth: int = 1) → [xir.ClampScalar](#xir.ClampScalar)[#](#xir.ClampScalar.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property max[#](#xir.ClampScalar.max)**

裁剪的上限，默认正无穷

**property min[#](#xir.ClampScalar.min)**

裁剪的下限，默认负无穷

**CommitID() → str[#](#xir.CommitID)**

获取CommitID

**CommitSinceTag() → int[#](#xir.CommitSinceTag)**

获取自上个Tag提交了所少次

**class CompileTarget(self: [xir.CompileTarget](#xir.CompileTarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.CompileTarget)**

表示算子的编译目标的类型

将父类强制转换为子类（该类型）

**clone(self: [xir.CompileTarget](#xir.CompileTarget), depth: int = 1) → [xir.CompileTarget](#xir.CompileTarget)[#](#xir.CompileTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Concat(*args, **kwargs)[#](#xir.Concat)**

Overloaded function.

- 
__init__(self: xir.Concat) -> None

默认构造函数

- 
__init__(self: xir.Concat, inputs: List[xir.Value], axis: int = -1) -> None

构造函数
:param  input:          输入
:param  axis:           拼接的维度，默认为-1，表示最后一维

- 
__init__(self: xir.Concat, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Concat](#xir.Concat)[#](#xir.Concat.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.Concat.axis)**

拼接的维度，默认为-1，表示最后一维

**clone(self: [xir.Concat](#xir.Concat), depth: int = 1) → [xir.Concat](#xir.Concat)[#](#xir.Concat.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Conv1d(*args, **kwargs)[#](#xir.Conv1d)**

Overloaded function.

- 
__init__(self: xir.Conv1d) -> None

默认构造函数

- 
__init__(self: xir.Conv1d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_width: int, pad_left: int, pad_right: int, dilation_width: int, groups: int = 1, padding_mode: xir.PaddingMode = <PaddingMode.ZEROS: 0>) -> None

构造函数
:param  input:                                  输入
:param  weights:                                卷积的权重
:param  bias:                                   卷积的偏置
:param  stride_width:                   卷积滑动宽度
:param  pad_left:                               卷积左方Pad
:param  pad_right:                              卷积右方Pad
:param  dilation_width:                 卷积膨胀宽度
:param  groups:                                 卷积分组，默认为1
:param  padding_mode:                   卷积pad模式，默认为ZEROS

- 
__init__(self: xir.Conv1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Conv1d](#xir.Conv1d)[#](#xir.Conv1d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Conv1d](#xir.Conv1d), depth: int = 1) → [xir.Conv1d](#xir.Conv1d)[#](#xir.Conv1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property cut_scale[#](#xir.Conv1d.cut_scale)**

硬件截位时的系数

**property dilation_width[#](#xir.Conv1d.dilation_width)**

卷积膨胀宽度，默认为1

**property groups[#](#xir.Conv1d.groups)**

卷积分组数量，默认为1

**property pad_left[#](#xir.Conv1d.pad_left)**

卷积左方Pad，默认为0

**property pad_right[#](#xir.Conv1d.pad_right)**

卷积右方Pad，默认为0

**property padding_mode[#](#xir.Conv1d.padding_mode)**

卷积的pad模式，默认为ZEROS

**property stride_width[#](#xir.Conv1d.stride_width)**

卷积滑动宽度，默认为1

**Conv1dTranspose[#](#xir.Conv1dTranspose)**

[ConvTranspose1d](#xir.ConvTranspose1d) 的别名

**class Conv2d(*args, **kwargs)[#](#xir.Conv2d)**

Overloaded function.

- 
__init__(self: xir.Conv2d) -> None

默认构造函数

- 
__init__(self: xir.Conv2d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_width: int, stride_height: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_width: int, dilation_height: int, groups: int = 1, padding_mode: xir.PaddingMode = <PaddingMode.ZEROS: 0>) -> None

构造函数
:param  input:                                  输入
:param  weights:                                卷积的权重
:param  bias:                                   卷积的偏置
:param  stride_width:                   卷积滑动宽度
:param  stride_height:                  卷积滑动高度
:param  pad_top:                                卷积上方Pad
:param  pad_bottom:                             卷积下方Pad
:param  pad_left:                               卷积左方Pad
:param  pad_right:                              卷积右方Pad
:param  dilation_width:                 卷积膨胀宽度
:param  dilation_height:                卷积膨胀高度
:param  groups:                                 卷积分组，默认为1
:param  padding_mode:                   卷积pad模式，默认为ZEROS

- 
__init__(self: xir.Conv2d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride: int, pad: int, dilation: int, groups: int = 1, padding_mode: xir.PaddingMode = <PaddingMode.ZEROS: 0>) -> None

构造函数
:param  input:                                  输入
:param  weights:                                卷积的权重
:param  bias:                                   卷积的偏置
:param  stride:                                 卷积滑动步长，宽度和高度相同
:param  pad:                                    卷积的Pad，上下左右相同
:param  dilation:                               卷积膨胀系数，宽度和高度相同
:param  groups:                                 卷积分组，默认为1
:param  padding_mode:                   卷积pad模式，默认为ZEROS

- 
__init__(self: xir.Conv2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Conv2d](#xir.Conv2d)[#](#xir.Conv2d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Conv2d](#xir.Conv2d), depth: int = 1) → [xir.Conv2d](#xir.Conv2d)[#](#xir.Conv2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property cut_scale[#](#xir.Conv2d.cut_scale)**

硬件截位时的系数

**property dilation_height[#](#xir.Conv2d.dilation_height)**

卷积膨胀高度，默认为1

**property dilation_width[#](#xir.Conv2d.dilation_width)**

卷积膨胀宽度，默认为1

**property groups[#](#xir.Conv2d.groups)**

卷积分组数量，默认为1

**property pad_bottom[#](#xir.Conv2d.pad_bottom)**

卷积下方Pad，默认为0

**property pad_left[#](#xir.Conv2d.pad_left)**

卷积左方Pad，默认为0

**property pad_right[#](#xir.Conv2d.pad_right)**

卷积右方Pad，默认为0

**property pad_top[#](#xir.Conv2d.pad_top)**

卷积上方Pad，默认为0

**property padding_mode[#](#xir.Conv2d.padding_mode)**

卷积的pad模式，默认为ZEROS

**property stride_height[#](#xir.Conv2d.stride_height)**

卷积滑动高度，默认为1

**property stride_width[#](#xir.Conv2d.stride_width)**

卷积滑动宽度，默认为1

**Conv2dTranspose[#](#xir.Conv2dTranspose)**

[ConvTranspose2d](#xir.ConvTranspose2d) 的别名

**class Conv3d(*args, **kwargs)[#](#xir.Conv3d)**

Overloaded function.

- 
__init__(self: xir.Conv3d) -> None

默认构造函数

- 
__init__(self: xir.Conv3d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_depth: int, stride_width: int, stride_height: int, pad_front: int, pad_back: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_depth: int, dilation_width: int, dilation_height: int, groups: int = 1, padding_mode: xir.PaddingMode = <PaddingMode.ZEROS: 0>) -> None

构造函数
:param  input:                                  输入
:param  weights:                                卷积的权重
:param  bias:                                   卷积的偏置
:param  stride_depth:                   卷积滑动深度
:param  stride_width:                   卷积滑动宽度
:param  stride_height:                  卷积滑动高度
:param  pad_front:                              卷积前方Pad
:param  pad_back:                               卷积后方Pad
:param  pad_top:                                卷积上方Pad
:param  pad_bottom:                             卷积下方Pad
:param  pad_left:                               卷积左方Pad
:param  pad_right:                              卷积右方Pad
:param  dilation_depth:                 卷积膨胀深度
:param  dilation_width:                 卷积膨胀宽度
:param  dilation_height:                卷积膨胀高度
:param  groups:                                 卷积分组，默认为1
:param  padding_mode:                   卷积pad模式，默认为ZEROS

- 
__init__(self: xir.Conv3d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride: int, pad: int, dilation: int, groups: int = 1, padding_mode: xir.PaddingMode = <PaddingMode.ZEROS: 0>) -> None

构造函数
:param  input:                                  输入
:param  weights:                                卷积的权重
:param  bias:                                   卷积的偏置
:param  stride:                                 卷积滑动步长，深度、宽度和高度相同
:param  pad:                                    卷积的Pad，前后上下左右相同
:param  dilation:                               卷积膨胀系数，深度、宽度和高度相同
:param  groups:                                 卷积分组，默认为1
:param  padding_mode:                   卷积pad模式，默认为ZEROS

- 
__init__(self: xir.Conv3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Conv3d](#xir.Conv3d)[#](#xir.Conv3d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Conv3d](#xir.Conv3d), depth: int = 1) → [xir.Conv3d](#xir.Conv3d)[#](#xir.Conv3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property cut_scale[#](#xir.Conv3d.cut_scale)**

硬件截位时的系数

**property dilation_depth[#](#xir.Conv3d.dilation_depth)**

卷积膨胀深度，默认为1

**property dilation_height[#](#xir.Conv3d.dilation_height)**

卷积膨胀高度，默认为1

**property dilation_width[#](#xir.Conv3d.dilation_width)**

卷积膨胀宽度，默认为1

**property groups[#](#xir.Conv3d.groups)**

卷积分组数量，默认为1

**property pad_back[#](#xir.Conv3d.pad_back)**

卷积后方Pad，默认为0

**property pad_bottom[#](#xir.Conv3d.pad_bottom)**

卷积下方Pad，默认为0

**property pad_front[#](#xir.Conv3d.pad_front)**

卷积前方Pad，默认为0

**property pad_left[#](#xir.Conv3d.pad_left)**

卷积左方Pad，默认为0

**property pad_right[#](#xir.Conv3d.pad_right)**

卷积右方Pad，默认为0

**property pad_top[#](#xir.Conv3d.pad_top)**

卷积上方Pad，默认为0

**property padding_mode[#](#xir.Conv3d.padding_mode)**

卷积的pad模式，默认为ZEROS

**property stride_depth[#](#xir.Conv3d.stride_depth)**

卷积滑动深度，默认为1

**property stride_height[#](#xir.Conv3d.stride_height)**

卷积滑动高度，默认为1

**property stride_width[#](#xir.Conv3d.stride_width)**

卷积滑动宽度，默认为1

**Conv3dTranspose[#](#xir.Conv3dTranspose)**

[ConvTranspose3d](#xir.ConvTranspose3d) 的别名

**class ConvTranspose1d(*args, **kwargs)[#](#xir.ConvTranspose1d)**

Overloaded function.

- 
__init__(self: xir.ConvTranspose1d) -> None

默认构造函数

- 
__init__(self: xir.ConvTranspose1d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_width: int, pad_left: int, pad_right: int, dilation_width: int, output_pad_width: int, groups: int = 1) -> None

构造函数
:param  input:                                  输入
:param  weights:                                反卷积的权重
:param  bias:                                   反卷积的偏置
:param  stride_width:                   反卷积滑动宽度
:param  pad_left:                               反卷积左方Pad
:param  pad_right:                              反卷积右方Pad
:param  dilation_width:                 反卷积膨胀宽度
:param  output_pad_width:               反卷积宽度上输出Pad
:param  groups:                                 反卷积分组，默认为1

- 
__init__(self: xir.ConvTranspose1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ConvTranspose1d](#xir.ConvTranspose1d)[#](#xir.ConvTranspose1d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ConvTranspose1d](#xir.ConvTranspose1d), depth: int = 1) → [xir.ConvTranspose1d](#xir.ConvTranspose1d)[#](#xir.ConvTranspose1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_width[#](#xir.ConvTranspose1d.dilation_width)**

反卷积膨胀宽度，默认为1

**property groups[#](#xir.ConvTranspose1d.groups)**

反卷积分组数量，默认为1

**property output_pad_width[#](#xir.ConvTranspose1d.output_pad_width)**

反卷积宽度上输出Pad，默认为0

**property pad_left[#](#xir.ConvTranspose1d.pad_left)**

反卷积左方Pad，默认为0

**property pad_right[#](#xir.ConvTranspose1d.pad_right)**

反卷积右方Pad，默认为0

**property stride_width[#](#xir.ConvTranspose1d.stride_width)**

反卷积滑动宽度，默认为1

**class ConvTranspose2d(*args, **kwargs)[#](#xir.ConvTranspose2d)**

Overloaded function.

- 
__init__(self: xir.ConvTranspose2d) -> None

默认构造函数

- 
__init__(self: xir.ConvTranspose2d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_width: int, stride_height: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_width: int, dilation_height: int, output_pad_width: int, output_pad_height: int, groups: int = 1) -> None

构造函数
:param  input:                                  输入
:param  weights:                                反卷积的权重
:param  bias:                                   反卷积的偏置
:param  stride_width:                   反卷积滑动宽度
:param  stride_height:                  反卷积滑动高度
:param  pad_top:                                反卷积上方Pad
:param  pad_bottom:                             反卷积下方Pad
:param  pad_left:                               反卷积左方Pad
:param  pad_right:                              反卷积右方Pad
:param  dilation_width:                 反卷积膨胀宽度
:param  dilation_height:                反卷积膨胀高度
:param  output_pad_width:               反卷积宽度上输出Pad
:param  output_pad_height:              反卷积高度上输出Pad
:param  groups:                                 反卷积分组，默认为1

- 
__init__(self: xir.ConvTranspose2d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride: int, pad: int, dilation: int, output_pad: int, groups: int = 1) -> None

构造函数
:param  input:                                  输入
:param  weights:                                反卷积的权重
:param  bias:                                   反卷积的偏置
:param  stride:                                 反卷积滑动步长，宽度和高度相同
:param  pad:                                    反卷积的Pad，上下左右相同
:param  dilation:                               反卷积膨胀系数，宽度和高度相同
:param  output_pad:                             反卷积输出PAD，宽度和高度相同
:param  groups:                                 反卷积分组，默认为1

- 
__init__(self: xir.ConvTranspose2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ConvTranspose2d](#xir.ConvTranspose2d)[#](#xir.ConvTranspose2d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ConvTranspose2d](#xir.ConvTranspose2d), depth: int = 1) → [xir.ConvTranspose2d](#xir.ConvTranspose2d)[#](#xir.ConvTranspose2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_height[#](#xir.ConvTranspose2d.dilation_height)**

反卷积膨胀高度，默认为1

**property dilation_width[#](#xir.ConvTranspose2d.dilation_width)**

反卷积膨胀宽度，默认为1

**property groups[#](#xir.ConvTranspose2d.groups)**

反卷积分组数量，默认为1

**property output_pad_height[#](#xir.ConvTranspose2d.output_pad_height)**

反卷积高度上输出Pad，默认为0

**property output_pad_width[#](#xir.ConvTranspose2d.output_pad_width)**

反卷积宽度上输出Pad，默认为0

**property pad_bottom[#](#xir.ConvTranspose2d.pad_bottom)**

反卷积下方Pad，默认为0

**property pad_left[#](#xir.ConvTranspose2d.pad_left)**

反卷积左方Pad，默认为0

**property pad_right[#](#xir.ConvTranspose2d.pad_right)**

反卷积右方Pad，默认为0

**property pad_top[#](#xir.ConvTranspose2d.pad_top)**

反卷积上方Pad，默认为0

**property stride_height[#](#xir.ConvTranspose2d.stride_height)**

反卷积滑动高度，默认为1

**property stride_width[#](#xir.ConvTranspose2d.stride_width)**

反卷积滑动宽度，默认为1

**class ConvTranspose3d(*args, **kwargs)[#](#xir.ConvTranspose3d)**

Overloaded function.

- 
__init__(self: xir.ConvTranspose3d) -> None

默认构造函数

- 
__init__(self: xir.ConvTranspose3d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride_depth: int, stride_width: int, stride_height: int, pad_front: int, pad_back: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_depth: int, dilation_width: int, dilation_height: int, output_pad_depth: int, output_pad_width: int, output_pad_height: int, groups: int = 1) -> None

构造函数
:param  input:                                  输入
:param  weights:                                反卷积的权重
:param  bias:                                   反卷积的偏置
:param  stride_depth:                   反卷积滑动深度
:param  stride_width:                   反卷积滑动宽度
:param  stride_height:                  反卷积滑动高度
:param  pad_front:                              反卷积前方Pad
:param  pad_back:                               反卷积后方Pad
:param  pad_top:                                反卷积上方Pad
:param  pad_bottom:                             反卷积下方Pad
:param  pad_left:                               反卷积左方Pad
:param  pad_right:                              反卷积右方Pad
:param  dilation_depth:                 反卷积膨胀深度
:param  dilation_width:                 反卷积膨胀宽度
:param  dilation_height:                反卷积膨胀高度
:param  output_pad_depth:               反卷积深度上输出Pad
:param  output_pad_width:               反卷积宽度上输出Pad
:param  output_pad_height:              反卷积高度上输出Pad
:param  groups:                                 反卷积分组，默认为1

- 
__init__(self: xir.ConvTranspose3d, input: xir.Value, weights: xir.Value, bias: Optional[xir.Value], stride: int, pad: int, dilation: int, output_pad: int, groups: int = 1) -> None

构造函数
:param  input:                                  输入
:param  weights:                                反卷积的权重
:param  bias:                                   反卷积的偏置
:param  stride:                                 反卷积滑动步长，深度、宽度和高度相同
:param  pad:                                    反卷积的Pad，前后上下左右相同
:param  dilation:                               反卷积膨胀系数，深度、宽度和高度相同
:param  output_pad:                             反卷积输出PAD，深度、宽度和高度相同
:param  groups:                                 反卷积分组，默认为1

- 
__init__(self: xir.ConvTranspose3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ConvTranspose3d](#xir.ConvTranspose3d)[#](#xir.ConvTranspose3d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ConvTranspose3d](#xir.ConvTranspose3d), depth: int = 1) → [xir.ConvTranspose3d](#xir.ConvTranspose3d)[#](#xir.ConvTranspose3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_depth[#](#xir.ConvTranspose3d.dilation_depth)**

反卷积膨胀深度，默认为1

**property dilation_height[#](#xir.ConvTranspose3d.dilation_height)**

反卷积膨胀高度，默认为1

**property dilation_width[#](#xir.ConvTranspose3d.dilation_width)**

反卷积膨胀宽度，默认为1

**property groups[#](#xir.ConvTranspose3d.groups)**

反卷积分组数量，默认为1

**property output_pad_depth[#](#xir.ConvTranspose3d.output_pad_depth)**

反卷积深度上输出Pad，默认为0

**property output_pad_height[#](#xir.ConvTranspose3d.output_pad_height)**

反卷积高度上输出Pad，默认为0

**property output_pad_width[#](#xir.ConvTranspose3d.output_pad_width)**

反卷积宽度上输出Pad，默认为0

**property pad_back[#](#xir.ConvTranspose3d.pad_back)**

反卷积后方Pad，默认为0

**property pad_bottom[#](#xir.ConvTranspose3d.pad_bottom)**

反卷积下方Pad，默认为0

**property pad_front[#](#xir.ConvTranspose3d.pad_front)**

反卷积前方Pad，默认为0

**property pad_left[#](#xir.ConvTranspose3d.pad_left)**

反卷积左方Pad，默认为0

**property pad_right[#](#xir.ConvTranspose3d.pad_right)**

反卷积右方Pad，默认为0

**property pad_top[#](#xir.ConvTranspose3d.pad_top)**

反卷积上方Pad，默认为0

**property stride_depth[#](#xir.ConvTranspose3d.stride_depth)**

反卷积滑动深度，默认为1

**property stride_height[#](#xir.ConvTranspose3d.stride_height)**

反卷积滑动高度，默认为1

**property stride_width[#](#xir.ConvTranspose3d.stride_width)**

反卷积滑动宽度，默认为1

**class Copy(*args, **kwargs)[#](#xir.Copy)**

Overloaded function.

- 
__init__(self: xir.Copy) -> None

默认构造函数

- 
__init__(self: xir.Copy, input: xir.Value) -> None

构造函数
:param  input:  输入

- 
__init__(self: xir.Copy, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Copy](#xir.Copy)[#](#xir.Copy.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Copy](#xir.Copy), depth: int = 1) → [xir.Copy](#xir.Copy)[#](#xir.Copy.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Cos(*args, **kwargs)[#](#xir.Cos)**

Overloaded function.

- 
__init__(self: xir.Cos) -> None

默认构造函数

- 
__init__(self: xir.Cos, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Cos, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Cos](#xir.Cos)[#](#xir.Cos.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Cos](#xir.Cos), depth: int = 1) → [xir.Cos](#xir.Cos)[#](#xir.Cos.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Cosh(*args, **kwargs)[#](#xir.Cosh)**

Overloaded function.

- 
__init__(self: xir.Cosh) -> None

默认构造函数

- 
__init__(self: xir.Cosh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Cosh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Cosh](#xir.Cosh)[#](#xir.Cosh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Cosh](#xir.Cosh), depth: int = 1) → [xir.Cosh](#xir.Cosh)[#](#xir.Cosh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class CustomTarget(self: [xir.CustomTarget](#xir.CustomTarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.CustomTarget)**

表示Custom编译目标的类型

将父类强制转换为子类（该类型）

**static Init() → [xir.CustomTarget](#xir.CustomTarget)[#](#xir.CustomTarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.CustomTarget](#xir.CustomTarget), depth: int = 1) → [xir.CustomTarget](#xir.CustomTarget)[#](#xir.CustomTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Data(*args, **kwargs)[#](#xir.Data)**

表示数据的类型

Overloaded function.

- 
__init__(self: xir.Data) -> None

默认构造函数

- 
__init__(self: xir.Data, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**clone(self: [xir.Data](#xir.Data), depth: int = 1) → [xir.Data](#xir.Data)[#](#xir.Data.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dtype[#](#xir.Data.dtype)**

数据类型

**property mtype[#](#xir.Data.mtype)**

存储类型

**setDType(self: [xir.Data](#xir.Data), arg0: [xir.DataType](#xir.DataType)) → [xir.Data](#xir.Data)[#](#xir.Data.setDType)**

设置数据类型

**setMType(self: [xir.Data](#xir.Data), arg0: [xir.MemType](#xir.MemType)) → [xir.Data](#xir.Data)[#](#xir.Data.setMType)**

设置存储类型

**storageBits(self: [xir.Data](#xir.Data)) → int[#](#xir.Data.storageBits)**

获取存储位数

**storageBytes(self: [xir.Data](#xir.Data)) → int[#](#xir.Data.storageBytes)**

获取存储字节数

**class DataType(self: [xir.DataType](#xir.DataType), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.DataType)**

表示数据类型的类型

将父类强制转换为子类（该类型）

**bits(self: [xir.DataType](#xir.DataType)) → int[#](#xir.DataType.bits)**

获取该数据类型所占位数.

**bytes(self: [xir.DataType](#xir.DataType)) → int[#](#xir.DataType.bytes)**

获取该数据类型所占字节数.

**clone(self: [xir.DataType](#xir.DataType), depth: int = 1) → [xir.DataType](#xir.DataType)[#](#xir.DataType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**getNormratio(self: [xir.DataType](#xir.DataType)) → Optional[icraft::xir::NormratioArray][#](#xir.DataType.getNormratio)**

获取(可选的)归一化系数
:return:  如果该DataType是 NormalizedType 或 NormalizedQuantizedType,
则返回相应的归一化系数，否则返回None

**getScale(self: [xir.DataType](#xir.DataType)) → Optional[icraft::xir::QuantizedScaleArray][#](#xir.DataType.getScale)**

获取(可选的)量化缩放因子
:return:  如果该DataType是 QuantizedType,
则返回相应的量化缩放因子，否则返回std::nullopt

**getStorageType(self: [xir.DataType](#xir.DataType)) → icraft::xir::ScalarType[#](#xir.DataType.getStorageType)**

获取存储类型
:return:  如果该DataType是非量化类型，则返回本身；
如果该DataType是量化类型，则返回相应的storage_dtype；
如果该DataType是TensorType，对其element_dtype做以上处理

**getZeroPoints(self: [xir.DataType](#xir.DataType)) → Optional[List[int]][#](#xir.DataType.getZeroPoints)**

获取(可选的)量化的零点
:return:  如果该DataType是 QuantizedType,
则返回相应的量化的零点，否则返回std::nullopt

**numElements(self: [xir.DataType](#xir.DataType)) → int[#](#xir.DataType.numElements)**

获取数据类型的元素个数.

**setNormratio(self: [xir.DataType](#xir.DataType), normratio: List[float]) → bool[#](#xir.DataType.setNormratio)**

尝试设置归一化系数
:return:  如果该DataType是 NormalizedType 或 NormalizedQuantizedType,
则设置相应的归一化系数并返回True，否则返回False

**setScale(self: xir.DataType, scale: icraft::xir::QuantizedScaleArray) → bool[#](#xir.DataType.setScale)**

尝试设置量化缩放因子
:return:  如果该DataType是 QuantizedType,
则设置相应的量化缩放因子并返回true，否则返回false

**setStorageType(self: xir.DataType, type: icraft::xir::ScalarType) → None[#](#xir.DataType.setStorageType)**

获取存储类型
:return:  如果该DataType是非量化类型，则设置本身；
如果该DataType是量化类型，则设置相应的storage_dtype；
如果该DataType是TensorType，对其element_dtype做以上处理

**setZeroPoints(self: [xir.DataType](#xir.DataType), zero_points: List[int]) → bool[#](#xir.DataType.setZeroPoints)**

尝试设置量化的零点
:return:  如果该DataType是 QuantizedType,
则设置相应的量化的零点并返回true，否则返回false

**class DistrUnvalidValue(self: [xir.DistrUnvalidValue](#xir.DistrUnvalidValue), value: int)[#](#xir.DistrUnvalidValue)**

分布的无效值

Members:

ZERO : 无效值填充0

NONE : 无效值不存在

**property name[#](#xir.DistrUnvalidValue.name)**

**class Div(*args, **kwargs)[#](#xir.Div)**

Overloaded function.

- 
__init__(self: xir.Div) -> None

默认构造函数

- 
__init__(self: xir.Div, lhs: xir.Value, rhs: xir.Value, rounding_mode: icraft::xir::DivNode::Mode) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Div, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Div](#xir.Div)[#](#xir.Div.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Div](#xir.Div), depth: int = 1) → [xir.Div](#xir.Div)[#](#xir.Div.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class DivideScalar(*args, **kwargs)[#](#xir.DivideScalar)**

Overloaded function.

- 
__init__(self: xir.DivideScalar) -> None

默认构造函数

- 
__init__(self: xir.DivideScalar, input: xir.Value, divisor: float, rounding_mode: xir.RoundingMode = <RoundingMode.NONE: 0>) -> None

构造函数
:param  input:                  输入
:param  divisor:                除数
:param  rounding_mode:  取整模式

- 
__init__(self: xir.DivideScalar, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.DivideScalar](#xir.DivideScalar)[#](#xir.DivideScalar.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.DivideScalar](#xir.DivideScalar), depth: int = 1) → [xir.DivideScalar](#xir.DivideScalar)[#](#xir.DivideScalar.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property divisor[#](#xir.DivideScalar.divisor)**

除数

**property rounding_mode[#](#xir.DivideScalar.rounding_mode)**

取整模式

**class ELU(*args, **kwargs)[#](#xir.ELU)**

Overloaded function.

- 
__init__(self: xir.ELU) -> None

默认构造函数

- 
__init__(self: xir.ELU, input: xir.Value, alpha: float = 1.0) -> None

构造函数
:param  input:                  输入
:param  alpha:                  负半轴的系数

- 
__init__(self: xir.ELU, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ELU](#xir.ELU)[#](#xir.ELU.Init)**

创建一个初始化(非空)对象

**property alpha[#](#xir.ELU.alpha)**

负半轴的系数

**clone(self: [xir.ELU](#xir.ELU), depth: int = 1) → [xir.ELU](#xir.ELU)[#](#xir.ELU.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Einsum(*args, **kwargs)[#](#xir.Einsum)**

Overloaded function.

- 
__init__(self: xir.Einsum) -> None

默认构造函数

- 
__init__(self: xir.Einsum, inputs: List[xir.Value], equation: str) -> None

构造函数
:param  inputs:         输入
:param  equation:       求和标记

- 
__init__(self: xir.Einsum, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Einsum](#xir.Einsum)[#](#xir.Einsum.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Einsum](#xir.Einsum), depth: int = 1) → [xir.Einsum](#xir.Einsum)[#](#xir.Einsum.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property equation[#](#xir.Einsum.equation)**

求和标记

**Elu[#](#xir.Elu)**

[ELU](#xir.ELU) 的别名

**class Equal(*args, **kwargs)[#](#xir.Equal)**

Overloaded function.

- 
__init__(self: xir.Equal) -> None

默认构造函数

- 
__init__(self: xir.Equal, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.Equal, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Equal](#xir.Equal)[#](#xir.Equal.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Equal](#xir.Equal), depth: int = 1) → [xir.Equal](#xir.Equal)[#](#xir.Equal.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**exception Error[#](#xir.Error)**

**class ExpQuantizedScale(*args, **kwargs)[#](#xir.ExpQuantizedScale)**

Overloaded function.

- 
__init__(self: xir.ExpQuantizedScale) -> None

默认构造函数.

- 
__init__(self: xir.ExpQuantizedScale, m: int, exp: int, origin_scale: float) -> None

构造函数.
:param m:                               m*2^(-exp)中的m
:param exp:                             m*2^(-exp)中的exp
:param origin_scale:    未适配硬件的原始浮点缩放系数

- 
__init__(self: xir.ExpQuantizedScale, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ExpQuantizedScale](#xir.ExpQuantizedScale)[#](#xir.ExpQuantizedScale.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ExpQuantizedScale](#xir.ExpQuantizedScale), depth: int = 1) → [xir.ExpQuantizedScale](#xir.ExpQuantizedScale)[#](#xir.ExpQuantizedScale.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property exp[#](#xir.ExpQuantizedScale.exp)**

m*2^(-exp)中的exp

**property m[#](#xir.ExpQuantizedScale.m)**

m*2^(-exp)中的m

**class ExpQuantizedScaleArray(*args, **kwargs)[#](#xir.ExpQuantizedScaleArray)**

Overloaded function.

- 
__init__(self: xir.ExpQuantizedScaleArray) -> None

默认构造函数.

- 
__init__(self: xir.ExpQuantizedScaleArray, m: List[int], exp: List[int], origin_scale: List[float], axis: int = -1) -> None

构造函数.
:param m:                               m*2^(-exp)中的m
:param exp:                             m*2^(-exp)中的exp
:param origin_scale:    未适配硬件的原始浮点缩放系数
:param axis:                    三种系数对应的维度，默认为-1，表示最后一维

- 
__init__(self: xir.ExpQuantizedScaleArray, lhs: xir.QuantizedScaleArray, rhs: xir.QuantizedScaleArray) -> None

构造函数.
:param lhs:             待拼接输入1
:param rhs:             待拼接输入2

- 
__init__(self: xir.ExpQuantizedScaleArray, n: int, val: xir.QuantizedScale) -> None

构造函数，从初始值构造.
:param n:               元素数量
:param val:             初始值

- 
__init__(self: xir.ExpQuantizedScaleArray, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ExpQuantizedScaleArray](#xir.ExpQuantizedScaleArray)[#](#xir.ExpQuantizedScaleArray.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ExpQuantizedScaleArray](#xir.ExpQuantizedScaleArray), depth: int = 1) → [xir.ExpQuantizedScaleArray](#xir.ExpQuantizedScaleArray)[#](#xir.ExpQuantizedScaleArray.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property exp[#](#xir.ExpQuantizedScaleArray.exp)**

m*2^(-exp)中的exp

**property m[#](#xir.ExpQuantizedScaleArray.m)**

m*2^(-exp)中的m

**setAxis(self: [xir.ExpQuantizedScaleArray](#xir.ExpQuantizedScaleArray), axis: int) → [xir.ExpQuantizedScaleArray](#xir.ExpQuantizedScaleArray)[#](#xir.ExpQuantizedScaleArray.setAxis)**

**class Expand(*args, **kwargs)[#](#xir.Expand)**

Overloaded function.

- 
__init__(self: xir.Expand) -> None

默认构造函数

- 
__init__(self: xir.Expand, input: xir.Value, sizes: List[int]) -> None

构造函数
:param  input:          输入
:param  dims:           期望扩充到的维度

- 
__init__(self: xir.Expand, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Expand](#xir.Expand)[#](#xir.Expand.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Expand](#xir.Expand), depth: int = 1) → [xir.Expand](#xir.Expand)[#](#xir.Expand.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property sizes[#](#xir.Expand.sizes)**

期望扩充到的维度

**class ExternalMem(*args, **kwargs)[#](#xir.ExternalMem)**

Overloaded function.

- 
__init__(self: xir.ExternalMem) -> None

默认构造函数

- 
__init__(self: xir.ExternalMem, addr: int) -> None

构造函数，从地址构造
:param addr:    ETM上的地址

- 
__init__(self: xir.ExternalMem, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ExternalMem](#xir.ExternalMem)[#](#xir.ExternalMem.Init)**

创建一个初始化(非空)对象

**property addr[#](#xir.ExternalMem.addr)**

ETM上的地址

**clone(self: [xir.ExternalMem](#xir.ExternalMem), depth: int = 1) → [xir.ExternalMem](#xir.ExternalMem)[#](#xir.ExternalMem.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**setAddr(self: [xir.ExternalMem](#xir.ExternalMem), addr: int) → [xir.ExternalMem](#xir.ExternalMem)[#](#xir.ExternalMem.setAddr)**

设置地址
:param addr:    ETM上的地址

**class FPGATarget(self: [xir.FPGATarget](#xir.FPGATarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.FPGATarget)**

表示FPGA编译目标的类型

将父类强制转换为子类（该类型）

**static Init() → [xir.FPGATarget](#xir.FPGATarget)[#](#xir.FPGATarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.FPGATarget](#xir.FPGATarget), depth: int = 1) → [xir.FPGATarget](#xir.FPGATarget)[#](#xir.FPGATarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class FloatImm(*args, **kwargs)[#](#xir.FloatImm)**

表示浮点立即数

Overloaded function.

- 
__init__(self: xir.FloatImm) -> None

默认构造函数

- 
__init__(self: xir.FloatImm, value: float, dtype: xir.ScalarType, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB01AB0>) -> None

构造函数
:param value:           立即数的值
:param dtype:           立即数的数据类型
:param mtype:           立即数的存储类型

- 
__init__(self: xir.FloatImm, value: float, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB04930>) -> None

构造函数
:param value:           立即数的值
:param mtype:           立即数的存储类型

- 
__init__(self: xir.FloatImm, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.FloatImm](#xir.FloatImm)[#](#xir.FloatImm.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.FloatImm](#xir.FloatImm), depth: int = 1) → [xir.FloatImm](#xir.FloatImm)[#](#xir.FloatImm.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property value[#](#xir.FloatImm.value)**

立即数的值

**class FloatType(*args, **kwargs)[#](#xir.FloatType)**

表示浮点数据类型的类型

Overloaded function.

- 
__init__(self: xir.FloatType) -> None

默认构造函数

- 
__init__(self: xir.FloatType, emax: int, emin: int, precision: int, bits: int) -> None

构造函数
:param emax:            指数的最大值
:param emin:            指数的最小值
:param precision:       尾数的精度(位数)
:param bits:            浮点数的位数

- 
__init__(self: xir.FloatType, sem: xir.Semantics) -> None

构造函数
:param sem:             浮点语义

- 
__init__(self: xir.FloatType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static BF16() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.BF16)**

创建一个bf16

**static FP16() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.FP16)**

创建一个fp16

**static FP32() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.FP32)**

创建一个fp32

**static FP64() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.FP64)**

创建一个fp64

**static FPE6M9() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.FPE6M9)**

创建一个fpe6m9

**static FPE7M8() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.FPE7M8)**

创建一个fpe7m8

**static Init() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.Init)**

创建一个初始化(非空)对象

**static TF32() → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.TF32)**

创建一个tf32

**clone(self: [xir.FloatType](#xir.FloatType), depth: int = 1) → [xir.FloatType](#xir.FloatType)[#](#xir.FloatType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**semantics(self: [xir.FloatType](#xir.FloatType)) → [xir.Semantics](#xir.Semantics)[#](#xir.FloatType.semantics)**

获取该浮点类型的浮点语义

**class Framework(self: [xir.Framework](#xir.Framework), value: int)[#](#xir.Framework)**

表示前端框架的枚举

Members:

PYTORCH : Pytorch框架

CAFFE : Caffe框架

TENSORFLOW : Tensorflow框架

DARKNET : Darknet框架

ONNX : ONNX框架

**property name[#](#xir.Framework.name)**

**FullVersion() → str[#](#xir.FullVersion)**

获取全版本号

**class GELU(*args, **kwargs)[#](#xir.GELU)**

Overloaded function.

- 
__init__(self: xir.GELU) -> None

默认构造函数

- 
__init__(self: xir.GELU, input: xir.Value) -> None

构造函数
:param  input:                  输入

- 
__init__(self: xir.GELU, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.GELU](#xir.GELU)[#](#xir.GELU.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.GELU](#xir.GELU), depth: int = 1) → [xir.GELU](#xir.GELU)[#](#xir.GELU.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**Gelu[#](#xir.Gelu)**

[GELU](#xir.GELU) 的别名

**class Greater(*args, **kwargs)[#](#xir.Greater)**

Overloaded function.

- 
__init__(self: xir.Greater) -> None

默认构造函数

- 
__init__(self: xir.Greater, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.Greater, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Greater](#xir.Greater)[#](#xir.Greater.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Greater](#xir.Greater), depth: int = 1) → [xir.Greater](#xir.Greater)[#](#xir.Greater.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class GreaterEqual(*args, **kwargs)[#](#xir.GreaterEqual)**

Overloaded function.

- 
__init__(self: xir.GreaterEqual) -> None

默认构造函数

- 
__init__(self: xir.GreaterEqual, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.GreaterEqual, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.GreaterEqual](#xir.GreaterEqual)[#](#xir.GreaterEqual.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.GreaterEqual](#xir.GreaterEqual), depth: int = 1) → [xir.GreaterEqual](#xir.GreaterEqual)[#](#xir.GreaterEqual.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class HardOp(*args, **kwargs)[#](#xir.HardOp)**

Overloaded function.

- 
__init__(self: xir.HardOp) -> None

默认构造函数

- 
__init__(self: xir.HardOp, arg0: List[xir.Value], arg1: List[xir.Params], arg2: List[xir.Params], arg3: List[int], arg4: Dict[str, int]) -> None

- 
__init__(self: xir.HardOp, arg0: List[xir.Value], arg1: xir.Params, arg2: xir.Params, arg3: List[int], arg4: Dict[str, int]) -> None

- 
__init__(self: xir.HardOp, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.HardOp](#xir.HardOp)[#](#xir.HardOp.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.HardOp](#xir.HardOp), depth: int = 1) → [xir.HardOp](#xir.HardOp)[#](#xir.HardOp.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property device_info[#](#xir.HardOp.device_info)**

设备信息

**property instr[#](#xir.HardOp.instr)**

指令

**property origin_ops_id[#](#xir.HardOp.origin_ops_id)**

原始的Op ID列表

**property params[#](#xir.HardOp.params)**

参数

**class Hardshrink(*args, **kwargs)[#](#xir.Hardshrink)**

Overloaded function.

- 
__init__(self: xir.Hardshrink) -> None

默认构造函数

- 
__init__(self: xir.Hardshrink, input: xir.Value, lambda: float = 0.5) -> None

构造函数
:param  input:          输入
:param  lambda:         系数λ，默认为0.5

- 
__init__(self: xir.Hardshrink, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Hardshrink](#xir.Hardshrink)[#](#xir.Hardshrink.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Hardshrink](#xir.Hardshrink), depth: int = 1) → [xir.Hardshrink](#xir.Hardshrink)[#](#xir.Hardshrink.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property lambda[#](#xir.Hardshrink.lambda)**

系数λ，默认为0.5

**class Hardsigmoid(*args, **kwargs)[#](#xir.Hardsigmoid)**

Overloaded function.

- 
__init__(self: xir.Hardsigmoid) -> None

默认构造函数

- 
__init__(self: xir.Hardsigmoid, input: xir.Value, alpha: float = 0.1666666716337204, beta: float = 0.5) -> None

构造函数
:param  input:  输入
:param  alpha:  Hardsigmoid的系数α，默认为1/6
:param  beta:   Hardsigmoid的系数β，默认为0.5

- 
__init__(self: xir.Hardsigmoid, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Hardsigmoid](#xir.Hardsigmoid)[#](#xir.Hardsigmoid.Init)**

创建一个初始化(非空)对象

**property alpha[#](#xir.Hardsigmoid.alpha)**

系数α

**property beta[#](#xir.Hardsigmoid.beta)**

系数β

**clone(self: [xir.Hardsigmoid](#xir.Hardsigmoid), depth: int = 1) → [xir.Hardsigmoid](#xir.Hardsigmoid)[#](#xir.Hardsigmoid.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Hardswish(*args, **kwargs)[#](#xir.Hardswish)**

Overloaded function.

- 
__init__(self: xir.Hardswish) -> None

默认构造函数

- 
__init__(self: xir.Hardswish, input: xir.Value) -> None

构造函数
:param  input:                  输入

- 
__init__(self: xir.Hardswish, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Hardswish](#xir.Hardswish)[#](#xir.Hardswish.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Hardswish](#xir.Hardswish), depth: int = 1) → [xir.Hardswish](#xir.Hardswish)[#](#xir.Hardswish.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Hardtanh(*args, **kwargs)[#](#xir.Hardtanh)**

Overloaded function.

- 
__init__(self: xir.Hardtanh) -> None

默认构造函数

- 
__init__(self: xir.Hardtanh, input: xir.Value, min_val: float = -1.0, max_val: float = 1.0) -> None

构造函数
:param  input:          输入
:param  min_val:        Hardtanh的最小值，默认为 -1.0
:param  max_val:        Hardtanh的最大值，默认为  1.0

- 
__init__(self: xir.Hardtanh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Hardtanh](#xir.Hardtanh)[#](#xir.Hardtanh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Hardtanh](#xir.Hardtanh), depth: int = 1) → [xir.Hardtanh](#xir.Hardtanh)[#](#xir.Hardtanh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property max_val[#](#xir.Hardtanh.max_val)**

Hardtanh的最大值，默认为  1.0

**property min_val[#](#xir.Hardtanh.min_val)**

Hardtanh的最小值，默认为 -1.0

**class HostMem(*args, **kwargs)[#](#xir.HostMem)**

表示Host存储类型

Overloaded function.

- 
__init__(self: xir.HostMem) -> None

默认构造函数

- 
__init__(self: xir.HostMem, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.HostMem](#xir.HostMem)[#](#xir.HostMem.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.HostMem](#xir.HostMem), depth: int = 1) → [xir.HostMem](#xir.HostMem)[#](#xir.HostMem.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class HostTarget(self: [xir.HostTarget](#xir.HostTarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.HostTarget)**

表示Host编译目标的类型

将父类强制转换为子类（该类型）

**static Init() → [xir.HostTarget](#xir.HostTarget)[#](#xir.HostTarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.HostTarget](#xir.HostTarget), depth: int = 1) → [xir.HostTarget](#xir.HostTarget)[#](#xir.HostTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**ICRAFT_REGISTER_PASS(arg0: function) → None[#](#xir.ICRAFT_REGISTER_PASS)**

Pass注册辅助函数.

**class Input(*args, **kwargs)[#](#xir.Input)**

表示输入算子

Overloaded function.

- 
__init__(self: xir.Input) -> None

默认构造函数

- 
__init__(self: xir.Input, [*](#id1)args) -> None

构造函数，根据数据类型列表构造Input
该方法会根据指定的数据类型创建Input的输出
:param dtypes:  数据类型列表或可变参数

- 
__init__(self: xir.Input, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Input](#xir.Input)[#](#xir.Input.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Input](#xir.Input), depth: int = 1) → [xir.Input](#xir.Input)[#](#xir.Input.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class InstanceNorm1d(*args, **kwargs)[#](#xir.InstanceNorm1d)**

Overloaded function.

- 
__init__(self: xir.InstanceNorm1d) -> None

默认构造函数

- 
__init__(self: xir.InstanceNorm1d, input: xir.Value, eps: float = 1e-05, gamma: Optional[xir.Params] = None, beta: Optional[xir.Params] = None) -> None

构造函数
:param  input:          输入
:param  axis:           待归一化的维度
:param  eps:            防止除以0的小浮点数，默认为1e-5
:param  gamma:          输入
:param  beta:           输入

- 
__init__(self: xir.InstanceNorm1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.InstanceNorm1d](#xir.InstanceNorm1d)[#](#xir.InstanceNorm1d.Init)**

创建一个初始化(非空)对象

**property beta[#](#xir.InstanceNorm1d.beta)**

仿射计算中的bias

**clone(self: [xir.InstanceNorm1d](#xir.InstanceNorm1d), depth: int = 1) → [xir.InstanceNorm1d](#xir.InstanceNorm1d)[#](#xir.InstanceNorm1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property eps[#](#xir.InstanceNorm1d.eps)**

防止除以0的小浮点数，默认为1e-5

**property gamma[#](#xir.InstanceNorm1d.gamma)**

仿射计算中的weight

**class InstanceNorm2d(*args, **kwargs)[#](#xir.InstanceNorm2d)**

Overloaded function.

- 
__init__(self: xir.InstanceNorm2d) -> None

默认构造函数

- 
__init__(self: xir.InstanceNorm2d, input: xir.Value, eps: float = 1e-05, gamma: Optional[xir.Params] = None, beta: Optional[xir.Params] = None) -> None

构造函数
:param  input:          输入
:param  axis:           待归一化的维度
:param  eps:            防止除以0的小浮点数，默认为1e-5
:param  gamma:          输入
:param  beta:           输入

- 
__init__(self: xir.InstanceNorm2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.InstanceNorm2d](#xir.InstanceNorm2d)[#](#xir.InstanceNorm2d.Init)**

创建一个初始化(非空)对象

**property beta[#](#xir.InstanceNorm2d.beta)**

仿射计算中的bias

**clone(self: [xir.InstanceNorm2d](#xir.InstanceNorm2d), depth: int = 1) → [xir.InstanceNorm2d](#xir.InstanceNorm2d)[#](#xir.InstanceNorm2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property eps[#](#xir.InstanceNorm2d.eps)**

防止除以0的小浮点数，默认为1e-5

**property gamma[#](#xir.InstanceNorm2d.gamma)**

仿射计算中的weight

**class InstanceNorm3d(*args, **kwargs)[#](#xir.InstanceNorm3d)**

Overloaded function.

- 
__init__(self: xir.InstanceNorm3d) -> None

默认构造函数

- 
__init__(self: xir.InstanceNorm3d, input: xir.Value, eps: float = 1e-05, gamma: Optional[xir.Params] = None, beta: Optional[xir.Params] = None) -> None

构造函数
:param  input:          输入
:param  axis:           待归一化的维度
:param  eps:            防止除以0的小浮点数，默认为1e-5
:param  gamma:          输入
:param  beta:           输入

- 
__init__(self: xir.InstanceNorm3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.InstanceNorm3d](#xir.InstanceNorm3d)[#](#xir.InstanceNorm3d.Init)**

创建一个初始化(非空)对象

**property beta[#](#xir.InstanceNorm3d.beta)**

仿射计算中的bias

**clone(self: [xir.InstanceNorm3d](#xir.InstanceNorm3d), depth: int = 1) → [xir.InstanceNorm3d](#xir.InstanceNorm3d)[#](#xir.InstanceNorm3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property eps[#](#xir.InstanceNorm3d.eps)**

防止除以0的小浮点数，默认为1e-5

**property gamma[#](#xir.InstanceNorm3d.gamma)**

仿射计算中的weight

**class IntImm(*args, **kwargs)[#](#xir.IntImm)**

表示整型立即数

Overloaded function.

- 
__init__(self: xir.IntImm) -> None

默认构造函数

- 
__init__(self: xir.IntImm, value: int, dtype: xir.ScalarType, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB01070>) -> None

构造函数
:param value:           立即数的值
:param dtype:           立即数的数据类型
:param mtype:           立即数的存储类型

- 
__init__(self: xir.IntImm, value: int, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB01C30>) -> None

构造函数
:param value:           立即数的值
:param mtype:           立即数的存储类型

- 
__init__(self: xir.IntImm, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.IntImm](#xir.IntImm)[#](#xir.IntImm.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.IntImm](#xir.IntImm), depth: int = 1) → [xir.IntImm](#xir.IntImm)[#](#xir.IntImm.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property value[#](#xir.IntImm.value)**

立即数的值

**class IntegerType(*args, **kwargs)[#](#xir.IntegerType)**

表示整型数据类型的类型

Overloaded function.

- 
__init__(self: xir.IntegerType) -> None

默认构造函数

- 
__init__(self: xir.IntegerType, sign: bool, bits: int) -> None

构造函数
:param sign:    整型的符号
:param bits:    整型的位数

- 
__init__(self: xir.IntegerType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.Init)**

创建一个初始化(非空)对象

**static SInt(N: int) → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.SInt)**

创建一个指定位数的sint

**static SInt16() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.SInt16)**

创建一个sint16

**static SInt32() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.SInt32)**

创建一个sint32

**static SInt64() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.SInt64)**

创建一个sint64

**static SInt8() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.SInt8)**

创建一个sint8

**static UInt(N: int) → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.UInt)**

创建一个指定位数的uint

**static UInt16() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.UInt16)**

创建一个uint16

**static UInt32() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.UInt32)**

创建一个uint32

**static UInt64() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.UInt64)**

创建一个uint64

**static UInt8() → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.UInt8)**

创建一个uint8

**clone(self: [xir.IntegerType](#xir.IntegerType), depth: int = 1) → [xir.IntegerType](#xir.IntegerType)[#](#xir.IntegerType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**exception InternalError[#](#xir.InternalError)**

**class Interpolation(self: [xir.Interpolation](#xir.Interpolation), value: int)[#](#xir.Interpolation)**

Upsample插值方式

Members:

NEAREST : 最近邻插值

BILINEAR : 双线性插值

BICUBIC : 双三次插值

**property name[#](#xir.Interpolation.name)**

**IsModified() → bool[#](#xir.IsModified)**

检查是否有修改

**IsOp(*args, **kwargs)[#](#xir.IsOp)**

Overloaded function.

- 
IsOp(type_key: str, [*](#id3)args) -> xir.OpPattern

构造一个匹配算子的模式, 匹配指定的算子类型
:param type_key:        算子类型字符串
:param args:            算子输入列表或可变参数

- 
IsOp(type: type, [*](#id5)args) -> xir.OpPattern

构造一个匹配算子的模式, 匹配指定的算子类型
:param type:    算子类型
:param args:    算子输入列表或可变参数

- 
IsOp(type: List[type], [*](#id7)args) -> xir.OpPattern

构造一个匹配算子的模式, 匹配指定的算子类型
:param type:    算子类型
:param args:    算子输入列表或可变参数

- 
IsOp([*](#id9)args) -> xir.OpPattern

构造一个匹配算子的模式, 匹配指定的算子类型
:param args:    算子输入列表或可变参数

**IsOptionalOp(*args, **kwargs)[#](#xir.IsOptionalOp)**

Overloaded function.

- 
IsOptionalOp(type_key: str, [*](#id11)args) -> xir.OptionalOpPattern

构造一个匹配可选算子的模式, 匹配指定的算子类型
:param type_key:        算子类型字符串
:param args:            算子输入列表或可变参数

- 
IsOptionalOp(type: type, [*](#id13)args) -> xir.OptionalOpPattern

构造一个匹配可选算子的模式, 匹配指定的算子类型
:param type:    算子类型
:param args:    算子输入列表或可变参数

- 
IsOptionalOp([*](#id15)args) -> xir.OptionalOpPattern

构造一个匹配可选算子的模式, 匹配指定的算子类型
:param args:    算子输入列表或可变参数

**class LayerNorm(*args, **kwargs)[#](#xir.LayerNorm)**

Overloaded function.

- 
__init__(self: xir.LayerNorm) -> None

默认构造函数

- 
__init__(self: xir.LayerNorm, input: xir.Value, axis: List[int], eps: float = 1e-05, gamma: Optional[xir.Params] = None, beta: Optional[xir.Params] = None) -> None

构造函数
:param  input:          输入
:param  axis:           待归一化的维度
:param  eps:            防止除以0的小浮点数，默认为1e-5
:param  gamma:          输入
:param  beta:           输入

- 
__init__(self: xir.LayerNorm, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.LayerNorm](#xir.LayerNorm)[#](#xir.LayerNorm.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.LayerNorm.axis)**

待归一化的维度

**property beta[#](#xir.LayerNorm.beta)**

仿射计算中的bias

**clone(self: [xir.LayerNorm](#xir.LayerNorm), depth: int = 1) → [xir.LayerNorm](#xir.LayerNorm)[#](#xir.LayerNorm.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property eps[#](#xir.LayerNorm.eps)**

防止除以0的小浮点数，默认为1e-5

**property gamma[#](#xir.LayerNorm.gamma)**

仿射计算中的weight

**Layernorm[#](#xir.Layernorm)**

[LayerNorm](#xir.LayerNorm) 的别名

**class Layout(*args, **kwargs)[#](#xir.Layout)**

表示排布的类型

Overloaded function.

- 
__init__(self: xir.Layout) -> None

默认构造函数

- 
__init__(self: xir.Layout, axis: List[xir.AxisName]) -> None

构造函数
:param axis:            表示坐标轴的列表

- 
__init__(self: xir.Layout, layout: str) -> None

构造函数，从字符串构造
:param layout:          表示Layout的字符串

- 
__init__(self: xir.Layout, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**C(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.C)**

向Layout中添加坐标轴C

**static CheckAxisNameUpper(c: str) → bool[#](#xir.Layout.CheckAxisNameUpper)**

检查坐标轴的字符名是否是大写
:param c:                               坐标轴的字符名

**D(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.D)**

向Layout中添加坐标轴D

**static Default(size: int = 0) → [xir.Layout](#xir.Layout)[#](#xir.Layout.Default)**

创建一个默认Layout

**H(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.H)**

向Layout中添加坐标轴H

**static HWIO() → [xir.Layout](#xir.Layout)[#](#xir.Layout.HWIO)**

创建一个HWIO

**I(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.I)**

向Layout中添加坐标轴I

**static Init() → [xir.Layout](#xir.Layout)[#](#xir.Layout.Init)**

创建一个初始化(非空)对象

**N(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.N)**

向Layout中添加坐标轴N

**static NCHW() → [xir.Layout](#xir.Layout)[#](#xir.Layout.NCHW)**

创建一个NCHW

**static NHWC() → [xir.Layout](#xir.Layout)[#](#xir.Layout.NHWC)**

创建一个NHWC

**O(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.O)**

向Layout中添加坐标轴O

**static OIHW() → [xir.Layout](#xir.Layout)[#](#xir.Layout.OIHW)**

创建一个OIHW

**W(self: [xir.Layout](#xir.Layout)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.W)**

向Layout中添加坐标轴W

**X(self: [xir.Layout](#xir.Layout), num: int = 1) → [xir.Layout](#xir.Layout)[#](#xir.Layout.X)**

向Layout中添加坐标轴*, [*](#id17)表示无名坐标
:param num:             坐标轴*的个数

**property axis_names[#](#xir.Layout.axis_names)**

坐标轴的序列

**c(*args, **kwargs)[#](#xir.Layout.c)**

Overloaded function.

- 
c(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴c
:param unit:    坐标轴的单位长度

- 
c(self: xir.Layout) -> int

获取坐标轴c的单位长度

**clone(self: [xir.Layout](#xir.Layout), depth: int = 1) → [xir.Layout](#xir.Layout)[#](#xir.Layout.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**d(*args, **kwargs)[#](#xir.Layout.d)**

Overloaded function.

- 
d(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴d
:param unit:    坐标轴的单位长度

- 
d(self: xir.Layout) -> int

获取坐标轴d的单位长度

**eraseAxis(self: [xir.Layout](#xir.Layout), index: int) → [xir.Layout](#xir.Layout)[#](#xir.Layout.eraseAxis)**

删除坐标轴
:param index:                   被删除的位置索引

**get(self: [xir.Layout](#xir.Layout), c: str) → icraft::xir::Optional<icraft::xir::AxisName>[#](#xir.Layout.get)**

获取Layout中的某一坐标轴
:param c:               字符表示的坐标轴
:return:                若坐标轴不存在则返回None

**getAxisCharName(self: [xir.Layout](#xir.Layout), index: int) → str[#](#xir.Layout.getAxisCharName)**

获取指定索引位置的坐标轴字符名称
:param index:   索引位置

**getIndexOf(self: [xir.Layout](#xir.Layout), c: str) → int[#](#xir.Layout.getIndexOf)**

获取指定坐标轴在Layout中的位置索引
:param c:       字符表示的坐标轴

**h(*args, **kwargs)[#](#xir.Layout.h)**

Overloaded function.

- 
h(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴h
:param unit:    坐标轴的单位长度

- 
h(self: xir.Layout) -> int

获取坐标轴h的单位长度

**has(self: [xir.Layout](#xir.Layout), c: str) → bool[#](#xir.Layout.has)**

检查Layout中是否包含某一坐标轴
:param c:               字符表示的坐标轴

**i(*args, **kwargs)[#](#xir.Layout.i)**

Overloaded function.

- 
i(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴i
:param unit:    坐标轴的单位长度

- 
i(self: xir.Layout) -> int

获取坐标轴i的单位长度

**insertAxis(self: [xir.Layout](#xir.Layout), index: int, axis_name: [xir.AxisName](#xir.AxisName)) → [xir.Layout](#xir.Layout)[#](#xir.Layout.insertAxis)**

插入坐标轴
:param index:                   被插入的位置索引
:param axis_name:               被插入的坐标轴

**isDefault(self: [xir.Layout](#xir.Layout)) → bool[#](#xir.Layout.isDefault)**

检查该Layout是否是layout(default)

**n(*args, **kwargs)[#](#xir.Layout.n)**

Overloaded function.

- 
n(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴n
:param unit:    坐标轴的单位长度

- 
n(self: xir.Layout) -> int

获取坐标轴n的单位长度

**numAxis(self: [xir.Layout](#xir.Layout)) → int[#](#xir.Layout.numAxis)**

获取Layout中的坐标轴数量

**o(*args, **kwargs)[#](#xir.Layout.o)**

Overloaded function.

- 
o(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴o
:param unit:    坐标轴的单位长度

- 
o(self: xir.Layout) -> int

获取坐标轴o的单位长度

**swapAxis(self: [xir.Layout](#xir.Layout), left_index: int, right_index: int) → [xir.Layout](#xir.Layout)[#](#xir.Layout.swapAxis)**

交换两个坐标轴
:param left_index:              被交换的索引之一
:param right_index:             被交换的索引之二

**toString(self: [xir.Layout](#xir.Layout)) → str[#](#xir.Layout.toString)**

获取字符串形式的Layout

**w(*args, **kwargs)[#](#xir.Layout.w)**

Overloaded function.

- 
w(self: xir.Layout, unit: int) -> xir.Layout

向Layout中添加坐标轴w
:param unit:    坐标轴的单位长度

- 
w(self: xir.Layout) -> int

获取坐标轴w的单位长度

**class Less(*args, **kwargs)[#](#xir.Less)**

Overloaded function.

- 
__init__(self: xir.Less) -> None

默认构造函数

- 
__init__(self: xir.Less, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.Less, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Less](#xir.Less)[#](#xir.Less.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Less](#xir.Less), depth: int = 1) → [xir.Less](#xir.Less)[#](#xir.Less.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class LessEqual(*args, **kwargs)[#](#xir.LessEqual)**

Overloaded function.

- 
__init__(self: xir.LessEqual) -> None

默认构造函数

- 
__init__(self: xir.LessEqual, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.LessEqual, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.LessEqual](#xir.LessEqual)[#](#xir.LessEqual.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.LessEqual](#xir.LessEqual), depth: int = 1) → [xir.LessEqual](#xir.LessEqual)[#](#xir.LessEqual.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Log(*args, **kwargs)[#](#xir.Log)**

Overloaded function.

- 
__init__(self: xir.Log) -> None

默认构造函数

- 
__init__(self: xir.Log, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Log, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Log](#xir.Log)[#](#xir.Log.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Log](#xir.Log), depth: int = 1) → [xir.Log](#xir.Log)[#](#xir.Log.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class LogSigmoid(*args, **kwargs)[#](#xir.LogSigmoid)**

Overloaded function.

- 
__init__(self: xir.LogSigmoid) -> None

默认构造函数

- 
__init__(self: xir.LogSigmoid, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.LogSigmoid, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.LogSigmoid](#xir.LogSigmoid)[#](#xir.LogSigmoid.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.LogSigmoid](#xir.LogSigmoid), depth: int = 1) → [xir.LogSigmoid](#xir.LogSigmoid)[#](#xir.LogSigmoid.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class LogSoftmax(*args, **kwargs)[#](#xir.LogSoftmax)**

Overloaded function.

- 
__init__(self: xir.LogSoftmax) -> None

默认构造函数

- 
__init__(self: xir.LogSoftmax, input: xir.Value, axis: int = -1) -> None

构造函数
:param  input:          输入
:param  axis:           指定LogSoftmax的维度，默认为-1，表示最后一维

- 
__init__(self: xir.LogSoftmax, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.LogSoftmax](#xir.LogSoftmax)[#](#xir.LogSoftmax.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.LogSoftmax.axis)**

指定LogSoftmax的维度，默认为-1，表示最后一维

**clone(self: [xir.LogSoftmax](#xir.LogSoftmax), depth: int = 1) → [xir.LogSoftmax](#xir.LogSoftmax)[#](#xir.LogSoftmax.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**MainVersion() → str[#](#xir.MainVersion)**

获取版本号

**MajorVersionNum() → int[#](#xir.MajorVersionNum)**

获取主版本号

**class Matmul(*args, **kwargs)[#](#xir.Matmul)**

Overloaded function.

- 
__init__(self: xir.Matmul) -> None

默认构造函数

- 
__init__(self: xir.Matmul, x: xir.Value, k: xir.Value, b: Optional[xir.Value]) -> None

构造函数，y = x * k + b
:param  x:              因数之一
:param  k:              因数之二
:param  b:              偏置，可选

- 
__init__(self: xir.Matmul, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Matmul](#xir.Matmul)[#](#xir.Matmul.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Matmul](#xir.Matmul), depth: int = 1) → [xir.Matmul](#xir.Matmul)[#](#xir.Matmul.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property cut_scale[#](#xir.Matmul.cut_scale)**

硬件截位时的系数

**class Max(*args, **kwargs)[#](#xir.Max)**

Overloaded function.

- 
__init__(self: xir.Max) -> None

默认构造函数

- 
__init__(self: xir.Max, input: xir.Value, dim: Optional[xir.IntImm] = None, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求最大值索引的维度（支持负数索引）
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Max, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Max](#xir.Max)[#](#xir.Max.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Max](#xir.Max), depth: int = 1) → [xir.Max](#xir.Max)[#](#xir.Max.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Max.dim)**

进行求最大值索引的维度（支持负数索引）

**property keepdim[#](#xir.Max.keepdim)**

是否保持维度不变

**class MaxPool1d(*args, **kwargs)[#](#xir.MaxPool1d)**

Overloaded function.

- 
__init__(self: xir.MaxPool1d) -> None

默认构造函数

- 
__init__(self: xir.MaxPool1d, input: xir.Value, pool_width: int, stride_width: int, pad_left: int, pad_right: int, dilation_width: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_width:                             池化窗口宽度
:param  stride_width:                   池化滑动宽度
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  dilation_width:                 池化膨胀宽度

- 
__init__(self: xir.MaxPool1d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.MaxPool1d](#xir.MaxPool1d)[#](#xir.MaxPool1d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.MaxPool1d](#xir.MaxPool1d), depth: int = 1) → [xir.MaxPool1d](#xir.MaxPool1d)[#](#xir.MaxPool1d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_width[#](#xir.MaxPool1d.dilation_width)**

池化膨胀宽度，默认为1

**property pad_left[#](#xir.MaxPool1d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.MaxPool1d.pad_right)**

池化右方Pad，默认为0

**property pool_width[#](#xir.MaxPool1d.pool_width)**

池化窗口宽度

**property stride_width[#](#xir.MaxPool1d.stride_width)**

池化滑动宽度，默认为1

**class MaxPool2d(*args, **kwargs)[#](#xir.MaxPool2d)**

Overloaded function.

- 
__init__(self: xir.MaxPool2d) -> None

默认构造函数

- 
__init__(self: xir.MaxPool2d, input: xir.Value, pool_width: int, pool_height: int, stride_width: int, stride_height: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_width: int, dilation_height: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_width:                             池化窗口宽度
:param  pool_height:                    池化窗口高度
:param  stride_width:                   池化滑动宽度
:param  stride_height:                  池化滑动高度
:param  pad_top:                                池化上方Pad
:param  pad_bottom:                             池化下方Pad
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  dilation_width:                 池化膨胀宽度
:param  dilation_height:                池化膨胀高度

- 
__init__(self: xir.MaxPool2d, input: xir.Value, pool_size: int, stride: int, pad_top_bottom: int, pad_left_right: int, dilation: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，高度和宽度相同
:param  stride:                                 池化滑动长度，高度和宽度相同
:param  pad_top_bottom:                 池化上下方Pad
:param  pad_left_right:                 池化左右方Pad
:param  dilation:                               池化膨胀系数，宽度和高度相同

- 
__init__(self: xir.MaxPool2d, input: xir.Value, pool_size: int, stride: int, pad: int, dilation: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，高度和宽度相同
:param  stride:                                 池化滑动长度，高度和宽度相同
:param  pad:                                    池化上下左右方Pad
:param  dilation:                               池化膨胀系数，宽度和高度相同

- 
__init__(self: xir.MaxPool2d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.MaxPool2d](#xir.MaxPool2d)[#](#xir.MaxPool2d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.MaxPool2d](#xir.MaxPool2d), depth: int = 1) → [xir.MaxPool2d](#xir.MaxPool2d)[#](#xir.MaxPool2d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_height[#](#xir.MaxPool2d.dilation_height)**

池化膨胀高度，默认为1

**property dilation_width[#](#xir.MaxPool2d.dilation_width)**

池化膨胀宽度，默认为1

**property pad_bottom[#](#xir.MaxPool2d.pad_bottom)**

池化下方Pad，默认为0

**property pad_left[#](#xir.MaxPool2d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.MaxPool2d.pad_right)**

池化右方Pad，默认为0

**property pad_top[#](#xir.MaxPool2d.pad_top)**

池化上方Pad，默认为0

**property pool_height[#](#xir.MaxPool2d.pool_height)**

池化窗口宽度

**property pool_width[#](#xir.MaxPool2d.pool_width)**

池化窗口宽度

**property stride_height[#](#xir.MaxPool2d.stride_height)**

池化滑动高度，默认为1

**property stride_width[#](#xir.MaxPool2d.stride_width)**

池化滑动宽度，默认为1

**class MaxPool3d(*args, **kwargs)[#](#xir.MaxPool3d)**

Overloaded function.

- 
__init__(self: xir.MaxPool3d) -> None

默认构造函数

- 
__init__(self: xir.MaxPool3d, input: xir.Value, pool_depth: int, pool_width: int, pool_height: int, stride_depth: int, stride_width: int, stride_height: int, pad_front: int, pad_back: int, pad_top: int, pad_bottom: int, pad_left: int, pad_right: int, dilation_depth: int, dilation_width: int, dilation_height: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_depth:                             池化窗口深度
:param  pool_width:                             池化窗口宽度
:param  pool_height:                    池化窗口高度
:param  stride_depth:                   池化滑动深度
:param  stride_width:                   池化滑动宽度
:param  stride_height:                  池化滑动高度
:param  pad_front:                              池化前方Pad
:param  pad_back:                               池化后方Pad
:param  pad_top:                                池化上方Pad
:param  pad_bottom:                             池化下方Pad
:param  pad_left:                               池化左方Pad
:param  pad_right:                              池化右方Pad
:param  dilation_width:                 池化膨胀深度
:param  dilation_width:                 池化膨胀宽度
:param  dilation_height:                池化膨胀高度

- 
__init__(self: xir.MaxPool3d, input: xir.Value, pool_size: int, stride: int, pad_front_top_bottom: int, pad_back_left_right: int, dilation: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，高度和宽度相同
:param  stride:                                 池化滑动长度，高度和宽度相同
:param  pad_front_top_bottom:   池化前上下方Pad
:param  pad_back_left_right:    池化后左右方Pad
:param  dilation:                               池化膨胀系数，宽度和高度相同

- 
__init__(self: xir.MaxPool3d, input: xir.Value, pool_size: int, stride: int, pad: int, dilation: int) -> None

构造函数
:param  input:                                  池化的输入
:param  pool_size:                              池化窗口尺寸，深度、高度和宽度相同
:param  stride:                                 池化滑动长度，深度、高度和宽度相同
:param  pad:                                    池化前后上下左右方Pad
:param  dilation:                               池化膨胀系数，深度、宽度和高度相同

- 
__init__(self: xir.MaxPool3d, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.MaxPool3d](#xir.MaxPool3d)[#](#xir.MaxPool3d.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.MaxPool3d](#xir.MaxPool3d), depth: int = 1) → [xir.MaxPool3d](#xir.MaxPool3d)[#](#xir.MaxPool3d.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dilation_depth[#](#xir.MaxPool3d.dilation_depth)**

池化膨胀深度，默认为1

**property dilation_height[#](#xir.MaxPool3d.dilation_height)**

池化膨胀高度，默认为1

**property dilation_width[#](#xir.MaxPool3d.dilation_width)**

池化膨胀宽度，默认为1

**property pad_back[#](#xir.MaxPool3d.pad_back)**

池化后方Pad，默认为0

**property pad_bottom[#](#xir.MaxPool3d.pad_bottom)**

池化下方Pad，默认为0

**property pad_front[#](#xir.MaxPool3d.pad_front)**

池化前方Pad，默认为0

**property pad_left[#](#xir.MaxPool3d.pad_left)**

池化左方Pad，默认为0

**property pad_right[#](#xir.MaxPool3d.pad_right)**

池化右方Pad，默认为0

**property pad_top[#](#xir.MaxPool3d.pad_top)**

池化上方Pad，默认为0

**property pool_depth[#](#xir.MaxPool3d.pool_depth)**

池化窗口深度

**property pool_height[#](#xir.MaxPool3d.pool_height)**

池化窗口宽度

**property pool_width[#](#xir.MaxPool3d.pool_width)**

池化窗口宽度

**property stride_depth[#](#xir.MaxPool3d.stride_depth)**

池化滑动深度，默认为1

**property stride_height[#](#xir.MaxPool3d.stride_height)**

池化滑动高度，默认为1

**property stride_width[#](#xir.MaxPool3d.stride_width)**

池化滑动宽度，默认为1

**class Maximum(*args, **kwargs)[#](#xir.Maximum)**

Overloaded function.

- 
__init__(self: xir.Maximum) -> None

默认构造函数

- 
__init__(self: xir.Maximum, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs:            左操作数
:param  rhs:            右操作数

- 
__init__(self: xir.Maximum, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Maximum](#xir.Maximum)[#](#xir.Maximum.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Maximum](#xir.Maximum), depth: int = 1) → [xir.Maximum](#xir.Maximum)[#](#xir.Maximum.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**Maxpool[#](#xir.Maxpool)**

[MaxPool2d](#xir.MaxPool2d) 的别名

**class Mean(*args, **kwargs)[#](#xir.Mean)**

Overloaded function.

- 
__init__(self: xir.Mean) -> None

默认构造函数

- 
__init__(self: xir.Mean, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Mean, input: xir.Value, dim: int, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求和的维度
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Mean, inputs: xir.Value, dim: List[int], keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求和的维度
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Mean, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Mean](#xir.Mean)[#](#xir.Mean.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Mean](#xir.Mean), depth: int = 1) → [xir.Mean](#xir.Mean)[#](#xir.Mean.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Mean.dim)**

进行求和的维度（支持负数索引）

**property keepdim[#](#xir.Mean.keepdim)**

是否保持维度不变

**class MemType(*args, **kwargs)[#](#xir.MemType)**

表示存储类型的类型

Overloaded function.

- 
__init__(self: xir.MemType) -> None

默认构造函数

- 
__init__(self: xir.MemType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**clone(self: [xir.MemType](#xir.MemType), depth: int = 1) → [xir.MemType](#xir.MemType)[#](#xir.MemType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class MergedAxisDistr(*args, **kwargs)[#](#xir.MergedAxisDistr)**

表示通道分布的类.
MergedAxisDistr使用掩码来表示多个维度融合后元素是否有效，掩码的数量和融合后元素数相同。
当掩码为1时表示该通道有效，为0表示无效。

Overloaded function.

- 
__init__(self: xir.MergedAxisDistr) -> None

默认构造函数.

- 
__init__(self: xir.MergedAxisDistr, merged_axis: List[int], element_num: int = 0, init: bool = True) -> None

构造函数.
:param merged_axis:             坐标轴索引
:param element_num:             元素的数量
:param init:                    valid_mask的初始值，默认为true

- 
__init__(self: xir.MergedAxisDistr, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.Init)**

创建一个初始化(非空)对象

**allSections(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → List[Tuple[int, int, bool]][#](#xir.MergedAxisDistr.allSections)**

获取所有的片段.
:return: 表示片段的list，其中每个元素为一个tuple.
tuple的三个元素分别表示该片段的[开始, 结束)以及是否有效.

**append(*args, **kwargs)[#](#xir.MergedAxisDistr.append)**

Overloaded function.

- 
append(self: xir.MergedAxisDistr, element_num: int, valid: bool) -> xir.MergedAxisDistr

设置融合坐标.
:param chann_num:       通道数量
:param valid:           添加的通道是否有效

- 
append(self: xir.MergedAxisDistr, other_valid_mask: List[bool]) -> xir.MergedAxisDistr

合并另一个valid_mask.
:param other_valid_mask:        数组表示的有效掩码

**clone(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), depth: int = 1) → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**isValid(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), index: int) → bool[#](#xir.MergedAxisDistr.isValid)**

检查指定的元素是否有效.
:param index:   通道索引
:return: 如果有效则返回true

**property merged_axis[#](#xir.MergedAxisDistr.merged_axis)**

融合的维度索引列表

**setMergedAxis(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), merged_axis: List[int]) → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.setMergedAxis)**

设置融合坐标.
:param merged_axis:             坐标轴索引

**setUValue(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), uvalue: [xir.DistrUnvalidValue](#xir.DistrUnvalidValue)) → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.setUValue)**

设置无效元素的值

**setUnvalid(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), start: int, end: int) → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.setUnvalid)**

标记[start, end)范围无效.

**setValid(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr), start: int, end: int) → [xir.MergedAxisDistr](#xir.MergedAxisDistr)[#](#xir.MergedAxisDistr.setValid)**

标记[start, end)范围有效.

**totalNum(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → int[#](#xir.MergedAxisDistr.totalNum)**

获取总的元素数.

**totalUnvalidNum(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → int[#](#xir.MergedAxisDistr.totalUnvalidNum)**

获取总的无效元素数.

**totalValidNum(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → int[#](#xir.MergedAxisDistr.totalValidNum)**

获取总的有效元素数.

**unvalidSections(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → List[Tuple[int, int]][#](#xir.MergedAxisDistr.unvalidSections)**

获取所有的无效片段.
:return: 表示片段的list，其中每个元素为一个tuple.
tuple的三个元素分别表示该片段的[开始, 结束)以及是否有效.

**property uvalue[#](#xir.MergedAxisDistr.uvalue)**

无效元素的值

**validSections(self: [xir.MergedAxisDistr](#xir.MergedAxisDistr)) → List[Tuple[int, int]][#](#xir.MergedAxisDistr.validSections)**

获取所有的有效片段.
:return: 表示片段的list，其中每个元素为一个tuple.
tuple的三个元素分别表示该片段的[开始, 结束)以及是否有效.

**property valid_mask[#](#xir.MergedAxisDistr.valid_mask)**

元素掩码列表

**class Min(*args, **kwargs)[#](#xir.Min)**

Overloaded function.

- 
__init__(self: xir.Min) -> None

默认构造函数

- 
__init__(self: xir.Min, input: xir.Value, dim: Optional[xir.IntImm] = None, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求最大值索引的维度（支持负数索引）
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Min, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Min](#xir.Min)[#](#xir.Min.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Min](#xir.Min), depth: int = 1) → [xir.Min](#xir.Min)[#](#xir.Min.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Min.dim)**

进行求最大值索引的维度（支持负数索引）

**property keepdim[#](#xir.Min.keepdim)**

是否保持维度不变

**class Minimum(*args, **kwargs)[#](#xir.Minimum)**

Overloaded function.

- 
__init__(self: xir.Minimum) -> None

默认构造函数

- 
__init__(self: xir.Minimum, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs:            左操作数
:param  rhs:            右操作数

- 
__init__(self: xir.Minimum, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Minimum](#xir.Minimum)[#](#xir.Minimum.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Minimum](#xir.Minimum), depth: int = 1) → [xir.Minimum](#xir.Minimum)[#](#xir.Minimum.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**MinorVersionNum() → int[#](#xir.MinorVersionNum)**

获取次版本号

**class Mish(*args, **kwargs)[#](#xir.Mish)**

Overloaded function.

- 
__init__(self: xir.Mish) -> None

默认构造函数

- 
__init__(self: xir.Mish, input: xir.Value) -> None

构造函数
:param  input:                  输入

- 
__init__(self: xir.Mish, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Mish](#xir.Mish)[#](#xir.Mish.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Mish](#xir.Mish), depth: int = 1) → [xir.Mish](#xir.Mish)[#](#xir.Mish.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Mode(self: [xir.Mode](#xir.Mode), value: int)[#](#xir.Mode)**

填充模式

Members:

CONSTANT : 常量

REFLECTION : 反射

REPLICATION : 复制

SYMMETRIC : 对称

**property name[#](#xir.Mode.name)**

**class Multiply(*args, **kwargs)[#](#xir.Multiply)**

Overloaded function.

- 
__init__(self: xir.Multiply) -> None

默认构造函数

- 
__init__(self: xir.Multiply, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs:                    左操作数
:param  rhs:                    右操作数

- 
__init__(self: xir.Multiply, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Multiply](#xir.Multiply)[#](#xir.Multiply.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Multiply](#xir.Multiply), depth: int = 1) → [xir.Multiply](#xir.Multiply)[#](#xir.Multiply.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property cut_scale[#](#xir.Multiply.cut_scale)**

硬件截位时的系数

**class Neg(*args, **kwargs)[#](#xir.Neg)**

Overloaded function.

- 
__init__(self: xir.Neg) -> None

默认构造函数

- 
__init__(self: xir.Neg, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Neg, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Neg](#xir.Neg)[#](#xir.Neg.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Neg](#xir.Neg), depth: int = 1) → [xir.Neg](#xir.Neg)[#](#xir.Neg.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Network(*args, **kwargs)[#](#xir.Network)**

表示网络的类

Overloaded function.

- 
__init__(self: xir.Network) -> None

默认构造函数

- 
__init__(self: xir.Network, name: str, framework_kind: xir.Framework, framework_version: str, ai_target: xir.CompileTarget = <xir.BuyiTarget object at 0x000002A9DAB38230>) -> None

构造函数
:param name:                            网络名称
:param framework_kind:          前端框架
:param framework_version:       前端框架
:param ai_target:                       准备部署到的ICore后端

- 
__init__(self: xir.Network, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static CreateFromFlatFile(file_path: str) → [xir.Network](#xir.Network)[#](#xir.Network.CreateFromFlatFile)**

从Flat文件创建一个网络

**static CreateFromJsonFile(file_path: str) → [xir.Network](#xir.Network)[#](#xir.Network.CreateFromJsonFile)**

从Json文件创建一个网络

**static Init() → [xir.Network](#xir.Network)[#](#xir.Network.Init)**

创建一个初始化(非空)对象

**addOp(self: [xir.Network](#xir.Network), op: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.addOp)**

向网络中添加算子
:param op:                      被添加的算子
:raise: 如果遇到以下情况，则抛出异常:
*       将Input插入非空网络
*       在空网络中插入非Input算子
*       Op为空
*       Op已经加入过别的网络
*       Op在该网络中已经存在
*       Op指定的op_id在网络中已被分配
*       Op不是Input算子，但是却没有输入
*   Op的输出指定的v_id在网络中已被分配

**clone(self: [xir.Network](#xir.Network), depth: int = 1) → [xir.Network](#xir.Network)[#](#xir.Network.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**connect(*args, **kwargs)[#](#xir.Network.connect)**

Overloaded function.

- 
connect(self: xir.Network, from: xir.Value, to: xir.Operation, index: int) -> xir.Network

将(算子输出)Value连接到算子to的第index个输入
:param  from:           源Value
:param  to:                     目标算子
:param  index:          算子的第index个输入

- 
connect(self: xir.Network, from: xir.Value, to: xir.Operation) -> xir.Network

将(算子输出)Value连接到算子to最后一个输入
:param  from:           源Value
:param  to:                     目标算子

- 
connect(self: xir.Network, from: xir.Value, to: List[Tuple[xir.Operation, Set[int]]]) -> xir.Network

将(算子输出)Value连接到ValueUsesInfo表示的目标
:param  from:           源Value
:param  to:                     目标

**dumpFlatToFile(self: [xir.Network](#xir.Network), file_path: str, calc_md5: bool = True, validate: bool = True) → None[#](#xir.Network.dumpFlatToFile)**

将网络序列化为FlatBuffers，并输出到指定的文件
:param  file_path:              指定的文件路径
:param  calc_md5:               序列化时是否计算参数的MD5
:param  validate:               序列化时是否检查网络必须符合规范

**dumpJson(self: [xir.Network](#xir.Network), stream: io.BytesIO, calc_md5: bool = True) → None[#](#xir.Network.dumpJson)**

将网络序列化为Json，并输出到指定的流
:param  stream:         指定的输出流
:param  calc_md5:       序列化时是否计算参数的MD5

**dumpJsonToFile(self: [xir.Network](#xir.Network), file_path: str, calc_md5: bool = True, validate: bool = True) → None[#](#xir.Network.dumpJsonToFile)**

将网络序列化为Json，并输出到指定的文件
:param  file_path:              指定的文件路径
:param  calc_md5:               序列化时是否计算参数的MD5
:param  validate:               序列化时是否检查网络必须符合规范

**dumpParams(self: [xir.Network](#xir.Network), stream: io.BytesIO) → None[#](#xir.Network.dumpParams)**

输出网络参数到指定的流
:param  stream:         指定的输出流

**dumpParamsToFile(self: [xir.Network](#xir.Network), file_path: str) → None[#](#xir.Network.dumpParamsToFile)**

输出网络参数到指定的文件
:param  file_path:              指定的文件路径

**property framework_kind[#](#xir.Network.framework_kind)**

前端框架

**property framework_version[#](#xir.Network.framework_version)**

框架版本

**getTag(self: [xir.Network](#xir.Network), key: str) → Optional[[xir.ObjectRef](#xir.ObjectRef)][#](#xir.Network.getTag)**

获取网络的标签
:param key:                     标签的键
:return: 标签的值（可选项）

**getUsesInfo(self: [xir.Network](#xir.Network), v: [xir.Value](#xir.Value)) → List[Tuple[[xir.Operation](#xir.Operation), Set[int]]][#](#xir.Network.getUsesInfo)**

获取某个Value的使用信息
:param  v:              目标Value

**getUsesInfoExceptMatch(self: [xir.Network](#xir.Network), v: [xir.Value](#xir.Value), match: Dict[[xir.OpPattern](#xir.OpPattern), [xir.Operation](#xir.Operation)]) → List[Tuple[[xir.Operation](#xir.Operation), Set[int]]][#](#xir.Network.getUsesInfoExceptMatch)**

获取某个Value的使用信息，排除匹配结果中的算子
:param  v:              目标Value

**property icraft_version[#](#xir.Network.icraft_version)**

Icraft版本

**property icraft_xir_version[#](#xir.Network.icraft_xir_version)**

XIR版本

**insertOp(self: [xir.Network](#xir.Network), op_index: int, op: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.insertOp)**

向网络中插入算子
:param op_index:        插入位置
:param op:                      被插入Op
:raise: 如果遇到以下情况，则抛出异常:
*       将Input插入非空网络
*       在空网络中插入非Input算子
*       Op为空
*       Op已经加入过别的网络
*       Op在该网络中已经存在
*       Op指定的op_id在网络中已被分配
*       Op不是Input算子，但是却没有输入
*   Op的输出指定的v_id在网络中已被分配

**insertOpById(self: [xir.Network](#xir.Network), op_id: int, op: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.insertOpById)**

向网络中插入算子
:param op_id:           插入位置的Op ID
:param op:                      被插入Op
:raise: 如果遇到以下情况，则抛出异常:
*       将Input插入非空网络
*       在空网络中插入非Input算子
*       Op为空
*       Op已经加入过别的网络
*       Op在该网络中已经存在
*       Op指定的op_id在网络中已被分配
*       Op不是Input算子，但是却没有输入
*   Op的输出指定的v_id在网络中已被分配

**lazyLoadParamsFromFile(self: [xir.Network](#xir.Network), file_path: str, calc_md5: bool = True) → None[#](#xir.Network.lazyLoadParamsFromFile)**

从文件中惰性加载网络的参数
:param  file_path:              指定的文件路径
:param  calc_md5:               反序列化时是否计算参数的MD5
:raise:                                 如果参数的MD5和网络不匹配的抛出异常

**loadParams(self: [xir.Network](#xir.Network), stream: io.BytesIO, calc_md5: bool = True) → None[#](#xir.Network.loadParams)**

从输入流中加载网络的参数
:param  stream:         指定的输入流
:param  calc_md5:       反序列化时是否计算参数的MD5
:raise:                         如果参数的MD5和网络不匹配的抛出异常

**loadParamsFromFile(self: [xir.Network](#xir.Network), file_path: str, calc_md5: bool = True) → None[#](#xir.Network.loadParamsFromFile)**

从文件中加载网络的参数
:param  file_path:              指定的文件路径
:param  calc_md5:               反序列化时是否计算参数的MD5
:raise:                                 如果参数的MD5和网络不匹配的抛出异常

**property name[#](#xir.Network.name)**

网络名称

**property params_bytes[#](#xir.Network.params_bytes)**

参数大小

**property params_md5[#](#xir.Network.params_md5)**

参数的MD5

**removeOp(self: [xir.Network](#xir.Network), f: Callable[[[xir.Operation](#xir.Operation)], bool]) → [xir.Network](#xir.Network)[#](#xir.Network.removeOp)**

移除网络中的算子
:param  f:              移除算子的条件函数，所有f返回true的算子都会被移除

**removeOpById(self: [xir.Network](#xir.Network), op_id: int) → [xir.Network](#xir.Network)[#](#xir.Network.removeOpById)**

移除网络中的算子
:param op_id:           被移除算子的ID
:raise: 如果指定的Op在网络中不存在则抛出异常

**removeTag(self: [xir.Network](#xir.Network), key: str) → bool[#](#xir.Network.removeTag)**

删除算子的标签
:param key:                     标签的键
:return: 如果标签存在则返回true，否则返回false

**replaceGroup(self: [xir.Network](#xir.Network), src: Dict[[xir.OpPattern](#xir.OpPattern), [xir.Operation](#xir.Operation)], dest: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.replaceGroup)**

将MatchGroup表达的子图替换为某个算子
:param  src:            MatchGroup表达的子图
:param  dest:           替换后的算子

**replaceOp(self: [xir.Network](#xir.Network), src: [xir.Operation](#xir.Operation), dest: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.replaceOp)**

替换网络中的算子
:param  src:            被替换的算子
:param  dest:           替换后的算子

**replaceOpById(self: [xir.Network](#xir.Network), op_id: int, op: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.replaceOpById)**

替换网络中的算子
:param  op_id:          被替换的算子ID
:param  op:                     替换后的算子

**replaceOpByIdKeepUses(self: [xir.Network](#xir.Network), op_id: int, op: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.replaceOpByIdKeepUses)**

替换网络中的算子，保持原来的连接关系
:param  op_id:          被替换的算子ID
:param  op:                     替换后的算子
:raise: 如果指定的Op在网络中不存在则抛出异常

**replaceOpKeepUses(self: [xir.Network](#xir.Network), src: [xir.Operation](#xir.Operation), dest: [xir.Operation](#xir.Operation)) → [xir.Network](#xir.Network)[#](#xir.Network.replaceOpKeepUses)**

替换网络中的算子，保持原来的连接关系
:param  src:            被替换的算子
:param  dest:           替换后的算子
:raise: 如果指定的Op在网络中不存在则抛出异常

**rewrite(self: [xir.Network](#xir.Network), pattern: [xir.Pattern](#xir.Pattern), callback: Callable[[[xir.Network](#xir.Network), Dict[[xir.OpPattern](#xir.OpPattern), [xir.Operation](#xir.Operation)]], None], times: int = 10000) → None[#](#xir.Network.rewrite)**

根据指定的模式和回调重写网络
:param  pattern:        指定的模式
:param  callback:       回调函数，实现了改变网络的逻辑
:param  times:          搜索的最大次数

**rewriter(self: [xir.Network](#xir.Network)) → icraft::xir::NetworkRewriter[#](#xir.Network.rewriter)**

获取网络的NetworkRewriter

**search(self: [xir.Network](#xir.Network), pattern: [xir.Pattern](#xir.Pattern)) → List[Dict[[xir.OpPattern](#xir.OpPattern), [xir.Operation](#xir.Operation)]][#](#xir.Network.search)**

搜索网络中符合模式的结构
:param  pattern:        指定的模式
:return:                        list[dict[OpPattern, Operation]]表示的搜索结果
其中每个dict[OpPattern, Operation]表示一组匹配结果, 即MatchGroup

**searchOnce(self: [xir.Network](#xir.Network), pattern: [xir.Pattern](#xir.Pattern)) → Dict[[xir.OpPattern](#xir.OpPattern), [xir.Operation](#xir.Operation)][#](#xir.Network.searchOnce)**

搜索网络中符合模式的结构一次
:param  pattern:        指定的模式
:return:                        dict[OpPattern, Operation]表示的一组搜索结果

**setName(self: [xir.Network](#xir.Network), name: str) → [xir.Network](#xir.Network)[#](#xir.Network.setName)**

设置网络的名称
:param name:            网络的名称

**setTag(self: [xir.Network](#xir.Network), key: str, value: [xir.ObjectRef](#xir.ObjectRef)) → [xir.Network](#xir.Network)[#](#xir.Network.setTag)**

设置网络的标签
:param key:                     标签的键
:param value:           标签的值

**property tags[#](#xir.Network.tags)**

一些标记

**class NetworkBase(self: [xir.NetworkBase](#xir.NetworkBase), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.NetworkBase)**

表示网络的基类.

将父类强制转换为子类（该类型）

**static Init() → [xir.NetworkBase](#xir.NetworkBase)[#](#xir.NetworkBase.Init)**

创建一个初始化(非空)对象

**property ai_target[#](#xir.NetworkBase.ai_target)**

准备部署到的ICore后端

**clone(self: [xir.NetworkBase](#xir.NetworkBase), depth: int = 1) → [xir.NetworkBase](#xir.NetworkBase)[#](#xir.NetworkBase.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**getConsumersByOpId(self: icraft::xir::Network, op_id: int, sorted: bool) → List[[xir.Operation](#xir.Operation)][#](#xir.NetworkBase.getConsumersByOpId)**

获取网络中指定Op的消费者(消费者的输入是该Op的输出)

**getNextOpById(self: [xir.NetworkBase](#xir.NetworkBase), op_id: int) → [xir.Operation](#xir.Operation)[#](#xir.NetworkBase.getNextOpById)**

获取网络Op列表中(即执行序)某个Op的后一个Op

**getOpById(self: [xir.NetworkBase](#xir.NetworkBase), op_id: int) → [xir.Operation](#xir.Operation)[#](#xir.NetworkBase.getOpById)**

根据指定ID获取网络中的Op
:param  op_id:          指定的ID
:raise:                         如果op_id指定的Op不存在则抛出异常

**getOpIndexById(self: [xir.NetworkBase](#xir.NetworkBase), op_id: int) → int[#](#xir.NetworkBase.getOpIndexById)**

获取指定Op在网络中的index
:param  op_id:          指定Op的ID

**getOpsById(self: icraft::xir::Network, op_ids: List[int]) → List[[xir.Operation](#xir.Operation)][#](#xir.NetworkBase.getOpsById)**

根据指定ID列表获取网络中的Op列表
:param  op_ids:         指定的ID列表
:raise:                         如果op_id指定的Op不存在则抛出异常

**getPreOpById(self: [xir.NetworkBase](#xir.NetworkBase), op_id: int) → [xir.Operation](#xir.Operation)[#](#xir.NetworkBase.getPreOpById)**

获取网络Op列表中(即执行序)某个Op的前一个Op

**getProducersByOpId(self: icraft::xir::Network, op_id: int, sorted: bool) → List[[xir.Operation](#xir.Operation)][#](#xir.NetworkBase.getProducersByOpId)**

获取网络中指定Op的生产者(生产者的输出是该Op的输入)

**getUsesNumByValueId(self: [xir.NetworkBase](#xir.NetworkBase), v_id: int) → int[#](#xir.NetworkBase.getUsesNumByValueId)**

获取网络中使用某Value(即以该Value做输入)的Op数量
:param  v_id:           指定的ID

**getUsesOpByValueId(self: [xir.NetworkBase](#xir.NetworkBase), v_id: int) → icraft::xir::Array<icraft::xir::Operation>[#](#xir.NetworkBase.getUsesOpByValueId)**

获取网络中使用某Value(即以该Value做输入)的Op列表
:param  v_id:           指定的ID

**getValueById(self: [xir.NetworkBase](#xir.NetworkBase), v_id: int) → [xir.Value](#xir.Value)[#](#xir.NetworkBase.getValueById)**

根据指定ID获取网络中的Value
:param  v_id:           指定的ID
:raise:                         如果v_id指定的Value不存在则抛出异常

**getValuesById(self: icraft::xir::Network, value_ids: List[int]) → List[[xir.Value](#xir.Value)][#](#xir.NetworkBase.getValuesById)**

根据指定ID列表获取网络中的Value列表
:param  value_ids:              指定的ID列表
:raise:                                 如果v_id指定的Value不存在则抛出异常

**inputs(self: [xir.NetworkBase](#xir.NetworkBase)) → List[[xir.Value](#xir.Value)][#](#xir.NetworkBase.inputs)**

获取网络中的输入
:return: 网络中输入算子的输出Value列表，即网络的输入

**property ops[#](#xir.NetworkBase.ops)**

Op列表

**outputs(self: [xir.NetworkBase](#xir.NetworkBase)) → List[[xir.Value](#xir.Value)][#](#xir.NetworkBase.outputs)**

获取网络中的输出
:return: 网络中输出算子的输入Value列表，即网络的输出

**setAITarget(self: [xir.NetworkBase](#xir.NetworkBase), ai_target: [xir.CompileTarget](#xir.CompileTarget)) → [xir.NetworkBase](#xir.NetworkBase)[#](#xir.NetworkBase.setAITarget)**

设置网络准备部署到的ICore后端
:param  ai_target:                      准备部署到的ICore后端

**view(*args, **kwargs)[#](#xir.NetworkBase.view)**

Overloaded function.

- 
view(self: xir.NetworkBase, ops: icraft::xir::Array<icraft::xir::Operation>) -> icraft::xir::NetworkView

从该网络创建一个NetworkView
:param  ops:            NetworkView包含的算子

- 
view(self: xir.NetworkBase, op_ids: List[int]) -> icraft::xir::NetworkView

从该网络创建一个NetworkView
:param  op_ids:         NetworkView包含的算子的ID列表

- 
view(self: xir.NetworkBase, start_index: int, end_index: int) -> icraft::xir::NetworkView

从该网络创建一个NetworkView
:param  start_index:    NetworkView包含的算子在原网络中的开始索引(包含)，支持负数索引
:param  end_index:              NetworkView包含的算子在原网络中的结束索引(不包含)

- 
view(self: xir.NetworkBase, start_index: int) -> icraft::xir::NetworkView

从该网络创建一个NetworkView
:param  start_index:    NetworkView包含的算子在原网络中的开始索引(包含)

- 
view(self: xir.NetworkBase, judge: Callable[[xir.Operation], bool]) -> icraft::xir::NetworkView

从该网络创建一个NetworkView
:param  judge:                  判断算子是否放入NetworkView的函数

**viewByOpId(self: [xir.NetworkBase](#xir.NetworkBase), start_op_id: int, end_op_id: int) → icraft::xir::NetworkView[#](#xir.NetworkBase.viewByOpId)**

从该网络视图创建一个NetworkView
:param  start_op_id:    NetworkView包含的开始算子ID(包含)
:param  end_op_id:              NetworkView包含的结束算子ID(包含)

**viewExcept(self: [xir.NetworkBase](#xir.NetworkBase), op_ids: List[int]) → icraft::xir::NetworkView[#](#xir.NetworkBase.viewExcept)**

从该网络视图创建一个NetworkView
:param  op_ids:         NetworkView不包含的算子的ID列表

**class NetworkPass(*args, **kwargs)[#](#xir.NetworkPass)**

表示网络Pass的类型
NetworkPass会对输入的Network调用执行函数进行处理，然后返回处理后的Network

Overloaded function.

- 
__init__(self: xir.NetworkPass) -> None

默认构造函数.

- 
__init__(self: xir.NetworkPass, pass_func: Callable[[icraft::xir::Network, xir.PassContext], icraft::xir::Network], name: xir.String, opt_level: int = 0, required_passes: List[xir.String] = []) -> None

构造函数
:param  pass_func:                      Pass的执行函数
:param  name:                           Pass的名称
:param  opt_level:                      Pass的优化等级，默认为0
:param  required_passes:        Pass的前置Pass，默认为空

- 
__init__(self: xir.NetworkPass, pass_func: Callable[[icraft::xir::Network, xir.PassContext], icraft::xir::Network], pass_info: xir.PassInfo) -> None

构造函数
:param  pass_func:                      Pass的执行函数
:param  pass_info:                      Pass的信息

- 
__init__(self: xir.NetworkPass, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NetworkPass](#xir.NetworkPass)[#](#xir.NetworkPass.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.NetworkPass](#xir.NetworkPass), depth: int = 1) → [xir.NetworkPass](#xir.NetworkPass)[#](#xir.NetworkPass.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property pass_func[#](#xir.NetworkPass.pass_func)**

Pass的执行函数

**class NetworkRewriter[#](#xir.NetworkRewriter)**

网络的重写器，提供continue和break方法控制重写过程
默认的重写过程会重复从头匹配网络，而continue可以使其从上一个匹配位置继续，break会直接中断重写过程

**Break(self: [xir.NetworkRewriter](#xir.NetworkRewriter)) → None[#](#xir.NetworkRewriter.Break)**

中断重写过程

**Continue(self: [xir.NetworkRewriter](#xir.NetworkRewriter)) → None[#](#xir.NetworkRewriter.Continue)**

从上次匹配的位置继续匹配和重写

**class NetworkView(*args, **kwargs)[#](#xir.NetworkView)**

Overloaded function.

- 
__init__(self: xir.NetworkView) -> None

默认构造函数

- 
__init__(self: xir.NetworkView, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NetworkView](#xir.NetworkView)[#](#xir.NetworkView.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.NetworkView](#xir.NetworkView), depth: int = 1) → [xir.NetworkView](#xir.NetworkView)[#](#xir.NetworkView.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**network(self: [xir.NetworkView](#xir.NetworkView)) → [xir.Network](#xir.Network)[#](#xir.NetworkView.network)**

获取该网络视图对应的Network.

**setOutputsOrderByValueIds(self: [xir.NetworkView](#xir.NetworkView), arg0: List[int]) → [xir.NetworkView](#xir.NetworkView)[#](#xir.NetworkView.setOutputsOrderByValueIds)**

修改NetworkView的输出Value的顺序.

**toNetwork(self: [xir.NetworkView](#xir.NetworkView)) → [xir.Network](#xir.Network)[#](#xir.NetworkView.toNetwork)**

将当前网络视图转为一个独立的网络，如果缺失输入输出会自动补全.

**class Normalize(*args, **kwargs)[#](#xir.Normalize)**

Overloaded function.

- 
__init__(self: xir.Normalize) -> None

默认构造函数

- 
__init__(self: xir.Normalize, input: xir.Value, axis: List[int], p: float = 2, eps: float = 1e-12) -> None

构造函数
:param  input:          输入
:param  axis:           待归一化的维度（支持负数索引）
:param  p:                      范数公式中的指数值，默认为2
:param  eps:            防止除以0的小浮点数，默认为1e-12

- 
__init__(self: xir.Normalize, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Normalize](#xir.Normalize)[#](#xir.Normalize.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.Normalize.axis)**

待归一化的维度（支持负数索引）

**clone(self: [xir.Normalize](#xir.Normalize), depth: int = 1) → [xir.Normalize](#xir.Normalize)[#](#xir.Normalize.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property eps[#](#xir.Normalize.eps)**

防止除以0的小浮点数，默认为1e-12

**property p[#](#xir.Normalize.p)**

范数公式中的指数值，默认为2

**class NormalizedQuantizedType(*args, **kwargs)[#](#xir.NormalizedQuantizedType)**

表示采用归一化的量化类型

Overloaded function.

- 
__init__(self: xir.NormalizedQuantizedType) -> None

默认构造函数

- 
__init__(self: xir.NormalizedQuantizedType, normratio: List[float], scale: icraft::xir::QuantizedScaleArray, storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1F970>) -> None

构造函数
:param normratio:                       归一化系数
:param scale:                           量化的缩放因子
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.NormalizedQuantizedType, nomalized: xir.NormalizedType, scale: icraft::xir::QuantizedScaleArray) -> None

构造函数
:param nomalized:                       归一化类型的对象
:param scale:                           量化的缩放因子

- 
__init__(self: xir.NormalizedQuantizedType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NormalizedQuantizedType](#xir.NormalizedQuantizedType)[#](#xir.NormalizedQuantizedType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.NormalizedQuantizedType](#xir.NormalizedQuantizedType), depth: int = 1) → [xir.NormalizedQuantizedType](#xir.NormalizedQuantizedType)[#](#xir.NormalizedQuantizedType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class NormalizedType(*args, **kwargs)[#](#xir.NormalizedType)**

表示归一化后的数据类型

Overloaded function.

- 
__init__(self: xir.NormalizedType) -> None

默认构造函数

- 
__init__(self: xir.NormalizedType, normratio: List[float], storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1F9B0>) -> None

构造函数
:param normratio:                       归一化系数
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.NormalizedType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NormalizedType](#xir.NormalizedType)[#](#xir.NormalizedType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.NormalizedType](#xir.NormalizedType), depth: int = 1) → [xir.NormalizedType](#xir.NormalizedType)[#](#xir.NormalizedType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property normratio[#](#xir.NormalizedType.normratio)**

归一化系数

**class NormratioArray(*args, **kwargs)[#](#xir.NormratioArray)**

表示归一化系数列表.

Overloaded function.

- 
__init__(self: xir.NormratioArray) -> None

默认构造函数.

- 
__init__(self: xir.NormratioArray, data: List[float], axis: int = -1) -> None

- 
__init__(self: xir.NormratioArray, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NormratioArray](#xir.NormratioArray)[#](#xir.NormratioArray.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.NormratioArray.axis)**

系数对应的维度

**clone(self: [xir.NormratioArray](#xir.NormratioArray), depth: int = 1) → [xir.NormratioArray](#xir.NormratioArray)[#](#xir.NormratioArray.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property data[#](#xir.NormratioArray.data)**

归一化系数

**setAxis(self: [xir.NormratioArray](#xir.NormratioArray), axis: int) → [xir.NormratioArray](#xir.NormratioArray)[#](#xir.NormratioArray.setAxis)**

**class NotEqual(*args, **kwargs)[#](#xir.NotEqual)**

Overloaded function.

- 
__init__(self: xir.NotEqual) -> None

默认构造函数

- 
__init__(self: xir.NotEqual, lhs: xir.Value, rhs: xir.Value) -> None

构造函数
:param  lhs :   左操作数
:param  rhs :   右操作数

- 
__init__(self: xir.NotEqual, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.NotEqual](#xir.NotEqual)[#](#xir.NotEqual.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.NotEqual](#xir.NotEqual), depth: int = 1) → [xir.NotEqual](#xir.NotEqual)[#](#xir.NotEqual.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ObjectRef(self: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.ObjectRef)**

表示XIR中的对象引用，可以认为是一个侵入式地智能指针，XIR中的所有类型都派生自此类

默认构造函数

**clone(self: [xir.ObjectRef](#xir.ObjectRef), depth: int = 1) → [xir.ObjectRef](#xir.ObjectRef)[#](#xir.ObjectRef.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**defined(self: [xir.ObjectRef](#xir.ObjectRef)) → bool[#](#xir.ObjectRef.defined)**

检查引用的实例是否存在，如果对象引用了空指针则返回false

**same_as(self: [xir.ObjectRef](#xir.ObjectRef), arg0: [xir.ObjectRef](#xir.ObjectRef)) → bool[#](#xir.ObjectRef.same_as)**

比较引用的实例是否相同，即对象的指针是否相同

**typeKey(self: [xir.ObjectRef](#xir.ObjectRef)) → str[#](#xir.ObjectRef.typeKey)**

获取所引用对象的type_key字符串，该字符串表示引用对象的类型

**type_is(self: [xir.ObjectRef](#xir.ObjectRef), arg0: type) → bool[#](#xir.ObjectRef.type_is)**

检查类型是否是字符串指定的类型

**unique(self: [xir.ObjectRef](#xir.ObjectRef)) → bool[#](#xir.ObjectRef.unique)**

判断引用是否唯一，即引用计数为1则返回true

**use_count(self: [xir.ObjectRef](#xir.ObjectRef)) → int[#](#xir.ObjectRef.use_count)**

获取引用计数

**class OnChipMem(*args, **kwargs)[#](#xir.OnChipMem)**

表示OCM存储类型

Overloaded function.

- 
__init__(self: xir.OnChipMem) -> None

默认构造函数

- 
__init__(self: xir.OnChipMem, addr: int) -> None

构造函数，从地址构造
:param addr:    OCM上的地址

- 
__init__(self: xir.OnChipMem, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.OnChipMem](#xir.OnChipMem)[#](#xir.OnChipMem.Init)**

创建一个初始化(非空)对象

**property addr[#](#xir.OnChipMem.addr)**

OCM上的地址

**clone(self: [xir.OnChipMem](#xir.OnChipMem), depth: int = 1) → [xir.OnChipMem](#xir.OnChipMem)[#](#xir.OnChipMem.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**setAddr(self: [xir.OnChipMem](#xir.OnChipMem), addr: int) → [xir.OnChipMem](#xir.OnChipMem)[#](#xir.OnChipMem.setAddr)**

设置地址
:param addr:    OCM上的地址

**class OpPattern(*args, **kwargs)[#](#xir.OpPattern)**

表示匹配算子的模式

Overloaded function.

- 
__init__(self: xir.OpPattern) -> None

默认构造函数

- 
__init__(self: xir.OpPattern, op_type: List[str]) -> None

构造函数
:param op_type:         算子的类型字符串

- 
__init__(self: xir.OpPattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.OpPattern](#xir.OpPattern)[#](#xir.OpPattern.Init)**

创建一个初始化(非空)对象

**property attrs[#](#xir.OpPattern.attrs)**

算子的属性

**property cfunc[#](#xir.OpPattern.cfunc)**

算子的约束函数

**clone(self: [xir.OpPattern](#xir.OpPattern), depth: int = 1) → [xir.OpPattern](#xir.OpPattern)[#](#xir.OpPattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**hasAttr(*args, **kwargs)[#](#xir.OpPattern.hasAttr)**

Overloaded function.

- 
hasAttr(self: xir.OpPattern, key: str) -> xir.OpPattern

为算子添加属性模式，匹配键
:param key:             属性的键

- 
hasAttr(self: xir.OpPattern, key: str, value: Union[xir.ObjectRef, int, int, int, bool, float, str]) -> xir.OpPattern

为算子添加属性模式，匹配键和值
:param key:             属性的键
:param value:   属性的值

**property inputs[#](#xir.OpPattern.inputs)**

算子的输入

**onTarget(self: [xir.OpPattern](#xir.OpPattern), arg0: type) → [xir.OpPattern](#xir.OpPattern)[#](#xir.OpPattern.onTarget)**

描述算子的编译目标

**property op_type[#](#xir.OpPattern.op_type)**

算子的类型

**setConstraint(self: [xir.OpPattern](#xir.OpPattern), cfunc: Callable[[[xir.Operation](#xir.Operation)], bool]) → [xir.OpPattern](#xir.OpPattern)[#](#xir.OpPattern.setConstraint)**

描述算子的约束函数
:param cfunc:   算子的约束函数，该函数返回True表示符合约束

**property target_type[#](#xir.OpPattern.target_type)**

算子的编译目标类型

**class Operation(self: [xir.Operation](#xir.Operation), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.Operation)**

表示算子的类型

将父类强制转换为子类（该类型）

**static Create(arg0: str, arg1: str) → [xir.Operation](#xir.Operation)[#](#xir.Operation.Create)**

根据名字创建算子
:param name:                    算子的名字
:param dll_file:                算子所在DLL路径(可选)

**addInput(self: [xir.Operation](#xir.Operation), v: [xir.Value](#xir.Value)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.addInput)**

获取算子的标签
:param v:               被添加的输入

**attrs(self: [xir.Operation](#xir.Operation)) → Dict[str, Union[[xir.ObjectRef](#xir.ObjectRef), int, int, int, bool, float, str]][#](#xir.Operation.attrs)**

获取算子中所有属性的字典

**checkBound(self: [xir.Operation](#xir.Operation)) → None[#](#xir.Operation.checkBound)**

检查算子的属性是否都满足边界条件. 不满足则抛出异常

**checkNull(self: [xir.Operation](#xir.Operation)) → None[#](#xir.Operation.checkNull)**

检查算子的属性是否都不为空. 为空则抛出异常

**clearInputs(self: [xir.Operation](#xir.Operation)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.clearInputs)**

清除算子所有的输入

**clone(self: [xir.Operation](#xir.Operation), depth: int = 1) → [xir.Operation](#xir.Operation)[#](#xir.Operation.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property compile_target[#](#xir.Operation.compile_target)**

算子的编译目标

**connectInput(self: [xir.Operation](#xir.Operation), index: int, v: [xir.Value](#xir.Value)) → None[#](#xir.Operation.connectInput)**

连接输入, 将v作为Op的第index个输入
:param index:           输入的索引
:param v:                       被连接的输入Value

**consumers(self: [xir.Operation](#xir.Operation)) → List[[xir.Operation](#xir.Operation)][#](#xir.Operation.consumers)**

获取算子的消费者算子列表

**getAttr(self: [xir.Operation](#xir.Operation), arg0: str) → Union[[xir.ObjectRef](#xir.ObjectRef), int, int, int, bool, float, str][#](#xir.Operation.getAttr)**

获取算子中的某个属性
:param key:             属性的字符串名称

**getInputIndex(*args, **kwargs)[#](#xir.Operation.getInputIndex)**

Overloaded function.

- 
getInputIndex(self: xir.Operation, v: xir.Value) -> Set[int]

获取输入的索引，即是算子的第几个输入
:param  v               指定的输入Value
:raise:                 如果v不是Op的任何输入则抛出异常

- 
getInputIndex(self: xir.Operation, v_id: int) -> Set[int]

获取输入的索引，即是算子的第几个输入
:param  v_id    指定的输入Value的ID
:raise:                 如果v不是Op的任何输入则抛出异常

**getTag(self: [xir.Operation](#xir.Operation), key: str) → Optional[[xir.ObjectRef](#xir.ObjectRef)][#](#xir.Operation.getTag)**

获取算子的标签
:param key:                     标签的键
:return: 标签的值（可选项）

**hasAttr(*args, **kwargs)[#](#xir.Operation.hasAttr)**

Overloaded function.

- 
hasAttr(self: xir.Operation, arg0: str) -> bool

检查算子中某个属性是否存在
:param key:             属性的字符串名称

- 
hasAttr(self: xir.Operation, arg0: str, arg1: Union[xir.ObjectRef, int, int, int, bool, float, str]) -> None

检查算子中某个属性是否存在并等于指定的值
:param key:             属性的字符串名称
:param value:   属性的值

**inferResults(*args, **kwargs)[#](#xir.Operation.inferResults)**

Overloaded function.

- 
inferResults(self: xir.Operation, override: bool = False) -> List[xir.Value]

推断算子的输出类型，并获取输出
该方法调用算子注册的TypeInfer函数来推断输出的类型
:param:         override        是否覆盖已有输出，默认为否，如果已有输出则不再推断
:raise:                                 如果没有注册TypeInfer函数，则抛出异常

- 
inferResults(self: xir.Operation, dtypes: List[xir.TensorType], override: bool = False) -> List[xir.Value]

根据指定的输出类型列表，获取算子的输出
该方法调用算子注册的TypeInfer函数来推断输出的类型
:param dtypes:                  输出的数据类型列表
:param override:                是否覆盖已有输出，默认为否，如果已有输出则不再推断

**property inputs[#](#xir.Operation.inputs)**

算子的输入列表

**insertInput(self: [xir.Operation](#xir.Operation), index: int, v: [xir.Value](#xir.Value)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.insertInput)**

插入输入
index表示插入后的索引，比如输入为空时应指定index为0
:param index:   插入输入后的索引
:param v:               指定的输入值

**isActivate(self: [xir.Operation](#xir.Operation)) → bool[#](#xir.Operation.isActivate)**

检查该算子是否是激活算子

**isBoundToNetwork(self: [xir.Operation](#xir.Operation)) → bool[#](#xir.Operation.isBoundToNetwork)**

检查算子是否绑定到了网络

**property name[#](#xir.Operation.name)**

算子的名字

**network(self: [xir.Operation](#xir.Operation)) → icraft::xir::Network[#](#xir.Operation.network)**

获取算子绑定的网络

**nextOp(self: [xir.Operation](#xir.Operation)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.nextOp)**

获取算子执行序的下一个算子

**nonParamsInputs(self: [xir.Operation](#xir.Operation)) → List[[xir.Value](#xir.Value)][#](#xir.Operation.nonParamsInputs)**

获取算子非Params的输入列表

**property op_id[#](#xir.Operation.op_id)**

算子的ID

**property outputs[#](#xir.Operation.outputs)**

算子的输出列表

**paramsAttrs(self: [xir.Operation](#xir.Operation), is_defined: bool = False) → List[[xir.Params](#xir.Params)][#](#xir.Operation.paramsAttrs)**

获取算子中所有Params属性的列表

**paramsInputs(self: [xir.Operation](#xir.Operation)) → List[[xir.Value](#xir.Value)][#](#xir.Operation.paramsInputs)**

获取算子Params的输入列表

**preOp(self: [xir.Operation](#xir.Operation)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.preOp)**

获取算子执行序的上一个算子

**producers(self: [xir.Operation](#xir.Operation)) → List[[xir.Operation](#xir.Operation)][#](#xir.Operation.producers)**

获取算子的生产者算子列表

**removeInputById(self: [xir.Operation](#xir.Operation), v_id: int) → [xir.Operation](#xir.Operation)[#](#xir.Operation.removeInputById)**

移除算子指定ID的输入
:param v_id:    输入的ID

**removeTag(self: [xir.Operation](#xir.Operation), key: str) → bool[#](#xir.Operation.removeTag)**

删除算子的标签
:param key:                     标签的键
:return: 如果标签存在则返回true，否则返回false

**replaceInput(self: [xir.Operation](#xir.Operation), old_input: [xir.Value](#xir.Value), new_input: [xir.Value](#xir.Value)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.replaceInput)**

替换输入
:param old_input:       老的输入
:param new_input:       新的输入

**setAttr(self: [xir.Operation](#xir.Operation), key: str, value: Union[[xir.ObjectRef](#xir.ObjectRef), int, int, int, bool, float, str]) → None[#](#xir.Operation.setAttr)**

设置算子中某个属性的值
:param key:             属性的字符串名称
:param value:   属性值

**setAttrs(self: [xir.Operation](#xir.Operation), attrs: Dict[str, Union[[xir.ObjectRef](#xir.ObjectRef), int, int, int, bool, float, str]]) → None[#](#xir.Operation.setAttrs)**

根据属性的字典设置属性值
:param attrs:   属性字典

**setCompileTarget(self: [xir.Operation](#xir.Operation), target: [xir.CompileTarget](#xir.CompileTarget)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setCompileTarget)**

设置算子的编译目标

**setId(self: [xir.Operation](#xir.Operation), op_id: int) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setId)**

设置算子的ID

**setInput(self: [xir.Operation](#xir.Operation), index: int, v: [xir.Value](#xir.Value)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setInput)**

设置算子索引指定位置的值
:param index:   索引
:param v:               指定的输入值

**setInputs(self: [xir.Operation](#xir.Operation), inputs: List[[xir.Value](#xir.Value)]) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setInputs)**

设置算子的输入序列
:param inputs:          指定的输入序列

**setName(self: [xir.Operation](#xir.Operation), name: str) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setName)**

设置算子的名字

**setOutput(self: [xir.Operation](#xir.Operation), index: int, v: [xir.Value](#xir.Value)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setOutput)**

设置算子索引指定位置输出的值
:param index:   索引
:param v:               指定的输入值

**setOutputs(self: [xir.Operation](#xir.Operation), outputs: List[[xir.Value](#xir.Value)]) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setOutputs)**

设置算子的输出序列
:param outputs:         指定的输出序列

**setTag(self: [xir.Operation](#xir.Operation), key: str, value: [xir.ObjectRef](#xir.ObjectRef)) → [xir.Operation](#xir.Operation)[#](#xir.Operation.setTag)**

设置算子的标签
:param key:                     标签的键
:param value:           标签的值

**property tags[#](#xir.Operation.tags)**

一些标记

**class OptionalOpPattern(*args, **kwargs)[#](#xir.OptionalOpPattern)**

表示匹配可选算子的模式

Overloaded function.

- 
__init__(self: xir.OptionalOpPattern) -> None

默认构造函数

- 
__init__(self: xir.OptionalOpPattern, op_type: List[str]) -> None

构造函数
:param op_type:         算子的类型字符串

- 
__init__(self: xir.OptionalOpPattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.OptionalOpPattern](#xir.OptionalOpPattern)[#](#xir.OptionalOpPattern.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.OptionalOpPattern](#xir.OptionalOpPattern), depth: int = 1) → [xir.OptionalOpPattern](#xir.OptionalOpPattern)[#](#xir.OptionalOpPattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class OrPattern(*args, **kwargs)[#](#xir.OrPattern)**

表示模式匹配中的或逻辑

Overloaded function.

- 
__init__(self: xir.OrPattern) -> None

默认构造函数

- 
__init__(self: xir.OrPattern, letf: xir.Pattern, right: xir.Pattern) -> None

构造函数
:param left:    左操作数
:param right:   右操作数

- 
__init__(self: xir.OrPattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.OrPattern](#xir.OrPattern)[#](#xir.OrPattern.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.OrPattern](#xir.OrPattern), depth: int = 1) → [xir.OrPattern](#xir.OrPattern)[#](#xir.OrPattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property left[#](#xir.OrPattern.left)**

左操作数

**property right[#](#xir.OrPattern.right)**

右操作数

**class Output(*args, **kwargs)[#](#xir.Output)**

表示输出算子

Overloaded function.

- 
__init__(self: xir.Output) -> None

默认构造函数

- 
__init__(self: xir.Output, [*](#id19)args) -> None

构造函数，根据Value列表构造Output
该方法会将指定的Value列表作为Output的输入
:param values:  Value列表或可变参数

- 
__init__(self: xir.Output, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Output](#xir.Output)[#](#xir.Output.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Output](#xir.Output), depth: int = 1) → [xir.Output](#xir.Output)[#](#xir.Output.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**PATTERN_REQUIRE(expr: bool) → bool[#](#xir.PATTERN_REQUIRE)**

算子约束辅助函数

**class PReLU(*args, **kwargs)[#](#xir.PReLU)**

Overloaded function.

- 
__init__(self: xir.PReLU) -> None

默认构造函数

- 
__init__(self: xir.PReLU, input: xir.Value, alpha: xir.Params) -> None

构造函数
:param  input:          输入
:param  alpha:          系数

- 
__init__(self: xir.PReLU, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.PReLU](#xir.PReLU)[#](#xir.PReLU.Init)**

创建一个初始化(非空)对象

**property alpha[#](#xir.PReLU.alpha)**

系数

**clone(self: [xir.PReLU](#xir.PReLU), depth: int = 1) → [xir.PReLU](#xir.PReLU)[#](#xir.PReLU.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Pad(*args, **kwargs)[#](#xir.Pad)**

Overloaded function.

- 
__init__(self: xir.Pad) -> None

默认构造函数

- 
__init__(self: xir.Pad, input: xir.Value, padding: List[int], mode: xir.Mode = <Mode.CONSTANT: 0>, value: xir.ScalarImm = <xir.IntImm object at 0x000002A9DAB22630>) -> None

构造函数
:param  input:                  输入
:param  padding:                Pad的数量，维度 = 输入维度*2，每个输入维度对应前后两个padding
:param  mode:                   Pad的模式，默认为CONSTANT
:param  value:                  Pad为CONSTANT模式时的值，默认为0

- 
__init__(self: xir.Pad, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Pad](#xir.Pad)[#](#xir.Pad.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Pad](#xir.Pad), depth: int = 1) → [xir.Pad](#xir.Pad)[#](#xir.Pad.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class PaddingMode(self: [xir.PaddingMode](#xir.PaddingMode), value: int)[#](#xir.PaddingMode)**

填充模式

Members:

ZEROS : 填充0

REFLECT : 反射

REPLICATE : 重复

CIRCULAR : 环形

**property name[#](#xir.PaddingMode.name)**

**class Params(*args, **kwargs)[#](#xir.Params)**

表示参数的类型

Overloaded function.

- 
__init__(self: xir.Params) -> None

默认构造函数

- 
__init__(self: xir.Params, b: buffer, name: str = ‘’, layout: xir.Layout = <xir.Layout object at 0x000002A9DCA1F030>, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAAF7AB0>) -> None

构造函数, 从buffer构造
:param b:                       python buffer
:param name:            数据名字
:param layout:          数据排布
:param mtype:           存储类型

- 
__init__(self: xir.Params, name: str, dtype: xir.TensorType, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB06A30>) -> None

构造函数
:param name:            数据名字
:param dtype:           数据类型
:param mtype:           存储类型

- 
__init__(self: xir.Params, dtype: xir.TensorType) -> None

构造函数(默认数据和名字为空)
:param dtype:           数据类型

- 
__init__(self: xir.Params, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Params](#xir.Params)[#](#xir.Params.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Params](#xir.Params), depth: int = 1) → [xir.Params](#xir.Params)[#](#xir.Params.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**copyData(self: [xir.Params](#xir.Params), b: buffer) → None[#](#xir.Params.copyData)**

复制别的数据作为参数数据

**fill(*args, **kwargs)[#](#xir.Params.fill)**

Overloaded function.

- 
fill(self: xir.Params, arg0: Callable[[int], float]) -> xir.Params

填充数据

- 
fill(self: xir.Params, arg0: Callable[[int], int]) -> xir.Params

填充数据

**hasData(self: [xir.Params](#xir.Params)) → bool[#](#xir.Params.hasData)**

检查参数是否包含数据

**isLazyLoaded(self: [xir.Params](#xir.Params)) → bool[#](#xir.Params.isLazyLoaded)**

检查该参数是否是被惰性加载的

**load(self: [xir.Params](#xir.Params)) → None[#](#xir.Params.load)**

加载参数
Note:
* 如果该参数是被惰性加载的，那么load会将其加载到内存中
* 如果该参数不是惰性加载的(即数据已在内存中)，那么load什么都不干

**setLazy(self: [xir.Params](#xir.Params), lazy: bool) → [xir.Params](#xir.Params)[#](#xir.Params.setLazy)**

设置标记该参数是被惰性加载的

**class Pass(*args, **kwargs)[#](#xir.Pass)**

Pass抽象了对网络的增删查改等访问.

Overloaded function.

- 
__init__(self: xir.Pass) -> None

默认构造函数

- 
__init__(self: xir.Pass, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Create(*args, **kwargs)[#](#xir.Pass.Create)**

Overloaded function.

- 
Create(name: str) -> xir.Pass

根据名字创建一个Pass
:param  name:                           Pass的名称

- 
Create(name: str, dll_path: str) -> xir.Pass

根据名字创建一个Pass
:param  name:                           Pass的名称
:param  dll_path:                       Pass所在的DLL路径

**clone(self: [xir.Pass](#xir.Pass), depth: int = 1) → [xir.Pass](#xir.Pass)[#](#xir.Pass.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property pass_info[#](#xir.Pass.pass_info)**

Pass的信息

**setName(self: [xir.Pass](#xir.Pass), name: [xir.String](#xir.String)) → [xir.Pass](#xir.Pass)[#](#xir.Pass.setName)**

设置Pass的名字
:param name:    Pass的名字

**setOptLevel(self: [xir.Pass](#xir.Pass), opt_level: int) → [xir.Pass](#xir.Pass)[#](#xir.Pass.setOptLevel)**

设置Pass的优化等级
:param opt_level:       Pass的优化等级

**setPassInfo(self: [xir.Pass](#xir.Pass), pass_info: [xir.PassInfo](#xir.PassInfo)) → [xir.Pass](#xir.Pass)[#](#xir.Pass.setPassInfo)**

设置Pass的信息.
:param pass_info:       Pass的信息

**setRequiredPasses(self: [xir.Pass](#xir.Pass), required_passes: List[[xir.String](#xir.String)]) → [xir.Pass](#xir.Pass)[#](#xir.Pass.setRequiredPasses)**

设置Pass的前置Pass.
:param required_passes: Pass需要的前置Pass

**class PassContext(*args, **kwargs)[#](#xir.PassContext)**

表示Pass上下文的类型

Overloaded function.

- 
__init__(self: xir.PassContext) -> None

默认构造函数

- 
__init__(self: xir.PassContext, top_level: int, required_passes: List[xir.String] = [], disabled_passes: List[xir.String] = [], config: Dict[xir.String, xir.ObjectRef] = {}) -> None

构造函数
:param top_level:                       上下文支持Pass的最高等级
:param required_passes:         上下文需要的前置Pass, 默认为空
:param disabled_passes:         上下文禁用的Pass, 默认为空
:param config:                          上下文的配置, 默认为空

- 
__init__(self: xir.PassContext, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Current() → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.Current)**

获取当前作用域下的上下文

**static Init() → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.PassContext](#xir.PassContext), depth: int = 1) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property config[#](#xir.PassContext.config)**

该上下文的配置

**disablePass(self: [xir.PassContext](#xir.PassContext), pass_name: str) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.disablePass)**

为上下文添加禁用Pass
:param pass_name:                       被禁用Pass的名字

**property disabled_passes[#](#xir.PassContext.disabled_passes)**

该上下文禁用的Pass

**getConfig(self: [xir.PassContext](#xir.PassContext), key: str, default_value: Optional[[xir.ObjectRef](#xir.ObjectRef)]) → Optional[[xir.ObjectRef](#xir.ObjectRef)][#](#xir.PassContext.getConfig)**

获取上下文的配置
:param key:                             配置的键
:param default_value:   如果配置不存在则使用的默认值

**isPassEnabled(self: xir.PassContext, info: icraft::xir::PassInfo) → bool[#](#xir.PassContext.isPassEnabled)**

检查指定的PassInfo表示的Pass是否可以在该上下文中执行
可以执行的条件如下：

- 
- 
该Pass没有被禁用

- 
- 
该Pass优化等级小于等于上下文允许的最大等级

**参数:**

**info** – 指定的PassInfo

**removeDisabledPass(self: [xir.PassContext](#xir.PassContext), pass_name: str) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.removeDisabledPass)**

为上下文移除禁用Pass
:param pass_name:                       被移除Pass的名字

**removeRequiredPass(self: [xir.PassContext](#xir.PassContext), pass_name: str) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.removeRequiredPass)**

为上下文移除前置Pass
:param pass_name:                       被移除Pass的名字

**requirePass(self: [xir.PassContext](#xir.PassContext), pass_name: str) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.requirePass)**

为上下文添加前置Pass
:param pass_name:                       被添加Pass的名字

**property required_passes[#](#xir.PassContext.required_passes)**

该上下文需要的前置Pass

**setConfig(self: [xir.PassContext](#xir.PassContext), key: str, value: [xir.ObjectRef](#xir.ObjectRef)) → [xir.PassContext](#xir.PassContext)[#](#xir.PassContext.setConfig)**

为上下文添加配置
:param key:                     配置的键
:param value:           配置的值

**property top_level[#](#xir.PassContext.top_level)**

该上下文支持Pass的最高等级

**class PassInfo(*args, **kwargs)[#](#xir.PassInfo)**

表示Pass信息的类

Overloaded function.

- 
__init__(self: xir.PassInfo) -> None

默认构造函数

- 
__init__(self: xir.PassInfo, name: str, opt_level: int = 0, required_passes: List[str] = []) -> None

构造函数
:param  name:                           Pass的名称
:param  opt_level:                      Pass的优化等级, 默认为0
:param  required_passes:        Pass需要的前置Pass, 默认为空

- 
__init__(self: xir.PassInfo, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.PassInfo](#xir.PassInfo)[#](#xir.PassInfo.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.PassInfo](#xir.PassInfo), depth: int = 1) → [xir.PassInfo](#xir.PassInfo)[#](#xir.PassInfo.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property name[#](#xir.PassInfo.name)**

Pass的名称

**property opt_level[#](#xir.PassInfo.opt_level)**

Pass的优化等级

**property required_passes[#](#xir.PassInfo.required_passes)**

Pass需要的前置Pass

**PatchVersionNum() → int[#](#xir.PatchVersionNum)**

获取补丁版本号

**class Pattern(*args, **kwargs)[#](#xir.Pattern)**

表示模式匹配的基类

Overloaded function.

- 
__init__(self: xir.Pattern) -> None

默认构造函数

- 
__init__(self: xir.Pattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**clone(self: [xir.Pattern](#xir.Pattern), depth: int = 1) → [xir.Pattern](#xir.Pattern)[#](#xir.Pattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class PixelShuffle(*args, **kwargs)[#](#xir.PixelShuffle)**

Overloaded function.

- 
__init__(self: xir.PixelShuffle) -> None

默认构造函数

- 
__init__(self: xir.PixelShuffle, input: xir.Value, upscale_factor: int) -> None

构造函数
:param  input:                          输入
:param  upscale_factor:         扩充因子

- 
__init__(self: xir.PixelShuffle, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.PixelShuffle](#xir.PixelShuffle)[#](#xir.PixelShuffle.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.PixelShuffle](#xir.PixelShuffle), depth: int = 1) → [xir.PixelShuffle](#xir.PixelShuffle)[#](#xir.PixelShuffle.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property upscale_factor[#](#xir.PixelShuffle.upscale_factor)**

扩充因子

**Prelu[#](#xir.Prelu)**

[PReLU](#xir.PReLU) 的别名

**class PruneAxis(*args, **kwargs)[#](#xir.PruneAxis)**

Overloaded function.

- 
__init__(self: xir.PruneAxis) -> None

默认构造函数.

- 
__init__(self: xir.PruneAxis, arg0: xir.Value, arg1: List[int]) -> None

构造函数.
:param  input:          输入
:param  input:          要执行去无效数据的merged_distr的下标们

- 
__init__(self: xir.PruneAxis, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.PruneAxis](#xir.PruneAxis)[#](#xir.PruneAxis.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.PruneAxis](#xir.PruneAxis), depth: int = 1) → [xir.PruneAxis](#xir.PruneAxis)[#](#xir.PruneAxis.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class QuantizedScale(*args, **kwargs)[#](#xir.QuantizedScale)**

表示量化缩放系数.

Overloaded function.

- 
__init__(self: xir.QuantizedScale) -> None

默认构造函数.

- 
__init__(self: xir.QuantizedScale, origin_scale: float) -> None

构造函数.
:param origin_scale:            未适配硬件的原始浮点缩放系数

- 
__init__(self: xir.QuantizedScale, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.QuantizedScale](#xir.QuantizedScale)[#](#xir.QuantizedScale.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.QuantizedScale](#xir.QuantizedScale), depth: int = 1) → [xir.QuantizedScale](#xir.QuantizedScale)[#](#xir.QuantizedScale.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property origin_scale[#](#xir.QuantizedScale.origin_scale)**

未适配硬件的原始浮点缩放系数

**class QuantizedScaleArray(*args, **kwargs)[#](#xir.QuantizedScaleArray)**

表示量化缩放系数列表.

Overloaded function.

- 
__init__(self: xir.QuantizedScaleArray) -> None

默认构造函数.

- 
__init__(self: xir.QuantizedScaleArray, origin_scale: List[float], axis: int = -1) -> None

构造函数.
:param origin_scale:            未适配硬件的原始浮点缩放系数列表
:param axis:                            origin_scale系数对应的维度，默认为-1，表示最后一维

- 
__init__(self: xir.QuantizedScaleArray, lhs: xir.QuantizedScaleArray, rhs: xir.QuantizedScaleArray) -> None

构造函数.
:param lhs:             待拼接输入1
:param rhs:             待拼接输入2

- 
__init__(self: xir.QuantizedScaleArray, n: int, val: xir.QuantizedScale) -> None

构造函数，从初始值构造.
:param n:               元素数量
:param val:             初始值

- 
__init__(self: xir.QuantizedScaleArray, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)[#](#xir.QuantizedScaleArray.Init)**

创建一个初始化(非空)对象

**back(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)) → [xir.QuantizedScale](#xir.QuantizedScale)[#](#xir.QuantizedScaleArray.back)**

获取存储的最后一个元素.

**clone(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray), depth: int = 1) → [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)[#](#xir.QuantizedScaleArray.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**empty(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)) → bool[#](#xir.QuantizedScaleArray.empty)**

检查Array是否为空.

**front(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)) → [xir.QuantizedScale](#xir.QuantizedScale)[#](#xir.QuantizedScaleArray.front)**

获取存储的第一个元素.

**property origin_scale[#](#xir.QuantizedScaleArray.origin_scale)**

未适配硬件的原始浮点缩放系数列表

**setAxis(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray), axis: int) → [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)[#](#xir.QuantizedScaleArray.setAxis)**

**size(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)) → int[#](#xir.QuantizedScaleArray.size)**

获取Array的大小.

**split(self: [xir.QuantizedScaleArray](#xir.QuantizedScaleArray), begin: int, end: int, stride: int = 1) → [xir.QuantizedScaleArray](#xir.QuantizedScaleArray)[#](#xir.QuantizedScaleArray.split)**

通过索引访问子列表.

**class QuantizedType(*args, **kwargs)[#](#xir.QuantizedType)**

表示量化后的数据类型

Overloaded function.

- 
__init__(self: xir.QuantizedType) -> None

默认构造函数

- 
__init__(self: xir.QuantizedType, scale: icraft::xir::QuantizedScaleArray, storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1FDB0>) -> None

构造函数
:param scale:                           量化的缩放因子
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.QuantizedType, scale: icraft::xir::QuantizedScaleArray, zero_points: List[int], storage_dtype: xir.ScalarType, expressed_dtype: xir.ScalarType = <xir.FloatType object at 0x000002A9DCA1FEF0>) -> None

构造函数
:param scale:                           量化的缩放因子
:param zero_points:                     量化的零点
:param storage_dtype:           存储类型，即量化的目标类型
:param expressed_dtype:         表达类型，即数据的原始类型

- 
__init__(self: xir.QuantizedType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.QuantizedType](#xir.QuantizedType)[#](#xir.QuantizedType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.QuantizedType](#xir.QuantizedType), depth: int = 1) → [xir.QuantizedType](#xir.QuantizedType)[#](#xir.QuantizedType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property scale[#](#xir.QuantizedType.scale)**

量化的缩放因子

**property zero_points[#](#xir.QuantizedType.zero_points)**

量化的零点

**class ReLU(*args, **kwargs)[#](#xir.ReLU)**

Overloaded function.

- 
__init__(self: xir.ReLU) -> None

默认构造函数

- 
__init__(self: xir.ReLU, input: xir.Value) -> None

构造函数
:param  input:                  输入

- 
__init__(self: xir.ReLU, input: xir.Value, alpha: float, max_value: float = inf, threshold: float = 0) -> None

构造函数
:param  input:                  输入
:param  alpha:                  系数
:param  max_value:              最大值
:param  threshold:              转折点

- 
__init__(self: xir.ReLU, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ReLU](#xir.ReLU)[#](#xir.ReLU.Init)**

创建一个初始化(非空)对象

**property alpha[#](#xir.ReLU.alpha)**

系数

**clone(self: [xir.ReLU](#xir.ReLU), depth: int = 1) → [xir.ReLU](#xir.ReLU)[#](#xir.ReLU.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property max_value[#](#xir.ReLU.max_value)**

最大值

**property threshold[#](#xir.ReLU.threshold)**

转折点

**Relu[#](#xir.Relu)**

[ReLU](#xir.ReLU) 的别名

**class Reshape(*args, **kwargs)[#](#xir.Reshape)**

Overloaded function.

- 
__init__(self: xir.Reshape) -> None

默认构造函数

- 
__init__(self: xir.Reshape, input: xir.Value, shape: List[int], layout: xir.Layout) -> None

构造函数
:param  input:                  输入
:param  shape:                  目标形状
:param  layout:                 目标排布

- 
__init__(self: xir.Reshape, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Reshape](#xir.Reshape)[#](#xir.Reshape.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Reshape](#xir.Reshape), depth: int = 1) → [xir.Reshape](#xir.Reshape)[#](#xir.Reshape.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property layout[#](#xir.Reshape.layout)**

目标排布

**property shape[#](#xir.Reshape.shape)**

目标形状

**class Resize(*args, **kwargs)[#](#xir.Resize)**

Overloaded function.

- 
__init__(self: xir.Resize) -> None

默认构造函数

- 
__init__(self: xir.Resize, input: xir.Value, dsize: List[int], interpolation: xir.ResizeInterpolation = <ResizeInterpolation.INTER_LINEAR: 1>) -> None

构造函数
:param  input:                  输入
:param  dsize:                  目标大小
:param  interpolation:  插值方式

- 
__init__(self: xir.Resize, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Resize](#xir.Resize)[#](#xir.Resize.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Resize](#xir.Resize), depth: int = 1) → [xir.Resize](#xir.Resize)[#](#xir.Resize.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dsize[#](#xir.Resize.dsize)**

目标大小

**property interpolation[#](#xir.Resize.interpolation)**

插值方式

**class ResizeInterpolation(self: [xir.ResizeInterpolation](#xir.ResizeInterpolation), value: int)[#](#xir.ResizeInterpolation)**

Resize的插值方式

Members:

INTER_NEAREST : 最近邻插值

INTER_LINEAR : 双线性插值

**property name[#](#xir.ResizeInterpolation.name)**

**class Roll(*args, **kwargs)[#](#xir.Roll)**

Overloaded function.

- 
__init__(self: xir.Roll) -> None

默认构造函数

- 
__init__(self: xir.Roll, input: xir.Value, shift: int, dim: Optional[int]) -> None

构造函数
:param  input:                  输入
:param  shift:                  滚动位移
:param  dim:                    滚动轴

- 
__init__(self: xir.Roll, input: xir.Value, dsize: List[int], interpolation: Optional[List[int]]) -> None

构造函数
:param  input:                  输入
:param  shifts:                 滚动位移
:param  dims:                   滚动轴

- 
__init__(self: xir.Roll, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Roll](#xir.Roll)[#](#xir.Roll.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Roll](#xir.Roll), depth: int = 1) → [xir.Roll](#xir.Roll)[#](#xir.Roll.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dims[#](#xir.Roll.dims)**

滚动轴

**property shifts[#](#xir.Roll.shifts)**

滚动位移

**class RoundingMode(self: [xir.RoundingMode](#xir.RoundingMode), value: int)[#](#xir.RoundingMode)**

取整模式

Members:

NONE : 对应true divide

TRUNC : 对应c语言风格的整除

FLOOR : 对应python风格”//”符号，或floor divide

**property name[#](#xir.RoundingMode.name)**

**class ScalarImm(*args, **kwargs)[#](#xir.ScalarImm)**

表示标量立即数

Overloaded function.

- 
__init__(self: xir.ScalarImm) -> None

表示标量立即数

- 
__init__(self: xir.ScalarImm, arg0: int) -> None

构造函数，从int构造

- 
__init__(self: xir.ScalarImm, arg0: float) -> None

构造函数，从float构造

- 
__init__(self: xir.ScalarImm, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**clone(self: [xir.ScalarImm](#xir.ScalarImm), depth: int = 1) → [xir.ScalarImm](#xir.ScalarImm)[#](#xir.ScalarImm.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**scalarType(self: [xir.ScalarImm](#xir.ScalarImm)) → [xir.ScalarType](#xir.ScalarType)[#](#xir.ScalarImm.scalarType)**

获取ScalarType类型的数据类型

**class ScalarType(self: [xir.ScalarType](#xir.ScalarType), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.ScalarType)**

表示标量数据类型的类型

将父类强制转换为子类（该类型）

**clone(self: [xir.ScalarType](#xir.ScalarType), depth: int = 1) → [xir.ScalarType](#xir.ScalarType)[#](#xir.ScalarType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**isBF16(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isBF16)**

检查该浮点类型是否是bf16

**isBool(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isBool)**

检查是否是bool

**isFP16(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isFP16)**

检查该浮点类型是否是fp16

**isFP32(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isFP32)**

检查该浮点类型是否是fp32

**isFP64(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isFP64)**

检查该浮点类型是否是fp64

**isFPE6M9(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isFPE6M9)**

检查该浮点类型是否是fpe6m9

**isFPE7M8(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isFPE7M8)**

检查该浮点类型是否是fpe7m8

**isSInt(self: [xir.ScalarType](#xir.ScalarType), N: int) → bool[#](#xir.ScalarType.isSInt)**

检查是否是N位的sint

**isSInt16(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isSInt16)**

检查是否是sint16

**isSInt32(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isSInt32)**

检查是否是sint32

**isSInt64(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isSInt64)**

检查是否是sint64

**isSInt8(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isSInt8)**

检查是否是sint8

**isSigned(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isSigned)**

检查是否是有符号的整数

**isTF32(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isTF32)**

检查该浮点类型是否是tf32

**isUInt(self: [xir.ScalarType](#xir.ScalarType), N: int) → bool[#](#xir.ScalarType.isUInt)**

检查是否是N位的uint

**isUInt16(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isUInt16)**

检查是否是uint16

**isUInt32(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isUInt32)**

检查是否是uint32

**isUInt64(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isUInt64)**

检查是否是uint64

**isUInt8(self: [xir.ScalarType](#xir.ScalarType)) → bool[#](#xir.ScalarType.isUInt8)**

检查是否是uint8

**class Semantics(self: [xir.Semantics](#xir.Semantics), emax: int, emin: int, precision: int, bits: int)[#](#xir.Semantics)**

表示浮点语义的结构体

构造函数
:param emax:            指数的最大值
:param emin:            指数的最小值
:param precision:       尾数的精度(位数)
:param bits:            浮点数的位数

**property bits[#](#xir.Semantics.bits)**

浮点数的位数

**property emax[#](#xir.Semantics.emax)**

指数的最大值

**property emin[#](#xir.Semantics.emin)**

指数的最小值

**property precision[#](#xir.Semantics.precision)**

尾数的精度(位数)

**class SequentialPass(*args, **kwargs)[#](#xir.SequentialPass)**

表示Pass序列的类型
Pass序列即一系列Pass组成的一个Pass, 该Pass执行时会依次执行每一个Pass

Overloaded function.

- 
__init__(self: xir.SequentialPass) -> None

默认构造函数

- 
__init__(self: xir.SequentialPass, passes: List[xir.Pass], name: xir.String, opt_level: int = 0, required_passes: List[xir.String] = []) -> None

构造函数.

**参数:**

- 
**passes** – Pass列表

- 
**name** – Pass的名称

- 
**opt_level** – Pass的优化等级，默认为0

- 
**required_passes** – Pass的前置Pass，默认为空

- 
__init__(self: xir.SequentialPass, passes: List[xir.Pass], pass_info: xir.PassInfo) -> None

构造函数
:param  passes:                 Pass列表
:param  pass_info:              Pass信息, 默认为Pass名为sequential

- 
__init__(self: xir.SequentialPass, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.SequentialPass](#xir.SequentialPass)[#](#xir.SequentialPass.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.SequentialPass](#xir.SequentialPass), depth: int = 1) → [xir.SequentialPass](#xir.SequentialPass)[#](#xir.SequentialPass.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property passes[#](#xir.SequentialPass.passes)**

Pass列表

**class SiLU(*args, **kwargs)[#](#xir.SiLU)**

Overloaded function.

- 
__init__(self: xir.SiLU) -> None

默认构造函数

- 
__init__(self: xir.SiLU, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.SiLU, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.SiLU](#xir.SiLU)[#](#xir.SiLU.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.SiLU](#xir.SiLU), depth: int = 1) → [xir.SiLU](#xir.SiLU)[#](#xir.SiLU.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Sigmoid(*args, **kwargs)[#](#xir.Sigmoid)**

Overloaded function.

- 
__init__(self: xir.Sigmoid) -> None

默认构造函数

- 
__init__(self: xir.Sigmoid, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Sigmoid, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Sigmoid](#xir.Sigmoid)[#](#xir.Sigmoid.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Sigmoid](#xir.Sigmoid), depth: int = 1) → [xir.Sigmoid](#xir.Sigmoid)[#](#xir.Sigmoid.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**Silu[#](#xir.Silu)**

[SiLU](#xir.SiLU) 的别名

**class Sin(*args, **kwargs)[#](#xir.Sin)**

Overloaded function.

- 
__init__(self: xir.Sin) -> None

默认构造函数

- 
__init__(self: xir.Sin, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Sin, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Sin](#xir.Sin)[#](#xir.Sin.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Sin](#xir.Sin), depth: int = 1) → [xir.Sin](#xir.Sin)[#](#xir.Sin.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Sinh(*args, **kwargs)[#](#xir.Sinh)**

Overloaded function.

- 
__init__(self: xir.Sinh) -> None

默认构造函数

- 
__init__(self: xir.Sinh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Sinh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Sinh](#xir.Sinh)[#](#xir.Sinh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Sinh](#xir.Sinh), depth: int = 1) → [xir.Sinh](#xir.Sinh)[#](#xir.Sinh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Slice(*args, **kwargs)[#](#xir.Slice)**

Overloaded function.

- 
__init__(self: xir.Slice) -> None

默认构造函数

- 
__init__(self: xir.Slice, arg0: xir.Value, arg1: List[int], arg2: List[int], arg3: List[int]) -> None

构造函数
:param  input:          输入
:param  begin:          切片的起始点，对应每个维度，从0开始
:param  end:            切片的结束点，对应每个维度，开空间
:param  stride:         切片的滑动步长，对应每个维度

- 
__init__(self: xir.Slice, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Slice](#xir.Slice)[#](#xir.Slice.Init)**

创建一个初始化(非空)对象

**property begin[#](#xir.Slice.begin)**

切片的起始点，对应每个维度，从0开始

**clone(self: [xir.Slice](#xir.Slice), depth: int = 1) → [xir.Slice](#xir.Slice)[#](#xir.Slice.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property end[#](#xir.Slice.end)**

切片的结束点，对应每个维度，开空间

**property stride[#](#xir.Slice.stride)**

切片的滑动步长，对应每个维度

**class Softmax(*args, **kwargs)[#](#xir.Softmax)**

Overloaded function.

- 
__init__(self: xir.Softmax) -> None

默认构造函数

- 
__init__(self: xir.Softmax, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Softmax, input: xir.Value, axis: int) -> None

构造函数
:param  input:          输入
:param  axis:           指定Softmax的维度，默认为-1，表示最后一维

- 
__init__(self: xir.Softmax, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Softmax](#xir.Softmax)[#](#xir.Softmax.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.Softmax.axis)**

Softmax的维度，默认为-1，表示最后一维

**clone(self: [xir.Softmax](#xir.Softmax), depth: int = 1) → [xir.Softmax](#xir.Softmax)[#](#xir.Softmax.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Softplus(*args, **kwargs)[#](#xir.Softplus)**

Overloaded function.

- 
__init__(self: xir.Softplus) -> None

默认构造函数.

- 
__init__(self: xir.Softplus, input: xir.Value, beta: float = 1.0, threshold: float = 20.0) -> None

构造函数
:param  input:          输入
:param  beta:           系数β，默认为1.0
:param  threshold:      阈值，默认为20.0

- 
__init__(self: xir.Softplus, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Softplus](#xir.Softplus)[#](#xir.Softplus.Init)**

创建一个初始化(非空)对象

**property beta[#](#xir.Softplus.beta)**

系数β，默认为1.0

**clone(self: [xir.Softplus](#xir.Softplus), depth: int = 1) → [xir.Softplus](#xir.Softplus)[#](#xir.Softplus.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property threshold[#](#xir.Softplus.threshold)**

阈值，默认为20.0

**class Softshrink(*args, **kwargs)[#](#xir.Softshrink)**

Overloaded function.

- 
__init__(self: xir.Softshrink) -> None

默认构造函数

- 
__init__(self: xir.Softshrink, input: xir.Value, lambda: float = 0.5) -> None

构造函数
:param  input:          输入
:param  lambda:         系数λ，默认为0.5

- 
__init__(self: xir.Softshrink, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Softshrink](#xir.Softshrink)[#](#xir.Softshrink.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Softshrink](#xir.Softshrink), depth: int = 1) → [xir.Softshrink](#xir.Softshrink)[#](#xir.Softshrink.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property lambda[#](#xir.Softshrink.lambda)**

系数λ，默认为0.5

**class Softsign(*args, **kwargs)[#](#xir.Softsign)**

Overloaded function.

- 
__init__(self: xir.Softsign) -> None

默认构造函数

- 
__init__(self: xir.Softsign, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Softsign, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Softsign](#xir.Softsign)[#](#xir.Softsign.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Softsign](#xir.Softsign), depth: int = 1) → [xir.Softsign](#xir.Softsign)[#](#xir.Softsign.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Split(*args, **kwargs)[#](#xir.Split)**

Overloaded function.

- 
__init__(self: xir.Split) -> None

默认构造函数

- 
__init__(self: xir.Split, input: xir.Value, sections: List[int], axis: int = -1) -> None

构造函数
:param  input:          输入
:param  sections:       分割块
:param  axis:           分割的维度

- 
__init__(self: xir.Split, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Split](#xir.Split)[#](#xir.Split.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.Split.axis)**

分割的维度，默认为-1，表示最后一维

**clone(self: [xir.Split](#xir.Split), depth: int = 1) → [xir.Split](#xir.Split)[#](#xir.Split.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property sections[#](#xir.Split.sections)**

分割块

**class Sqrt(*args, **kwargs)[#](#xir.Sqrt)**

Overloaded function.

- 
__init__(self: xir.Sqrt) -> None

默认构造函数

- 
__init__(self: xir.Sqrt, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Sqrt, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Sqrt](#xir.Sqrt)[#](#xir.Sqrt.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Sqrt](#xir.Sqrt), depth: int = 1) → [xir.Sqrt](#xir.Sqrt)[#](#xir.Sqrt.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Squeeze(*args, **kwargs)[#](#xir.Squeeze)**

Overloaded function.

- 
__init__(self: xir.Squeeze) -> None

默认构造函数

- 
__init__(self: xir.Squeeze, input: xir.Value, axis: List[int]) -> None

构造函数
:param  input:          输入
:param  axis:           压缩的维度

- 
__init__(self: xir.Squeeze, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Squeeze](#xir.Squeeze)[#](#xir.Squeeze.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.Squeeze.axis)**

压缩的维度

**clone(self: [xir.Squeeze](#xir.Squeeze), depth: int = 1) → [xir.Squeeze](#xir.Squeeze)[#](#xir.Squeeze.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Stack(*args, **kwargs)[#](#xir.Stack)**

Overloaded function.

- 
__init__(self: xir.Stack) -> None

默认构造函数

- 
__init__(self: xir.Stack, inputs: List[xir.Value], dim: int = 0) -> None

构造函数
:param  input:  输入
:param  dim:    进行堆叠运算的维度（支持负数索引），默认为0

- 
__init__(self: xir.Stack, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Stack](#xir.Stack)[#](#xir.Stack.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Stack](#xir.Stack), depth: int = 1) → [xir.Stack](#xir.Stack)[#](#xir.Stack.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Stack.dim)**

进行堆叠运算的维度（支持负数索引），默认为0

**class String(*args, **kwargs)[#](#xir.String)**

Overloaded function.

- 
__init__(self: xir.String) -> None

- 
__init__(self: xir.String, arg0: str) -> None

**empty(self: [xir.String](#xir.String)) → bool[#](#xir.String.empty)**

检查字符串是否为空

**class Sum(*args, **kwargs)[#](#xir.Sum)**

Overloaded function.

- 
__init__(self: xir.Sum) -> None

默认构造函数

- 
__init__(self: xir.Sum, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Sum, input: xir.Value, dim: int, keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求和的维度
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Sum, inputs: xir.Value, dim: List[int], keepdim: bool = False) -> None

构造函数
:param  input:          输入
:param  dim:            进行求和的维度
:param  keepdim:        是否保持维度不变

- 
__init__(self: xir.Sum, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Sum](#xir.Sum)[#](#xir.Sum.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Sum](#xir.Sum), depth: int = 1) → [xir.Sum](#xir.Sum)[#](#xir.Sum.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Sum.dim)**

进行求和的维度（支持负数索引）

**property keepdim[#](#xir.Sum.keepdim)**

是否保持维度不变

**class SwapOrder(*args, **kwargs)[#](#xir.SwapOrder)**

Overloaded function.

- 
__init__(self: xir.SwapOrder) -> None

默认构造函数

- 
__init__(self: xir.SwapOrder, input: xir.Value, order: List[int], axis: int = -1) -> None

构造函数
:param  input:          输入
:param  order:          期望的排布顺序
:param  axis:           期望交换顺序的维度

- 
__init__(self: xir.SwapOrder, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.SwapOrder](#xir.SwapOrder)[#](#xir.SwapOrder.Init)**

创建一个初始化(非空)对象

**property axis[#](#xir.SwapOrder.axis)**

期望交换顺序的维度

**clone(self: [xir.SwapOrder](#xir.SwapOrder), depth: int = 1) → [xir.SwapOrder](#xir.SwapOrder)[#](#xir.SwapOrder.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property order[#](#xir.SwapOrder.order)**

期望的排布顺序

**class Tan(*args, **kwargs)[#](#xir.Tan)**

Overloaded function.

- 
__init__(self: xir.Tan) -> None

默认构造函数

- 
__init__(self: xir.Tan, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Tan, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Tan](#xir.Tan)[#](#xir.Tan.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Tan](#xir.Tan), depth: int = 1) → [xir.Tan](#xir.Tan)[#](#xir.Tan.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Tanh(*args, **kwargs)[#](#xir.Tanh)**

Overloaded function.

- 
__init__(self: xir.Tanh) -> None

默认构造函数

- 
__init__(self: xir.Tanh, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Tanh, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Tanh](#xir.Tanh)[#](#xir.Tanh.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Tanh](#xir.Tanh), depth: int = 1) → [xir.Tanh](#xir.Tanh)[#](#xir.Tanh.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class Tanhshrink(*args, **kwargs)[#](#xir.Tanhshrink)**

Overloaded function.

- 
__init__(self: xir.Tanhshrink) -> None

默认构造函数

- 
__init__(self: xir.Tanhshrink, input: xir.Value) -> None

构造函数
:param  input:          输入

- 
__init__(self: xir.Tanhshrink, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Tanhshrink](#xir.Tanhshrink)[#](#xir.Tanhshrink.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Tanhshrink](#xir.Tanhshrink), depth: int = 1) → [xir.Tanhshrink](#xir.Tanhshrink)[#](#xir.Tanhshrink.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class TensorType(*args, **kwargs)[#](#xir.TensorType)**

表示张量数据类型

Overloaded function.

- 
__init__(self: xir.TensorType) -> None

默认构造函数

- 
__init__(self: xir.TensorType, element_type: xir.ScalarType, shape: List[int], layout: icraft::xir::Layout, merged_distrs: List[icraft::xir::MergedAxisDistr]) -> None

构造函数
:param element_type:    元素类型
:param shape:                   张量的形状
:param layout:                  张量的排布
:param merged_distrs:   维度的分布

- 
__init__(self: xir.TensorType, element_type: xir.ScalarType, shape: List[int], layout: icraft::xir::Layout) -> None

构造函数
:param element_type:    元素类型
:param shape:                   张量的形状
:param layout:                  张量的排布

- 
__init__(self: xir.TensorType, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.TensorType](#xir.TensorType), depth: int = 1) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**createAddMergedDistr(self: [xir.TensorType](#xir.TensorType), arg0: List[int]) → icraft::xir::MergedAxisDistr[#](#xir.TensorType.createAddMergedDistr)**

创建并添加维度分布, 默认融合分布所有元素全有效
:param merged_axis:             维度索引列表
:return:                                创建的维度分布
:raise:                                 如果相应维度的分布已经存在则抛出异常

**dimSize(self: [xir.TensorType](#xir.TensorType), combine: bool = False) → int[#](#xir.TensorType.dimSize)**

获取维度大小.

**property element_dtype[#](#xir.TensorType.element_dtype)**

张量元素的数据类型

**getChannel(self: [xir.TensorType](#xir.TensorType)) → int[#](#xir.TensorType.getChannel)**

获取通道数

**getDim(self: [xir.TensorType](#xir.TensorType), index: int, combine: bool = False) → int[#](#xir.TensorType.getDim)**

获取张量索引指定的维度
:param index:   索引，为负数时表示从后往前
:param combine: 组合，大小写字母合并后的完整维度
:return:                索引对应的维度
:raise:                 索引要小于张量的形状大小，否则抛出异常

**getDimByAxis(self: [xir.TensorType](#xir.TensorType), c: str, combine: bool = False) → int[#](#xir.TensorType.getDimByAxis)**

获取张量排布中的指定轴的维度
:param c:       字符表示的张量排布中的坐标轴
:param combine: 组合，大小写字母合并后的完整维度
:return:        该坐标轴上的维度
:raise:         坐标轴不能为’*’以及张量的形状大小和排布大小要相等，否则抛出异常

**getMergedDistr(self: [xir.TensorType](#xir.TensorType), arg0: List[int]) → Optional[icraft::xir::MergedAxisDistr][#](#xir.TensorType.getMergedDistr)**

获取融合维度的分布
:param merged_axis:             维度索引列表
:return:                                指定融合维度的分布，如果不存在则返回None

**hasNegativeDim(self: [xir.TensorType](#xir.TensorType)) → bool[#](#xir.TensorType.hasNegativeDim)**

检查是否有维度的尺寸是负的

**isLayouted(self: [xir.TensorType](#xir.TensorType)) → bool[#](#xir.TensorType.isLayouted)**

判断是否是Layout后的张量数据类型

**property layout[#](#xir.TensorType.layout)**

张量的排布

**property merged_distrs[#](#xir.TensorType.merged_distrs)**

维度的分布

**mutateMergedDistr(self: [xir.TensorType](#xir.TensorType), arg0: List[int], arg1: int, arg2: int, arg3: bool) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.mutateMergedDistr)**

调节指定分布
:param merged_axis:             维度索引列表
:param start:                   范围开始(包含)
:param end:                             范围结束(不包含)

**setDimByAxis(self: [xir.TensorType](#xir.TensorType), c: str, dim: int) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.setDimByAxis)**

设置张量排布中的指定轴的维度
:param c:       字符表示的张量排布中的坐标轴
:param dim:     被设置的维度
:raise:         坐标轴不能为’*’以及张量的形状大小和排布大小要相等，否则抛出异常

**setElementDtype(self: [xir.TensorType](#xir.TensorType), dtype: [xir.ScalarType](#xir.ScalarType)) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.setElementDtype)**

设置元素数据类型

**setLayout(self: xir.TensorType, layout: icraft::xir::Layout) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.setLayout)**

设置layout

**setMergedDistrs(self: xir.TensorType, arg0: List[icraft::xir::MergedAxisDistr]) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.setMergedDistrs)**

设置维度分布

**setShape(self: [xir.TensorType](#xir.TensorType), arg0: List[int]) → [xir.TensorType](#xir.TensorType)[#](#xir.TensorType.setShape)**

设置形状

**property shape[#](#xir.TensorType.shape)**

张量的形状

**class Transpose(*args, **kwargs)[#](#xir.Transpose)**

Overloaded function.

- 
__init__(self: xir.Transpose) -> None

默认构造函数

- 
__init__(self: xir.Transpose, input: xir.Value, dims: List[int], layout: xir.Layout) -> None

构造函数
:param  input:          输入
:param  dims:           期望的排布维度索引
:param  layout:         期望的排布

- 
__init__(self: xir.Transpose, input: xir.Value, dims: List[int]) -> None

构造函数
:param  input:          输入
:param  dims:           期望的排布维度索引

- 
__init__(self: xir.Transpose, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Transpose](#xir.Transpose)[#](#xir.Transpose.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Transpose](#xir.Transpose), depth: int = 1) → [xir.Transpose](#xir.Transpose)[#](#xir.Transpose.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dims[#](#xir.Transpose.dims)**

期望的排布维度索引

**property layout[#](#xir.Transpose.layout)**

期望的排布

**class Unstack(*args, **kwargs)[#](#xir.Unstack)**

Overloaded function.

- 
__init__(self: xir.Unstack) -> None

默认构造函数

- 
__init__(self: xir.Unstack, input: xir.Value, dim: int = 0) -> None

构造函数
:param  input:  输入
:param  dim:    进行分隔运算的维度（支持负数索引），默认为0

- 
__init__(self: xir.Unstack, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Unstack](#xir.Unstack)[#](#xir.Unstack.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Unstack](#xir.Unstack), depth: int = 1) → [xir.Unstack](#xir.Unstack)[#](#xir.Unstack.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dim[#](#xir.Unstack.dim)**

进行分隔运算的维度（支持负数索引），默认为0

**class Upsample(*args, **kwargs)[#](#xir.Upsample)**

Overloaded function.

- 
__init__(self: xir.Upsample) -> None

默认构造函数

- 
__init__(self: xir.Upsample, input: xir.Value, height: int, width: int, interpolation: xir.Interpolation = <Interpolation.NEAREST: 0>, align_corners: bool = False) -> None

构造函数
:param  input:                          输入
:param  height:                         上采样高度
:param  width:                          上采样宽度
:param  interpolation:          插值方式
:param  align_corners:          是否对齐四角

- 
__init__(self: xir.Upsample, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Upsample](#xir.Upsample)[#](#xir.Upsample.Init)**

创建一个初始化(非空)对象

**property align_corners[#](#xir.Upsample.align_corners)**

是否对齐四角

**clone(self: [xir.Upsample](#xir.Upsample), depth: int = 1) → [xir.Upsample](#xir.Upsample)[#](#xir.Upsample.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property height[#](#xir.Upsample.height)**

上采样高度

**property interpolation[#](#xir.Upsample.interpolation)**

插值方式

**property width[#](#xir.Upsample.width)**

上采样宽度

**class Value(*args, **kwargs)[#](#xir.Value)**

表示算子输入输出的数据

Overloaded function.

- 
__init__(self: xir.Value) -> None

默认构造函数

- 
__init__(self: xir.Value, name: str, dtype: xir.TensorType, mtype: xir.MemType = <xir.HostMem object at 0x000002A9DAB01FB0>) -> None

构造函数
:param name:            数据名字
:param dtype:           数据类型
:param mtype:           存储类型

- 
__init__(self: xir.Value, dtype: xir.TensorType) -> None

构造函数
:param dtype:           数据类型

- 
__init__(self: xir.Value, dtype: xir.TensorType, mtype: xir.MemType) -> None

构造函数
:param dtype:           数据类型
:param mtype:           存储类型

- 
__init__(self: xir.Value, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Value](#xir.Value)[#](#xir.Value.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Value](#xir.Value), depth: int = 1) → [xir.Value](#xir.Value)[#](#xir.Value.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**getUsesNum(self: [xir.Value](#xir.Value)) → int[#](#xir.Value.getUsesNum)**

获取该数据被使用的次数

**getUsesOp(self: [xir.Value](#xir.Value)) → std::vector<icraft::xir::Operation,std::allocator<icraft::xir::Operation> >[#](#xir.Value.getUsesOp)**

获取使用该数据作为输入的Op列表

**index(self: [xir.Value](#xir.Value)) → int[#](#xir.Value.index)**

获取该数据在Op中的index

**isBoundToNetwork(self: [xir.Value](#xir.Value)) → bool[#](#xir.Value.isBoundToNetwork)**

检查数据是否被绑定到了网络

**isBoundToOp(self: [xir.Value](#xir.Value)) → bool[#](#xir.Value.isBoundToOp)**

检查数据是否被绑定到了Op

**isParams(self: [xir.Value](#xir.Value)) → bool[#](#xir.Value.isParams)**

检查该数据是否是Params

**property name[#](#xir.Value.name)**

数据的名字

**network(self: [xir.Value](#xir.Value)) → icraft::xir::Network[#](#xir.Value.network)**

获取该数据绑定的网络

**op(self: [xir.Value](#xir.Value)) → icraft::xir::Operation[#](#xir.Value.op)**

获取产生该数据的Op

**setId(self: [xir.Value](#xir.Value), v_id: int) → [xir.Value](#xir.Value)[#](#xir.Value.setId)**

设置数据的ID

**setName(self: [xir.Value](#xir.Value), name: str) → [xir.Value](#xir.Value)[#](#xir.Value.setName)**

设置数据的名字

**tensorType(self: [xir.Value](#xir.Value)) → [xir.TensorType](#xir.TensorType)[#](#xir.Value.tensorType)**

获取TensorType类型的数据类型

**property v_id[#](#xir.Value.v_id)**

数据的ID

**class ValuePattern(*args, **kwargs)[#](#xir.ValuePattern)**

表示匹配算子输入的模式

Overloaded function.

- 
__init__(self: xir.ValuePattern) -> None

默认构造函数

- 
__init__(self: xir.ValuePattern, op_pattern: xir.OpPattern, index: int, uses: int = -1, dtype: xir.TensorType = <xir.TensorType object at 0x000002A9DCA17C70>) -> None

构造函数
:param op_pattern:      产生该Value的算子
:param index:           该Value在算子输出中的索引位置
:param uses:            使用该Value的Op数量，默认为-1，表示任意数量
:param dtype:           该Value的数据类型

- 
__init__(self: xir.ValuePattern, arg0: xir.AnycardsPattern) -> None

构造函数，从通配符构造

- 
__init__(self: xir.ValuePattern, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.ValuePattern](#xir.ValuePattern)[#](#xir.ValuePattern.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ValuePattern](#xir.ValuePattern), depth: int = 1) → [xir.ValuePattern](#xir.ValuePattern)[#](#xir.ValuePattern.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**property dtype[#](#xir.ValuePattern.dtype)**

该Value的数据类型

**hasDtype(self: [xir.ValuePattern](#xir.ValuePattern), dtype: [xir.TensorType](#xir.TensorType)) → [xir.ValuePattern](#xir.ValuePattern)[#](#xir.ValuePattern.hasDtype)**

描述Value的数据类型
:param dtype:   该Value的数据类型
:return:                返回一个新的模式

**hasUses(self: [xir.ValuePattern](#xir.ValuePattern), uses: int) → [xir.ValuePattern](#xir.ValuePattern)[#](#xir.ValuePattern.hasUses)**

描述Value的使用次数
:param uses:    使用次数
:return:                返回一个新的模式

**property index[#](#xir.ValuePattern.index)**

该Value在算子输出中的索引位置

**isAnycards(self: [xir.ValuePattern](#xir.ValuePattern)) → bool[#](#xir.ValuePattern.isAnycards)**

检查该模式是否是Anycards

**isWildcard(self: [xir.ValuePattern](#xir.ValuePattern)) → bool[#](#xir.ValuePattern.isWildcard)**

检查该模式是否是Wildcard

**property op_pattern[#](#xir.ValuePattern.op_pattern)**

产生Value的算子

**property uses[#](#xir.ValuePattern.uses)**

使用该Value的Op数量，默认为-1，表示任意数量

**class ValueUsesInfo[#](#xir.ValueUsesInfo)**

list[tuple(Operation, uint64_t)]表示的使用信息,
每个tuple(Operation, uint64_t)表示使用的Op, 以及在该Op输入中的index

**class Where(*args, **kwargs)[#](#xir.Where)**

Overloaded function.

- 
__init__(self: xir.Where) -> None

默认构造函数

- 
__init__(self: xir.Where, lhs: xir.Value, rhs: xir.Value, condition: xir.Value) -> None

构造函数
:param  lhs:            左操作数
:param  rhs:            右操作数
:param  condition:      判断条件

- 
__init__(self: xir.Where, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**static Init() → [xir.Where](#xir.Where)[#](#xir.Where.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.Where](#xir.Where), depth: int = 1) → [xir.Where](#xir.Where)[#](#xir.Where.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**Wildcard() → [xir.ValuePattern](#xir.ValuePattern)[#](#xir.Wildcard)**

构造一个通配符模式，匹配任意一个输入

**class WolongTarget(self: [xir.WolongTarget](#xir.WolongTarget), arg0: [xir.ObjectRef](#xir.ObjectRef))[#](#xir.WolongTarget)**

表示Wolong编译目标的类型

将父类强制转换为子类（该类型）

**static Init() → [xir.WolongTarget](#xir.WolongTarget)[#](#xir.WolongTarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.WolongTarget](#xir.WolongTarget), depth: int = 1) → [xir.WolongTarget](#xir.WolongTarget)[#](#xir.WolongTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ZhugeTarget(*args, **kwargs)[#](#xir.ZhugeTarget)**

表示Zhuge编译目标的类型

Overloaded function.

- 
__init__(self: xir.ZhugeTarget) -> None

默认构造函数

- 
__init__(self: xir.ZhugeTarget, core: xir.ZhugeTarget_Chips) -> None

构造函数

- 
__init__(self: xir.ZhugeTarget, arg0: xir.ObjectRef) -> None

将父类强制转换为子类（该类型）

**property Core[#](#xir.ZhugeTarget.Core)**

表示细分的的Zhuge后端芯片

**static Init() → [xir.ZhugeTarget](#xir.ZhugeTarget)[#](#xir.ZhugeTarget.Init)**

创建一个初始化(非空)对象

**clone(self: [xir.ZhugeTarget](#xir.ZhugeTarget), depth: int = 1) → [xir.ZhugeTarget](#xir.ZhugeTarget)[#](#xir.ZhugeTarget.clone)**

克隆一份该对象
:param depth:   克隆的深度，默认为1，即浅克隆
:return:                克隆得到的新对象

**class ZhugeTarget_Chips(self: [xir.ZhugeTarget_Chips](#xir.ZhugeTarget_Chips), value: int)[#](#xir.ZhugeTarget_Chips)**

表示细分的的Zhuge后端芯片

Members:

ZG330 : ZG330

ZG340 : ZG340

ZG30S : ZG30S

**property name[#](#xir.ZhugeTarget_Chips.name)**

                