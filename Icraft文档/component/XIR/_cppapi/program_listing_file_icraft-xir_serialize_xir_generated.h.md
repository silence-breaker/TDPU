# Program Listing for File xir_generated.h



â†° [Return to documentation for file](file_icraft-xir_serialize_xir_generated.h.md#file-icraft-xir-serialize-xir-generated-h) (`icraft-xir\serialize\xir_generated.h`)


```cpp
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_XIR_FBS_H_
#define FLATBUFFERS_GENERATED_XIR_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fbs {

struct ACos;
struct ACosBuilder;

struct ACosh;
struct ACoshBuilder;

struct ASin;
struct ASinBuilder;

struct ASinh;
struct ASinhBuilder;

struct ATan;
struct ATanBuilder;

struct ATanh;
struct ATanhBuilder;

struct Abs;
struct AbsBuilder;

struct Add;
struct AddBuilder;

struct AlignAxis;
struct AlignAxisBuilder;

struct AlignedUnit;
struct AlignedUnitBuilder;

struct Argmax;
struct ArgmaxBuilder;

struct Argmin;
struct ArgminBuilder;

struct AvgPool1d;
struct AvgPool1dBuilder;

struct AvgPool2d;
struct AvgPool2dBuilder;

struct AvgPool3d;
struct AvgPool3dBuilder;

struct AxisName;
struct AxisNameBuilder;

struct AxisUnit;
struct AxisUnitBuilder;

struct BaseQuantizedType;
struct BaseQuantizedTypeBuilder;

struct BatchNorm1d;
struct BatchNorm1dBuilder;

struct BatchNorm2d;
struct BatchNorm2dBuilder;

struct BatchNorm3d;
struct BatchNorm3dBuilder;

struct Bool;
struct BoolBuilder;

struct BoolType;
struct BoolTypeBuilder;

struct BuyiTarget;
struct BuyiTargetBuilder;

struct CalibratedType;
struct CalibratedTypeBuilder;

struct Cast;
struct CastBuilder;

struct ChannelShuffle;
struct ChannelShuffleBuilder;

struct ChunkMem;
struct ChunkMemBuilder;

struct ClampScalar;
struct ClampScalarBuilder;

struct CompileTarget;
struct CompileTargetBuilder;

struct Concat;
struct ConcatBuilder;

struct Conv1d;
struct Conv1dBuilder;

struct Conv2d;
struct Conv2dBuilder;

struct Conv3d;
struct Conv3dBuilder;

struct ConvTranspose1d;
struct ConvTranspose1dBuilder;

struct ConvTranspose2d;
struct ConvTranspose2dBuilder;

struct ConvTranspose3d;
struct ConvTranspose3dBuilder;

struct Copy;
struct CopyBuilder;

struct Cos;
struct CosBuilder;

struct Cosh;
struct CoshBuilder;

struct CustomTarget;
struct CustomTargetBuilder;

struct Data;
struct DataBuilder;

struct DataType;
struct DataTypeBuilder;

struct Div;
struct DivBuilder;

struct DivideScalar;
struct DivideScalarBuilder;

struct ELU;
struct ELUBuilder;

struct Einsum;
struct EinsumBuilder;

struct Equal;
struct EqualBuilder;

struct ExpQuantizedScale;
struct ExpQuantizedScaleBuilder;

struct ExpQuantizedScaleArray;
struct ExpQuantizedScaleArrayBuilder;

struct Expand;
struct ExpandBuilder;

struct ExternalMem;
struct ExternalMemBuilder;

struct FPGATarget;
struct FPGATargetBuilder;

struct FloatImm;
struct FloatImmBuilder;

struct FloatType;
struct FloatTypeBuilder;

struct GELU;
struct GELUBuilder;

struct Greater;
struct GreaterBuilder;

struct GreaterEqual;
struct GreaterEqualBuilder;

struct HardOp;
struct HardOpBuilder;

struct Hardshrink;
struct HardshrinkBuilder;

struct Hardsigmoid;
struct HardsigmoidBuilder;

struct Hardswish;
struct HardswishBuilder;

struct Hardtanh;
struct HardtanhBuilder;

struct HostMem;
struct HostMemBuilder;

struct HostTarget;
struct HostTargetBuilder;

struct Input;
struct InputBuilder;

struct InstanceNorm1d;
struct InstanceNorm1dBuilder;

struct InstanceNorm2d;
struct InstanceNorm2dBuilder;

struct InstanceNorm3d;
struct InstanceNorm3dBuilder;

struct IntImm;
struct IntImmBuilder;

struct IntegerType;
struct IntegerTypeBuilder;

struct LayerNorm;
struct LayerNormBuilder;

struct Layout;
struct LayoutBuilder;

struct Less;
struct LessBuilder;

struct LessEqual;
struct LessEqualBuilder;

struct Log;
struct LogBuilder;

struct LogSigmoid;
struct LogSigmoidBuilder;

struct LogSoftmax;
struct LogSoftmaxBuilder;

struct Matmul;
struct MatmulBuilder;

struct Max;
struct MaxBuilder;

struct MaxPool1d;
struct MaxPool1dBuilder;

struct MaxPool2d;
struct MaxPool2dBuilder;

struct MaxPool3d;
struct MaxPool3dBuilder;

struct Maximum;
struct MaximumBuilder;

struct Mean;
struct MeanBuilder;

struct MemType;
struct MemTypeBuilder;

struct MergedAxisDistr;
struct MergedAxisDistrBuilder;

struct Min;
struct MinBuilder;

struct Minimum;
struct MinimumBuilder;

struct Mish;
struct MishBuilder;

struct Multiply;
struct MultiplyBuilder;

struct Neg;
struct NegBuilder;

struct Network;
struct NetworkBuilder;

struct NetworkBase;
struct NetworkBaseBuilder;

struct Normalize;
struct NormalizeBuilder;

struct NormalizedQuantizedType;
struct NormalizedQuantizedTypeBuilder;

struct NormalizedType;
struct NormalizedTypeBuilder;

struct NormratioArray;
struct NormratioArrayBuilder;

struct Not;
struct NotBuilder;

struct NotEqual;
struct NotEqualBuilder;

struct ObjectRef;
struct ObjectRefBuilder;

struct OnChipMem;
struct OnChipMemBuilder;

struct Operation;
struct OperationBuilder;

struct Output;
struct OutputBuilder;

struct PReLU;
struct PReLUBuilder;

struct Pad;
struct PadBuilder;

struct Params;
struct ParamsBuilder;

struct PixelShuffle;
struct PixelShuffleBuilder;

struct Pow;
struct PowBuilder;

struct PruneAxis;
struct PruneAxisBuilder;

struct QuantizedScale;
struct QuantizedScaleBuilder;

struct QuantizedScaleArray;
struct QuantizedScaleArrayBuilder;

struct QuantizedType;
struct QuantizedTypeBuilder;

struct ReLU;
struct ReLUBuilder;

struct Reshape;
struct ReshapeBuilder;

struct Resize;
struct ResizeBuilder;

struct Roll;
struct RollBuilder;

struct ScalarImm;
struct ScalarImmBuilder;

struct ScalarType;
struct ScalarTypeBuilder;

struct SiLU;
struct SiLUBuilder;

struct Sigmoid;
struct SigmoidBuilder;

struct Sin;
struct SinBuilder;

struct Sinh;
struct SinhBuilder;

struct Slice;
struct SliceBuilder;

struct Softmax;
struct SoftmaxBuilder;

struct Softplus;
struct SoftplusBuilder;

struct Softshrink;
struct SoftshrinkBuilder;

struct Softsign;
struct SoftsignBuilder;

struct Split;
struct SplitBuilder;

struct Sqrt;
struct SqrtBuilder;

struct Squeeze;
struct SqueezeBuilder;

struct Stack;
struct StackBuilder;

struct Sum;
struct SumBuilder;

struct SwapOrder;
struct SwapOrderBuilder;

struct Tan;
struct TanBuilder;

struct Tanh;
struct TanhBuilder;

struct Tanhshrink;
struct TanhshrinkBuilder;

struct TensorType;
struct TensorTypeBuilder;

struct Tile;
struct TileBuilder;

struct Transpose;
struct TransposeBuilder;

struct Unfold;
struct UnfoldBuilder;

struct Unknown;
struct UnknownBuilder;

struct Unstack;
struct UnstackBuilder;

struct Unsupport;
struct UnsupportBuilder;

struct Upsample;
struct UpsampleBuilder;

struct Value;
struct ValueBuilder;

struct Where;
struct WhereBuilder;

struct WolongTarget;
struct WolongTargetBuilder;

struct ZhugeTarget;
struct ZhugeTargetBuilder;

enum AxisName_box : uint8_t {
  AxisName_box_NONE = 0,
  AxisName_box_AxisUnit = 1,
  AxisName_box_AxisName = 2,
  AxisName_box_MIN = AxisName_box_NONE,
  AxisName_box_MAX = AxisName_box_AxisName
};

inline const AxisName_box (&EnumValuesAxisName_box())[3] {
  static const AxisName_box values[] = {
    AxisName_box_NONE,
    AxisName_box_AxisUnit,
    AxisName_box_AxisName
  };
  return values;
}

inline const char * const *EnumNamesAxisName_box() {
  static const char * const names[4] = {
    "NONE",
    "AxisUnit",
    "AxisName",
    nullptr
  };
  return names;
}

inline const char *EnumNameAxisName_box(AxisName_box e) {
  if (::flatbuffers::IsOutRange(e, AxisName_box_NONE, AxisName_box_AxisName)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAxisName_box()[index];
}

template<typename T> struct AxisName_boxTraits {
  static const AxisName_box enum_value = AxisName_box_NONE;
};

template<> struct AxisName_boxTraits<fbs::AxisUnit> {
  static const AxisName_box enum_value = AxisName_box_AxisUnit;
};

template<> struct AxisName_boxTraits<fbs::AxisName> {
  static const AxisName_box enum_value = AxisName_box_AxisName;
};

bool VerifyAxisName_box(::flatbuffers::Verifier &verifier, const void *obj, AxisName_box type);
bool VerifyAxisName_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum BaseQuantizedType_box : uint8_t {
  BaseQuantizedType_box_NONE = 0,
  BaseQuantizedType_box_CalibratedType = 1,
  BaseQuantizedType_box_NormalizedType = 2,
  BaseQuantizedType_box_NormalizedQuantizedType = 3,
  BaseQuantizedType_box_QuantizedType = 4,
  BaseQuantizedType_box_BaseQuantizedType = 5,
  BaseQuantizedType_box_MIN = BaseQuantizedType_box_NONE,
  BaseQuantizedType_box_MAX = BaseQuantizedType_box_BaseQuantizedType
};

inline const BaseQuantizedType_box (&EnumValuesBaseQuantizedType_box())[6] {
  static const BaseQuantizedType_box values[] = {
    BaseQuantizedType_box_NONE,
    BaseQuantizedType_box_CalibratedType,
    BaseQuantizedType_box_NormalizedType,
    BaseQuantizedType_box_NormalizedQuantizedType,
    BaseQuantizedType_box_QuantizedType,
    BaseQuantizedType_box_BaseQuantizedType
  };
  return values;
}

inline const char * const *EnumNamesBaseQuantizedType_box() {
  static const char * const names[7] = {
    "NONE",
    "CalibratedType",
    "NormalizedType",
    "NormalizedQuantizedType",
    "QuantizedType",
    "BaseQuantizedType",
    nullptr
  };
  return names;
}

inline const char *EnumNameBaseQuantizedType_box(BaseQuantizedType_box e) {
  if (::flatbuffers::IsOutRange(e, BaseQuantizedType_box_NONE, BaseQuantizedType_box_BaseQuantizedType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBaseQuantizedType_box()[index];
}

template<typename T> struct BaseQuantizedType_boxTraits {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_NONE;
};

template<> struct BaseQuantizedType_boxTraits<fbs::CalibratedType> {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_CalibratedType;
};

template<> struct BaseQuantizedType_boxTraits<fbs::NormalizedType> {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_NormalizedType;
};

template<> struct BaseQuantizedType_boxTraits<fbs::NormalizedQuantizedType> {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_NormalizedQuantizedType;
};

template<> struct BaseQuantizedType_boxTraits<fbs::QuantizedType> {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_QuantizedType;
};

template<> struct BaseQuantizedType_boxTraits<fbs::BaseQuantizedType> {
  static const BaseQuantizedType_box enum_value = BaseQuantizedType_box_BaseQuantizedType;
};

bool VerifyBaseQuantizedType_box(::flatbuffers::Verifier &verifier, const void *obj, BaseQuantizedType_box type);
bool VerifyBaseQuantizedType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum CompileTarget_box : uint8_t {
  CompileTarget_box_NONE = 0,
  CompileTarget_box_HostTarget = 1,
  CompileTarget_box_FPGATarget = 2,
  CompileTarget_box_CustomTarget = 3,
  CompileTarget_box_BuyiTarget = 4,
  CompileTarget_box_ZhugeTarget = 5,
  CompileTarget_box_WolongTarget = 6,
  CompileTarget_box_CompileTarget = 7,
  CompileTarget_box_MIN = CompileTarget_box_NONE,
  CompileTarget_box_MAX = CompileTarget_box_CompileTarget
};

inline const CompileTarget_box (&EnumValuesCompileTarget_box())[8] {
  static const CompileTarget_box values[] = {
    CompileTarget_box_NONE,
    CompileTarget_box_HostTarget,
    CompileTarget_box_FPGATarget,
    CompileTarget_box_CustomTarget,
    CompileTarget_box_BuyiTarget,
    CompileTarget_box_ZhugeTarget,
    CompileTarget_box_WolongTarget,
    CompileTarget_box_CompileTarget
  };
  return values;
}

inline const char * const *EnumNamesCompileTarget_box() {
  static const char * const names[9] = {
    "NONE",
    "HostTarget",
    "FPGATarget",
    "CustomTarget",
    "BuyiTarget",
    "ZhugeTarget",
    "WolongTarget",
    "CompileTarget",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompileTarget_box(CompileTarget_box e) {
  if (::flatbuffers::IsOutRange(e, CompileTarget_box_NONE, CompileTarget_box_CompileTarget)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompileTarget_box()[index];
}

template<typename T> struct CompileTarget_boxTraits {
  static const CompileTarget_box enum_value = CompileTarget_box_NONE;
};

template<> struct CompileTarget_boxTraits<fbs::HostTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_HostTarget;
};

template<> struct CompileTarget_boxTraits<fbs::FPGATarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_FPGATarget;
};

template<> struct CompileTarget_boxTraits<fbs::CustomTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_CustomTarget;
};

template<> struct CompileTarget_boxTraits<fbs::BuyiTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_BuyiTarget;
};

template<> struct CompileTarget_boxTraits<fbs::ZhugeTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_ZhugeTarget;
};

template<> struct CompileTarget_boxTraits<fbs::WolongTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_WolongTarget;
};

template<> struct CompileTarget_boxTraits<fbs::CompileTarget> {
  static const CompileTarget_box enum_value = CompileTarget_box_CompileTarget;
};

bool VerifyCompileTarget_box(::flatbuffers::Verifier &verifier, const void *obj, CompileTarget_box type);
bool VerifyCompileTarget_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Data_box : uint8_t {
  Data_box_NONE = 0,
  Data_box_Bool = 1,
  Data_box_IntImm = 2,
  Data_box_FloatImm = 3,
  Data_box_ScalarImm = 4,
  Data_box_Params = 5,
  Data_box_Value = 6,
  Data_box_Data = 7,
  Data_box_MIN = Data_box_NONE,
  Data_box_MAX = Data_box_Data
};

inline const Data_box (&EnumValuesData_box())[8] {
  static const Data_box values[] = {
    Data_box_NONE,
    Data_box_Bool,
    Data_box_IntImm,
    Data_box_FloatImm,
    Data_box_ScalarImm,
    Data_box_Params,
    Data_box_Value,
    Data_box_Data
  };
  return values;
}

inline const char * const *EnumNamesData_box() {
  static const char * const names[9] = {
    "NONE",
    "Bool",
    "IntImm",
    "FloatImm",
    "ScalarImm",
    "Params",
    "Value",
    "Data",
    nullptr
  };
  return names;
}

inline const char *EnumNameData_box(Data_box e) {
  if (::flatbuffers::IsOutRange(e, Data_box_NONE, Data_box_Data)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData_box()[index];
}

template<typename T> struct Data_boxTraits {
  static const Data_box enum_value = Data_box_NONE;
};

template<> struct Data_boxTraits<fbs::Bool> {
  static const Data_box enum_value = Data_box_Bool;
};

template<> struct Data_boxTraits<fbs::IntImm> {
  static const Data_box enum_value = Data_box_IntImm;
};

template<> struct Data_boxTraits<fbs::FloatImm> {
  static const Data_box enum_value = Data_box_FloatImm;
};

template<> struct Data_boxTraits<fbs::ScalarImm> {
  static const Data_box enum_value = Data_box_ScalarImm;
};

template<> struct Data_boxTraits<fbs::Params> {
  static const Data_box enum_value = Data_box_Params;
};

template<> struct Data_boxTraits<fbs::Value> {
  static const Data_box enum_value = Data_box_Value;
};

template<> struct Data_boxTraits<fbs::Data> {
  static const Data_box enum_value = Data_box_Data;
};

bool VerifyData_box(::flatbuffers::Verifier &verifier, const void *obj, Data_box type);
bool VerifyData_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum DataType_box : uint8_t {
  DataType_box_NONE = 0,
  DataType_box_BoolType = 1,
  DataType_box_IntegerType = 2,
  DataType_box_FloatType = 3,
  DataType_box_CalibratedType = 4,
  DataType_box_NormalizedType = 5,
  DataType_box_NormalizedQuantizedType = 6,
  DataType_box_QuantizedType = 7,
  DataType_box_BaseQuantizedType = 8,
  DataType_box_ScalarType = 9,
  DataType_box_TensorType = 10,
  DataType_box_DataType = 11,
  DataType_box_MIN = DataType_box_NONE,
  DataType_box_MAX = DataType_box_DataType
};

inline const DataType_box (&EnumValuesDataType_box())[12] {
  static const DataType_box values[] = {
    DataType_box_NONE,
    DataType_box_BoolType,
    DataType_box_IntegerType,
    DataType_box_FloatType,
    DataType_box_CalibratedType,
    DataType_box_NormalizedType,
    DataType_box_NormalizedQuantizedType,
    DataType_box_QuantizedType,
    DataType_box_BaseQuantizedType,
    DataType_box_ScalarType,
    DataType_box_TensorType,
    DataType_box_DataType
  };
  return values;
}

inline const char * const *EnumNamesDataType_box() {
  static const char * const names[13] = {
    "NONE",
    "BoolType",
    "IntegerType",
    "FloatType",
    "CalibratedType",
    "NormalizedType",
    "NormalizedQuantizedType",
    "QuantizedType",
    "BaseQuantizedType",
    "ScalarType",
    "TensorType",
    "DataType",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType_box(DataType_box e) {
  if (::flatbuffers::IsOutRange(e, DataType_box_NONE, DataType_box_DataType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType_box()[index];
}

template<typename T> struct DataType_boxTraits {
  static const DataType_box enum_value = DataType_box_NONE;
};

template<> struct DataType_boxTraits<fbs::BoolType> {
  static const DataType_box enum_value = DataType_box_BoolType;
};

template<> struct DataType_boxTraits<fbs::IntegerType> {
  static const DataType_box enum_value = DataType_box_IntegerType;
};

template<> struct DataType_boxTraits<fbs::FloatType> {
  static const DataType_box enum_value = DataType_box_FloatType;
};

template<> struct DataType_boxTraits<fbs::CalibratedType> {
  static const DataType_box enum_value = DataType_box_CalibratedType;
};

template<> struct DataType_boxTraits<fbs::NormalizedType> {
  static const DataType_box enum_value = DataType_box_NormalizedType;
};

template<> struct DataType_boxTraits<fbs::NormalizedQuantizedType> {
  static const DataType_box enum_value = DataType_box_NormalizedQuantizedType;
};

template<> struct DataType_boxTraits<fbs::QuantizedType> {
  static const DataType_box enum_value = DataType_box_QuantizedType;
};

template<> struct DataType_boxTraits<fbs::BaseQuantizedType> {
  static const DataType_box enum_value = DataType_box_BaseQuantizedType;
};

template<> struct DataType_boxTraits<fbs::ScalarType> {
  static const DataType_box enum_value = DataType_box_ScalarType;
};

template<> struct DataType_boxTraits<fbs::TensorType> {
  static const DataType_box enum_value = DataType_box_TensorType;
};

template<> struct DataType_boxTraits<fbs::DataType> {
  static const DataType_box enum_value = DataType_box_DataType;
};

bool VerifyDataType_box(::flatbuffers::Verifier &verifier, const void *obj, DataType_box type);
bool VerifyDataType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum MemType_box : uint8_t {
  MemType_box_NONE = 0,
  MemType_box_HostMem = 1,
  MemType_box_OnChipMem = 2,
  MemType_box_ExternalMem = 3,
  MemType_box_ChunkMem = 4,
  MemType_box_MemType = 5,
  MemType_box_MIN = MemType_box_NONE,
  MemType_box_MAX = MemType_box_MemType
};

inline const MemType_box (&EnumValuesMemType_box())[6] {
  static const MemType_box values[] = {
    MemType_box_NONE,
    MemType_box_HostMem,
    MemType_box_OnChipMem,
    MemType_box_ExternalMem,
    MemType_box_ChunkMem,
    MemType_box_MemType
  };
  return values;
}

inline const char * const *EnumNamesMemType_box() {
  static const char * const names[7] = {
    "NONE",
    "HostMem",
    "OnChipMem",
    "ExternalMem",
    "ChunkMem",
    "MemType",
    nullptr
  };
  return names;
}

inline const char *EnumNameMemType_box(MemType_box e) {
  if (::flatbuffers::IsOutRange(e, MemType_box_NONE, MemType_box_MemType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMemType_box()[index];
}

template<typename T> struct MemType_boxTraits {
  static const MemType_box enum_value = MemType_box_NONE;
};

template<> struct MemType_boxTraits<fbs::HostMem> {
  static const MemType_box enum_value = MemType_box_HostMem;
};

template<> struct MemType_boxTraits<fbs::OnChipMem> {
  static const MemType_box enum_value = MemType_box_OnChipMem;
};

template<> struct MemType_boxTraits<fbs::ExternalMem> {
  static const MemType_box enum_value = MemType_box_ExternalMem;
};

template<> struct MemType_boxTraits<fbs::ChunkMem> {
  static const MemType_box enum_value = MemType_box_ChunkMem;
};

template<> struct MemType_boxTraits<fbs::MemType> {
  static const MemType_box enum_value = MemType_box_MemType;
};

bool VerifyMemType_box(::flatbuffers::Verifier &verifier, const void *obj, MemType_box type);
bool VerifyMemType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum NetworkBase_box : uint8_t {
  NetworkBase_box_NONE = 0,
  NetworkBase_box_Network = 1,
  NetworkBase_box_NetworkBase = 2,
  NetworkBase_box_MIN = NetworkBase_box_NONE,
  NetworkBase_box_MAX = NetworkBase_box_NetworkBase
};

inline const NetworkBase_box (&EnumValuesNetworkBase_box())[3] {
  static const NetworkBase_box values[] = {
    NetworkBase_box_NONE,
    NetworkBase_box_Network,
    NetworkBase_box_NetworkBase
  };
  return values;
}

inline const char * const *EnumNamesNetworkBase_box() {
  static const char * const names[4] = {
    "NONE",
    "Network",
    "NetworkBase",
    nullptr
  };
  return names;
}

inline const char *EnumNameNetworkBase_box(NetworkBase_box e) {
  if (::flatbuffers::IsOutRange(e, NetworkBase_box_NONE, NetworkBase_box_NetworkBase)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNetworkBase_box()[index];
}

template<typename T> struct NetworkBase_boxTraits {
  static const NetworkBase_box enum_value = NetworkBase_box_NONE;
};

template<> struct NetworkBase_boxTraits<fbs::Network> {
  static const NetworkBase_box enum_value = NetworkBase_box_Network;
};

template<> struct NetworkBase_boxTraits<fbs::NetworkBase> {
  static const NetworkBase_box enum_value = NetworkBase_box_NetworkBase;
};

bool VerifyNetworkBase_box(::flatbuffers::Verifier &verifier, const void *obj, NetworkBase_box type);
bool VerifyNetworkBase_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ObjectRef_box : uint8_t {
  ObjectRef_box_NONE = 0,
  ObjectRef_box_HostTarget = 1,
  ObjectRef_box_FPGATarget = 2,
  ObjectRef_box_CustomTarget = 3,
  ObjectRef_box_BuyiTarget = 4,
  ObjectRef_box_ZhugeTarget = 5,
  ObjectRef_box_WolongTarget = 6,
  ObjectRef_box_CompileTarget = 7,
  ObjectRef_box_Bool = 8,
  ObjectRef_box_IntImm = 9,
  ObjectRef_box_FloatImm = 10,
  ObjectRef_box_ScalarImm = 11,
  ObjectRef_box_Params = 12,
  ObjectRef_box_Value = 13,
  ObjectRef_box_Data = 14,
  ObjectRef_box_BoolType = 15,
  ObjectRef_box_IntegerType = 16,
  ObjectRef_box_FloatType = 17,
  ObjectRef_box_CalibratedType = 18,
  ObjectRef_box_NormalizedType = 19,
  ObjectRef_box_NormalizedQuantizedType = 20,
  ObjectRef_box_QuantizedType = 21,
  ObjectRef_box_BaseQuantizedType = 22,
  ObjectRef_box_ScalarType = 23,
  ObjectRef_box_TensorType = 24,
  ObjectRef_box_DataType = 25,
  ObjectRef_box_MergedAxisDistr = 26,
  ObjectRef_box_NormratioArray = 27,
  ObjectRef_box_ExpQuantizedScale = 28,
  ObjectRef_box_QuantizedScale = 29,
  ObjectRef_box_ExpQuantizedScaleArray = 30,
  ObjectRef_box_QuantizedScaleArray = 31,
  ObjectRef_box_AxisUnit = 32,
  ObjectRef_box_AxisName = 33,
  ObjectRef_box_Layout = 34,
  ObjectRef_box_HostMem = 35,
  ObjectRef_box_OnChipMem = 36,
  ObjectRef_box_ExternalMem = 37,
  ObjectRef_box_ChunkMem = 38,
  ObjectRef_box_MemType = 39,
  ObjectRef_box_Network = 40,
  ObjectRef_box_NetworkBase = 41,
  ObjectRef_box_Input = 42,
  ObjectRef_box_Output = 43,
  ObjectRef_box_Abs = 44,
  ObjectRef_box_ACos = 45,
  ObjectRef_box_ACosh = 46,
  ObjectRef_box_Add = 47,
  ObjectRef_box_AlignAxis = 48,
  ObjectRef_box_Argmax = 49,
  ObjectRef_box_Argmin = 50,
  ObjectRef_box_ASin = 51,
  ObjectRef_box_ASinh = 52,
  ObjectRef_box_ATan = 53,
  ObjectRef_box_ATanh = 54,
  ObjectRef_box_AvgPool1d = 55,
  ObjectRef_box_AvgPool2d = 56,
  ObjectRef_box_AvgPool3d = 57,
  ObjectRef_box_BatchNorm1d = 58,
  ObjectRef_box_BatchNorm2d = 59,
  ObjectRef_box_BatchNorm3d = 60,
  ObjectRef_box_Cast = 61,
  ObjectRef_box_ChannelShuffle = 62,
  ObjectRef_box_ClampScalar = 63,
  ObjectRef_box_Concat = 64,
  ObjectRef_box_Conv1d = 65,
  ObjectRef_box_Conv2d = 66,
  ObjectRef_box_Conv3d = 67,
  ObjectRef_box_ConvTranspose1d = 68,
  ObjectRef_box_ConvTranspose2d = 69,
  ObjectRef_box_ConvTranspose3d = 70,
  ObjectRef_box_Copy = 71,
  ObjectRef_box_Cos = 72,
  ObjectRef_box_Cosh = 73,
  ObjectRef_box_Div = 74,
  ObjectRef_box_DivideScalar = 75,
  ObjectRef_box_Einsum = 76,
  ObjectRef_box_ELU = 77,
  ObjectRef_box_Equal = 78,
  ObjectRef_box_Expand = 79,
  ObjectRef_box_GELU = 80,
  ObjectRef_box_Greater = 81,
  ObjectRef_box_GreaterEqual = 82,
  ObjectRef_box_HardOp = 83,
  ObjectRef_box_Hardshrink = 84,
  ObjectRef_box_Hardsigmoid = 85,
  ObjectRef_box_Hardswish = 86,
  ObjectRef_box_Hardtanh = 87,
  ObjectRef_box_InstanceNorm1d = 88,
  ObjectRef_box_InstanceNorm2d = 89,
  ObjectRef_box_InstanceNorm3d = 90,
  ObjectRef_box_LayerNorm = 91,
  ObjectRef_box_Less = 92,
  ObjectRef_box_LessEqual = 93,
  ObjectRef_box_Log = 94,
  ObjectRef_box_LogSigmoid = 95,
  ObjectRef_box_LogSoftmax = 96,
  ObjectRef_box_Matmul = 97,
  ObjectRef_box_Max = 98,
  ObjectRef_box_Maximum = 99,
  ObjectRef_box_MaxPool1d = 100,
  ObjectRef_box_MaxPool2d = 101,
  ObjectRef_box_MaxPool3d = 102,
  ObjectRef_box_Mean = 103,
  ObjectRef_box_Min = 104,
  ObjectRef_box_Minimum = 105,
  ObjectRef_box_Mish = 106,
  ObjectRef_box_Multiply = 107,
  ObjectRef_box_Neg = 108,
  ObjectRef_box_Normalize = 109,
  ObjectRef_box_Not = 110,
  ObjectRef_box_NotEqual = 111,
  ObjectRef_box_Pad = 112,
  ObjectRef_box_PixelShuffle = 113,
  ObjectRef_box_Pow = 114,
  ObjectRef_box_PReLU = 115,
  ObjectRef_box_PruneAxis = 116,
  ObjectRef_box_ReLU = 117,
  ObjectRef_box_Reshape = 118,
  ObjectRef_box_Resize = 119,
  ObjectRef_box_Roll = 120,
  ObjectRef_box_Sigmoid = 121,
  ObjectRef_box_SiLU = 122,
  ObjectRef_box_Sin = 123,
  ObjectRef_box_Sinh = 124,
  ObjectRef_box_Slice = 125,
  ObjectRef_box_Softmax = 126,
  ObjectRef_box_Softplus = 127,
  ObjectRef_box_Softshrink = 128,
  ObjectRef_box_Softsign = 129,
  ObjectRef_box_Split = 130,
  ObjectRef_box_Sqrt = 131,
  ObjectRef_box_Squeeze = 132,
  ObjectRef_box_Stack = 133,
  ObjectRef_box_Sum = 134,
  ObjectRef_box_SwapOrder = 135,
  ObjectRef_box_Tan = 136,
  ObjectRef_box_Tanh = 137,
  ObjectRef_box_Tanhshrink = 138,
  ObjectRef_box_Tile = 139,
  ObjectRef_box_Transpose = 140,
  ObjectRef_box_Unfold = 141,
  ObjectRef_box_Unknown = 142,
  ObjectRef_box_Unstack = 143,
  ObjectRef_box_Unsupport = 144,
  ObjectRef_box_Upsample = 145,
  ObjectRef_box_Where = 146,
  ObjectRef_box_Operation = 147,
  ObjectRef_box_AlignedUnit = 148,
  ObjectRef_box_ObjectRef = 149,
  ObjectRef_box_MIN = ObjectRef_box_NONE,
  ObjectRef_box_MAX = ObjectRef_box_ObjectRef
};

inline const ObjectRef_box (&EnumValuesObjectRef_box())[150] {
  static const ObjectRef_box values[] = {
    ObjectRef_box_NONE,
    ObjectRef_box_HostTarget,
    ObjectRef_box_FPGATarget,
    ObjectRef_box_CustomTarget,
    ObjectRef_box_BuyiTarget,
    ObjectRef_box_ZhugeTarget,
    ObjectRef_box_WolongTarget,
    ObjectRef_box_CompileTarget,
    ObjectRef_box_Bool,
    ObjectRef_box_IntImm,
    ObjectRef_box_FloatImm,
    ObjectRef_box_ScalarImm,
    ObjectRef_box_Params,
    ObjectRef_box_Value,
    ObjectRef_box_Data,
    ObjectRef_box_BoolType,
    ObjectRef_box_IntegerType,
    ObjectRef_box_FloatType,
    ObjectRef_box_CalibratedType,
    ObjectRef_box_NormalizedType,
    ObjectRef_box_NormalizedQuantizedType,
    ObjectRef_box_QuantizedType,
    ObjectRef_box_BaseQuantizedType,
    ObjectRef_box_ScalarType,
    ObjectRef_box_TensorType,
    ObjectRef_box_DataType,
    ObjectRef_box_MergedAxisDistr,
    ObjectRef_box_NormratioArray,
    ObjectRef_box_ExpQuantizedScale,
    ObjectRef_box_QuantizedScale,
    ObjectRef_box_ExpQuantizedScaleArray,
    ObjectRef_box_QuantizedScaleArray,
    ObjectRef_box_AxisUnit,
    ObjectRef_box_AxisName,
    ObjectRef_box_Layout,
    ObjectRef_box_HostMem,
    ObjectRef_box_OnChipMem,
    ObjectRef_box_ExternalMem,
    ObjectRef_box_ChunkMem,
    ObjectRef_box_MemType,
    ObjectRef_box_Network,
    ObjectRef_box_NetworkBase,
    ObjectRef_box_Input,
    ObjectRef_box_Output,
    ObjectRef_box_Abs,
    ObjectRef_box_ACos,
    ObjectRef_box_ACosh,
    ObjectRef_box_Add,
    ObjectRef_box_AlignAxis,
    ObjectRef_box_Argmax,
    ObjectRef_box_Argmin,
    ObjectRef_box_ASin,
    ObjectRef_box_ASinh,
    ObjectRef_box_ATan,
    ObjectRef_box_ATanh,
    ObjectRef_box_AvgPool1d,
    ObjectRef_box_AvgPool2d,
    ObjectRef_box_AvgPool3d,
    ObjectRef_box_BatchNorm1d,
    ObjectRef_box_BatchNorm2d,
    ObjectRef_box_BatchNorm3d,
    ObjectRef_box_Cast,
    ObjectRef_box_ChannelShuffle,
    ObjectRef_box_ClampScalar,
    ObjectRef_box_Concat,
    ObjectRef_box_Conv1d,
    ObjectRef_box_Conv2d,
    ObjectRef_box_Conv3d,
    ObjectRef_box_ConvTranspose1d,
    ObjectRef_box_ConvTranspose2d,
    ObjectRef_box_ConvTranspose3d,
    ObjectRef_box_Copy,
    ObjectRef_box_Cos,
    ObjectRef_box_Cosh,
    ObjectRef_box_Div,
    ObjectRef_box_DivideScalar,
    ObjectRef_box_Einsum,
    ObjectRef_box_ELU,
    ObjectRef_box_Equal,
    ObjectRef_box_Expand,
    ObjectRef_box_GELU,
    ObjectRef_box_Greater,
    ObjectRef_box_GreaterEqual,
    ObjectRef_box_HardOp,
    ObjectRef_box_Hardshrink,
    ObjectRef_box_Hardsigmoid,
    ObjectRef_box_Hardswish,
    ObjectRef_box_Hardtanh,
    ObjectRef_box_InstanceNorm1d,
    ObjectRef_box_InstanceNorm2d,
    ObjectRef_box_InstanceNorm3d,
    ObjectRef_box_LayerNorm,
    ObjectRef_box_Less,
    ObjectRef_box_LessEqual,
    ObjectRef_box_Log,
    ObjectRef_box_LogSigmoid,
    ObjectRef_box_LogSoftmax,
    ObjectRef_box_Matmul,
    ObjectRef_box_Max,
    ObjectRef_box_Maximum,
    ObjectRef_box_MaxPool1d,
    ObjectRef_box_MaxPool2d,
    ObjectRef_box_MaxPool3d,
    ObjectRef_box_Mean,
    ObjectRef_box_Min,
    ObjectRef_box_Minimum,
    ObjectRef_box_Mish,
    ObjectRef_box_Multiply,
    ObjectRef_box_Neg,
    ObjectRef_box_Normalize,
    ObjectRef_box_Not,
    ObjectRef_box_NotEqual,
    ObjectRef_box_Pad,
    ObjectRef_box_PixelShuffle,
    ObjectRef_box_Pow,
    ObjectRef_box_PReLU,
    ObjectRef_box_PruneAxis,
    ObjectRef_box_ReLU,
    ObjectRef_box_Reshape,
    ObjectRef_box_Resize,
    ObjectRef_box_Roll,
    ObjectRef_box_Sigmoid,
    ObjectRef_box_SiLU,
    ObjectRef_box_Sin,
    ObjectRef_box_Sinh,
    ObjectRef_box_Slice,
    ObjectRef_box_Softmax,
    ObjectRef_box_Softplus,
    ObjectRef_box_Softshrink,
    ObjectRef_box_Softsign,
    ObjectRef_box_Split,
    ObjectRef_box_Sqrt,
    ObjectRef_box_Squeeze,
    ObjectRef_box_Stack,
    ObjectRef_box_Sum,
    ObjectRef_box_SwapOrder,
    ObjectRef_box_Tan,
    ObjectRef_box_Tanh,
    ObjectRef_box_Tanhshrink,
    ObjectRef_box_Tile,
    ObjectRef_box_Transpose,
    ObjectRef_box_Unfold,
    ObjectRef_box_Unknown,
    ObjectRef_box_Unstack,
    ObjectRef_box_Unsupport,
    ObjectRef_box_Upsample,
    ObjectRef_box_Where,
    ObjectRef_box_Operation,
    ObjectRef_box_AlignedUnit,
    ObjectRef_box_ObjectRef
  };
  return values;
}

inline const char * const *EnumNamesObjectRef_box() {
  static const char * const names[151] = {
    "NONE",
    "HostTarget",
    "FPGATarget",
    "CustomTarget",
    "BuyiTarget",
    "ZhugeTarget",
    "WolongTarget",
    "CompileTarget",
    "Bool",
    "IntImm",
    "FloatImm",
    "ScalarImm",
    "Params",
    "Value",
    "Data",
    "BoolType",
    "IntegerType",
    "FloatType",
    "CalibratedType",
    "NormalizedType",
    "NormalizedQuantizedType",
    "QuantizedType",
    "BaseQuantizedType",
    "ScalarType",
    "TensorType",
    "DataType",
    "MergedAxisDistr",
    "NormratioArray",
    "ExpQuantizedScale",
    "QuantizedScale",
    "ExpQuantizedScaleArray",
    "QuantizedScaleArray",
    "AxisUnit",
    "AxisName",
    "Layout",
    "HostMem",
    "OnChipMem",
    "ExternalMem",
    "ChunkMem",
    "MemType",
    "Network",
    "NetworkBase",
    "Input",
    "Output",
    "Abs",
    "ACos",
    "ACosh",
    "Add",
    "AlignAxis",
    "Argmax",
    "Argmin",
    "ASin",
    "ASinh",
    "ATan",
    "ATanh",
    "AvgPool1d",
    "AvgPool2d",
    "AvgPool3d",
    "BatchNorm1d",
    "BatchNorm2d",
    "BatchNorm3d",
    "Cast",
    "ChannelShuffle",
    "ClampScalar",
    "Concat",
    "Conv1d",
    "Conv2d",
    "Conv3d",
    "ConvTranspose1d",
    "ConvTranspose2d",
    "ConvTranspose3d",
    "Copy",
    "Cos",
    "Cosh",
    "Div",
    "DivideScalar",
    "Einsum",
    "ELU",
    "Equal",
    "Expand",
    "GELU",
    "Greater",
    "GreaterEqual",
    "HardOp",
    "Hardshrink",
    "Hardsigmoid",
    "Hardswish",
    "Hardtanh",
    "InstanceNorm1d",
    "InstanceNorm2d",
    "InstanceNorm3d",
    "LayerNorm",
    "Less",
    "LessEqual",
    "Log",
    "LogSigmoid",
    "LogSoftmax",
    "Matmul",
    "Max",
    "Maximum",
    "MaxPool1d",
    "MaxPool2d",
    "MaxPool3d",
    "Mean",
    "Min",
    "Minimum",
    "Mish",
    "Multiply",
    "Neg",
    "Normalize",
    "Not",
    "NotEqual",
    "Pad",
    "PixelShuffle",
    "Pow",
    "PReLU",
    "PruneAxis",
    "ReLU",
    "Reshape",
    "Resize",
    "Roll",
    "Sigmoid",
    "SiLU",
    "Sin",
    "Sinh",
    "Slice",
    "Softmax",
    "Softplus",
    "Softshrink",
    "Softsign",
    "Split",
    "Sqrt",
    "Squeeze",
    "Stack",
    "Sum",
    "SwapOrder",
    "Tan",
    "Tanh",
    "Tanhshrink",
    "Tile",
    "Transpose",
    "Unfold",
    "Unknown",
    "Unstack",
    "Unsupport",
    "Upsample",
    "Where",
    "Operation",
    "AlignedUnit",
    "ObjectRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectRef_box(ObjectRef_box e) {
  if (::flatbuffers::IsOutRange(e, ObjectRef_box_NONE, ObjectRef_box_ObjectRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectRef_box()[index];
}

template<typename T> struct ObjectRef_boxTraits {
  static const ObjectRef_box enum_value = ObjectRef_box_NONE;
};

template<> struct ObjectRef_boxTraits<fbs::HostTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_HostTarget;
};

template<> struct ObjectRef_boxTraits<fbs::FPGATarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_FPGATarget;
};

template<> struct ObjectRef_boxTraits<fbs::CustomTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_CustomTarget;
};

template<> struct ObjectRef_boxTraits<fbs::BuyiTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_BuyiTarget;
};

template<> struct ObjectRef_boxTraits<fbs::ZhugeTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_ZhugeTarget;
};

template<> struct ObjectRef_boxTraits<fbs::WolongTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_WolongTarget;
};

template<> struct ObjectRef_boxTraits<fbs::CompileTarget> {
  static const ObjectRef_box enum_value = ObjectRef_box_CompileTarget;
};

template<> struct ObjectRef_boxTraits<fbs::Bool> {
  static const ObjectRef_box enum_value = ObjectRef_box_Bool;
};

template<> struct ObjectRef_boxTraits<fbs::IntImm> {
  static const ObjectRef_box enum_value = ObjectRef_box_IntImm;
};

template<> struct ObjectRef_boxTraits<fbs::FloatImm> {
  static const ObjectRef_box enum_value = ObjectRef_box_FloatImm;
};

template<> struct ObjectRef_boxTraits<fbs::ScalarImm> {
  static const ObjectRef_box enum_value = ObjectRef_box_ScalarImm;
};

template<> struct ObjectRef_boxTraits<fbs::Params> {
  static const ObjectRef_box enum_value = ObjectRef_box_Params;
};

template<> struct ObjectRef_boxTraits<fbs::Value> {
  static const ObjectRef_box enum_value = ObjectRef_box_Value;
};

template<> struct ObjectRef_boxTraits<fbs::Data> {
  static const ObjectRef_box enum_value = ObjectRef_box_Data;
};

template<> struct ObjectRef_boxTraits<fbs::BoolType> {
  static const ObjectRef_box enum_value = ObjectRef_box_BoolType;
};

template<> struct ObjectRef_boxTraits<fbs::IntegerType> {
  static const ObjectRef_box enum_value = ObjectRef_box_IntegerType;
};

template<> struct ObjectRef_boxTraits<fbs::FloatType> {
  static const ObjectRef_box enum_value = ObjectRef_box_FloatType;
};

template<> struct ObjectRef_boxTraits<fbs::CalibratedType> {
  static const ObjectRef_box enum_value = ObjectRef_box_CalibratedType;
};

template<> struct ObjectRef_boxTraits<fbs::NormalizedType> {
  static const ObjectRef_box enum_value = ObjectRef_box_NormalizedType;
};

template<> struct ObjectRef_boxTraits<fbs::NormalizedQuantizedType> {
  static const ObjectRef_box enum_value = ObjectRef_box_NormalizedQuantizedType;
};

template<> struct ObjectRef_boxTraits<fbs::QuantizedType> {
  static const ObjectRef_box enum_value = ObjectRef_box_QuantizedType;
};

template<> struct ObjectRef_boxTraits<fbs::BaseQuantizedType> {
  static const ObjectRef_box enum_value = ObjectRef_box_BaseQuantizedType;
};

template<> struct ObjectRef_boxTraits<fbs::ScalarType> {
  static const ObjectRef_box enum_value = ObjectRef_box_ScalarType;
};

template<> struct ObjectRef_boxTraits<fbs::TensorType> {
  static const ObjectRef_box enum_value = ObjectRef_box_TensorType;
};

template<> struct ObjectRef_boxTraits<fbs::DataType> {
  static const ObjectRef_box enum_value = ObjectRef_box_DataType;
};

template<> struct ObjectRef_boxTraits<fbs::MergedAxisDistr> {
  static const ObjectRef_box enum_value = ObjectRef_box_MergedAxisDistr;
};

template<> struct ObjectRef_boxTraits<fbs::NormratioArray> {
  static const ObjectRef_box enum_value = ObjectRef_box_NormratioArray;
};

template<> struct ObjectRef_boxTraits<fbs::ExpQuantizedScale> {
  static const ObjectRef_box enum_value = ObjectRef_box_ExpQuantizedScale;
};

template<> struct ObjectRef_boxTraits<fbs::QuantizedScale> {
  static const ObjectRef_box enum_value = ObjectRef_box_QuantizedScale;
};

template<> struct ObjectRef_boxTraits<fbs::ExpQuantizedScaleArray> {
  static const ObjectRef_box enum_value = ObjectRef_box_ExpQuantizedScaleArray;
};

template<> struct ObjectRef_boxTraits<fbs::QuantizedScaleArray> {
  static const ObjectRef_box enum_value = ObjectRef_box_QuantizedScaleArray;
};

template<> struct ObjectRef_boxTraits<fbs::AxisUnit> {
  static const ObjectRef_box enum_value = ObjectRef_box_AxisUnit;
};

template<> struct ObjectRef_boxTraits<fbs::AxisName> {
  static const ObjectRef_box enum_value = ObjectRef_box_AxisName;
};

template<> struct ObjectRef_boxTraits<fbs::Layout> {
  static const ObjectRef_box enum_value = ObjectRef_box_Layout;
};

template<> struct ObjectRef_boxTraits<fbs::HostMem> {
  static const ObjectRef_box enum_value = ObjectRef_box_HostMem;
};

template<> struct ObjectRef_boxTraits<fbs::OnChipMem> {
  static const ObjectRef_box enum_value = ObjectRef_box_OnChipMem;
};

template<> struct ObjectRef_boxTraits<fbs::ExternalMem> {
  static const ObjectRef_box enum_value = ObjectRef_box_ExternalMem;
};

template<> struct ObjectRef_boxTraits<fbs::ChunkMem> {
  static const ObjectRef_box enum_value = ObjectRef_box_ChunkMem;
};

template<> struct ObjectRef_boxTraits<fbs::MemType> {
  static const ObjectRef_box enum_value = ObjectRef_box_MemType;
};

template<> struct ObjectRef_boxTraits<fbs::Network> {
  static const ObjectRef_box enum_value = ObjectRef_box_Network;
};

template<> struct ObjectRef_boxTraits<fbs::NetworkBase> {
  static const ObjectRef_box enum_value = ObjectRef_box_NetworkBase;
};

template<> struct ObjectRef_boxTraits<fbs::Input> {
  static const ObjectRef_box enum_value = ObjectRef_box_Input;
};

template<> struct ObjectRef_boxTraits<fbs::Output> {
  static const ObjectRef_box enum_value = ObjectRef_box_Output;
};

template<> struct ObjectRef_boxTraits<fbs::Abs> {
  static const ObjectRef_box enum_value = ObjectRef_box_Abs;
};

template<> struct ObjectRef_boxTraits<fbs::ACos> {
  static const ObjectRef_box enum_value = ObjectRef_box_ACos;
};

template<> struct ObjectRef_boxTraits<fbs::ACosh> {
  static const ObjectRef_box enum_value = ObjectRef_box_ACosh;
};

template<> struct ObjectRef_boxTraits<fbs::Add> {
  static const ObjectRef_box enum_value = ObjectRef_box_Add;
};

template<> struct ObjectRef_boxTraits<fbs::AlignAxis> {
  static const ObjectRef_box enum_value = ObjectRef_box_AlignAxis;
};

template<> struct ObjectRef_boxTraits<fbs::Argmax> {
  static const ObjectRef_box enum_value = ObjectRef_box_Argmax;
};

template<> struct ObjectRef_boxTraits<fbs::Argmin> {
  static const ObjectRef_box enum_value = ObjectRef_box_Argmin;
};

template<> struct ObjectRef_boxTraits<fbs::ASin> {
  static const ObjectRef_box enum_value = ObjectRef_box_ASin;
};

template<> struct ObjectRef_boxTraits<fbs::ASinh> {
  static const ObjectRef_box enum_value = ObjectRef_box_ASinh;
};

template<> struct ObjectRef_boxTraits<fbs::ATan> {
  static const ObjectRef_box enum_value = ObjectRef_box_ATan;
};

template<> struct ObjectRef_boxTraits<fbs::ATanh> {
  static const ObjectRef_box enum_value = ObjectRef_box_ATanh;
};

template<> struct ObjectRef_boxTraits<fbs::AvgPool1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_AvgPool1d;
};

template<> struct ObjectRef_boxTraits<fbs::AvgPool2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_AvgPool2d;
};

template<> struct ObjectRef_boxTraits<fbs::AvgPool3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_AvgPool3d;
};

template<> struct ObjectRef_boxTraits<fbs::BatchNorm1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_BatchNorm1d;
};

template<> struct ObjectRef_boxTraits<fbs::BatchNorm2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_BatchNorm2d;
};

template<> struct ObjectRef_boxTraits<fbs::BatchNorm3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_BatchNorm3d;
};

template<> struct ObjectRef_boxTraits<fbs::Cast> {
  static const ObjectRef_box enum_value = ObjectRef_box_Cast;
};

template<> struct ObjectRef_boxTraits<fbs::ChannelShuffle> {
  static const ObjectRef_box enum_value = ObjectRef_box_ChannelShuffle;
};

template<> struct ObjectRef_boxTraits<fbs::ClampScalar> {
  static const ObjectRef_box enum_value = ObjectRef_box_ClampScalar;
};

template<> struct ObjectRef_boxTraits<fbs::Concat> {
  static const ObjectRef_box enum_value = ObjectRef_box_Concat;
};

template<> struct ObjectRef_boxTraits<fbs::Conv1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_Conv1d;
};

template<> struct ObjectRef_boxTraits<fbs::Conv2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_Conv2d;
};

template<> struct ObjectRef_boxTraits<fbs::Conv3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_Conv3d;
};

template<> struct ObjectRef_boxTraits<fbs::ConvTranspose1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_ConvTranspose1d;
};

template<> struct ObjectRef_boxTraits<fbs::ConvTranspose2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_ConvTranspose2d;
};

template<> struct ObjectRef_boxTraits<fbs::ConvTranspose3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_ConvTranspose3d;
};

template<> struct ObjectRef_boxTraits<fbs::Copy> {
  static const ObjectRef_box enum_value = ObjectRef_box_Copy;
};

template<> struct ObjectRef_boxTraits<fbs::Cos> {
  static const ObjectRef_box enum_value = ObjectRef_box_Cos;
};

template<> struct ObjectRef_boxTraits<fbs::Cosh> {
  static const ObjectRef_box enum_value = ObjectRef_box_Cosh;
};

template<> struct ObjectRef_boxTraits<fbs::Div> {
  static const ObjectRef_box enum_value = ObjectRef_box_Div;
};

template<> struct ObjectRef_boxTraits<fbs::DivideScalar> {
  static const ObjectRef_box enum_value = ObjectRef_box_DivideScalar;
};

template<> struct ObjectRef_boxTraits<fbs::Einsum> {
  static const ObjectRef_box enum_value = ObjectRef_box_Einsum;
};

template<> struct ObjectRef_boxTraits<fbs::ELU> {
  static const ObjectRef_box enum_value = ObjectRef_box_ELU;
};

template<> struct ObjectRef_boxTraits<fbs::Equal> {
  static const ObjectRef_box enum_value = ObjectRef_box_Equal;
};

template<> struct ObjectRef_boxTraits<fbs::Expand> {
  static const ObjectRef_box enum_value = ObjectRef_box_Expand;
};

template<> struct ObjectRef_boxTraits<fbs::GELU> {
  static const ObjectRef_box enum_value = ObjectRef_box_GELU;
};

template<> struct ObjectRef_boxTraits<fbs::Greater> {
  static const ObjectRef_box enum_value = ObjectRef_box_Greater;
};

template<> struct ObjectRef_boxTraits<fbs::GreaterEqual> {
  static const ObjectRef_box enum_value = ObjectRef_box_GreaterEqual;
};

template<> struct ObjectRef_boxTraits<fbs::HardOp> {
  static const ObjectRef_box enum_value = ObjectRef_box_HardOp;
};

template<> struct ObjectRef_boxTraits<fbs::Hardshrink> {
  static const ObjectRef_box enum_value = ObjectRef_box_Hardshrink;
};

template<> struct ObjectRef_boxTraits<fbs::Hardsigmoid> {
  static const ObjectRef_box enum_value = ObjectRef_box_Hardsigmoid;
};

template<> struct ObjectRef_boxTraits<fbs::Hardswish> {
  static const ObjectRef_box enum_value = ObjectRef_box_Hardswish;
};

template<> struct ObjectRef_boxTraits<fbs::Hardtanh> {
  static const ObjectRef_box enum_value = ObjectRef_box_Hardtanh;
};

template<> struct ObjectRef_boxTraits<fbs::InstanceNorm1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_InstanceNorm1d;
};

template<> struct ObjectRef_boxTraits<fbs::InstanceNorm2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_InstanceNorm2d;
};

template<> struct ObjectRef_boxTraits<fbs::InstanceNorm3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_InstanceNorm3d;
};

template<> struct ObjectRef_boxTraits<fbs::LayerNorm> {
  static const ObjectRef_box enum_value = ObjectRef_box_LayerNorm;
};

template<> struct ObjectRef_boxTraits<fbs::Less> {
  static const ObjectRef_box enum_value = ObjectRef_box_Less;
};

template<> struct ObjectRef_boxTraits<fbs::LessEqual> {
  static const ObjectRef_box enum_value = ObjectRef_box_LessEqual;
};

template<> struct ObjectRef_boxTraits<fbs::Log> {
  static const ObjectRef_box enum_value = ObjectRef_box_Log;
};

template<> struct ObjectRef_boxTraits<fbs::LogSigmoid> {
  static const ObjectRef_box enum_value = ObjectRef_box_LogSigmoid;
};

template<> struct ObjectRef_boxTraits<fbs::LogSoftmax> {
  static const ObjectRef_box enum_value = ObjectRef_box_LogSoftmax;
};

template<> struct ObjectRef_boxTraits<fbs::Matmul> {
  static const ObjectRef_box enum_value = ObjectRef_box_Matmul;
};

template<> struct ObjectRef_boxTraits<fbs::Max> {
  static const ObjectRef_box enum_value = ObjectRef_box_Max;
};

template<> struct ObjectRef_boxTraits<fbs::Maximum> {
  static const ObjectRef_box enum_value = ObjectRef_box_Maximum;
};

template<> struct ObjectRef_boxTraits<fbs::MaxPool1d> {
  static const ObjectRef_box enum_value = ObjectRef_box_MaxPool1d;
};

template<> struct ObjectRef_boxTraits<fbs::MaxPool2d> {
  static const ObjectRef_box enum_value = ObjectRef_box_MaxPool2d;
};

template<> struct ObjectRef_boxTraits<fbs::MaxPool3d> {
  static const ObjectRef_box enum_value = ObjectRef_box_MaxPool3d;
};

template<> struct ObjectRef_boxTraits<fbs::Mean> {
  static const ObjectRef_box enum_value = ObjectRef_box_Mean;
};

template<> struct ObjectRef_boxTraits<fbs::Min> {
  static const ObjectRef_box enum_value = ObjectRef_box_Min;
};

template<> struct ObjectRef_boxTraits<fbs::Minimum> {
  static const ObjectRef_box enum_value = ObjectRef_box_Minimum;
};

template<> struct ObjectRef_boxTraits<fbs::Mish> {
  static const ObjectRef_box enum_value = ObjectRef_box_Mish;
};

template<> struct ObjectRef_boxTraits<fbs::Multiply> {
  static const ObjectRef_box enum_value = ObjectRef_box_Multiply;
};

template<> struct ObjectRef_boxTraits<fbs::Neg> {
  static const ObjectRef_box enum_value = ObjectRef_box_Neg;
};

template<> struct ObjectRef_boxTraits<fbs::Normalize> {
  static const ObjectRef_box enum_value = ObjectRef_box_Normalize;
};

template<> struct ObjectRef_boxTraits<fbs::Not> {
  static const ObjectRef_box enum_value = ObjectRef_box_Not;
};

template<> struct ObjectRef_boxTraits<fbs::NotEqual> {
  static const ObjectRef_box enum_value = ObjectRef_box_NotEqual;
};

template<> struct ObjectRef_boxTraits<fbs::Pad> {
  static const ObjectRef_box enum_value = ObjectRef_box_Pad;
};

template<> struct ObjectRef_boxTraits<fbs::PixelShuffle> {
  static const ObjectRef_box enum_value = ObjectRef_box_PixelShuffle;
};

template<> struct ObjectRef_boxTraits<fbs::Pow> {
  static const ObjectRef_box enum_value = ObjectRef_box_Pow;
};

template<> struct ObjectRef_boxTraits<fbs::PReLU> {
  static const ObjectRef_box enum_value = ObjectRef_box_PReLU;
};

template<> struct ObjectRef_boxTraits<fbs::PruneAxis> {
  static const ObjectRef_box enum_value = ObjectRef_box_PruneAxis;
};

template<> struct ObjectRef_boxTraits<fbs::ReLU> {
  static const ObjectRef_box enum_value = ObjectRef_box_ReLU;
};

template<> struct ObjectRef_boxTraits<fbs::Reshape> {
  static const ObjectRef_box enum_value = ObjectRef_box_Reshape;
};

template<> struct ObjectRef_boxTraits<fbs::Resize> {
  static const ObjectRef_box enum_value = ObjectRef_box_Resize;
};

template<> struct ObjectRef_boxTraits<fbs::Roll> {
  static const ObjectRef_box enum_value = ObjectRef_box_Roll;
};

template<> struct ObjectRef_boxTraits<fbs::Sigmoid> {
  static const ObjectRef_box enum_value = ObjectRef_box_Sigmoid;
};

template<> struct ObjectRef_boxTraits<fbs::SiLU> {
  static const ObjectRef_box enum_value = ObjectRef_box_SiLU;
};

template<> struct ObjectRef_boxTraits<fbs::Sin> {
  static const ObjectRef_box enum_value = ObjectRef_box_Sin;
};

template<> struct ObjectRef_boxTraits<fbs::Sinh> {
  static const ObjectRef_box enum_value = ObjectRef_box_Sinh;
};

template<> struct ObjectRef_boxTraits<fbs::Slice> {
  static const ObjectRef_box enum_value = ObjectRef_box_Slice;
};

template<> struct ObjectRef_boxTraits<fbs::Softmax> {
  static const ObjectRef_box enum_value = ObjectRef_box_Softmax;
};

template<> struct ObjectRef_boxTraits<fbs::Softplus> {
  static const ObjectRef_box enum_value = ObjectRef_box_Softplus;
};

template<> struct ObjectRef_boxTraits<fbs::Softshrink> {
  static const ObjectRef_box enum_value = ObjectRef_box_Softshrink;
};

template<> struct ObjectRef_boxTraits<fbs::Softsign> {
  static const ObjectRef_box enum_value = ObjectRef_box_Softsign;
};

template<> struct ObjectRef_boxTraits<fbs::Split> {
  static const ObjectRef_box enum_value = ObjectRef_box_Split;
};

template<> struct ObjectRef_boxTraits<fbs::Sqrt> {
  static const ObjectRef_box enum_value = ObjectRef_box_Sqrt;
};

template<> struct ObjectRef_boxTraits<fbs::Squeeze> {
  static const ObjectRef_box enum_value = ObjectRef_box_Squeeze;
};

template<> struct ObjectRef_boxTraits<fbs::Stack> {
  static const ObjectRef_box enum_value = ObjectRef_box_Stack;
};

template<> struct ObjectRef_boxTraits<fbs::Sum> {
  static const ObjectRef_box enum_value = ObjectRef_box_Sum;
};

template<> struct ObjectRef_boxTraits<fbs::SwapOrder> {
  static const ObjectRef_box enum_value = ObjectRef_box_SwapOrder;
};

template<> struct ObjectRef_boxTraits<fbs::Tan> {
  static const ObjectRef_box enum_value = ObjectRef_box_Tan;
};

template<> struct ObjectRef_boxTraits<fbs::Tanh> {
  static const ObjectRef_box enum_value = ObjectRef_box_Tanh;
};

template<> struct ObjectRef_boxTraits<fbs::Tanhshrink> {
  static const ObjectRef_box enum_value = ObjectRef_box_Tanhshrink;
};

template<> struct ObjectRef_boxTraits<fbs::Tile> {
  static const ObjectRef_box enum_value = ObjectRef_box_Tile;
};

template<> struct ObjectRef_boxTraits<fbs::Transpose> {
  static const ObjectRef_box enum_value = ObjectRef_box_Transpose;
};

template<> struct ObjectRef_boxTraits<fbs::Unfold> {
  static const ObjectRef_box enum_value = ObjectRef_box_Unfold;
};

template<> struct ObjectRef_boxTraits<fbs::Unknown> {
  static const ObjectRef_box enum_value = ObjectRef_box_Unknown;
};

template<> struct ObjectRef_boxTraits<fbs::Unstack> {
  static const ObjectRef_box enum_value = ObjectRef_box_Unstack;
};

template<> struct ObjectRef_boxTraits<fbs::Unsupport> {
  static const ObjectRef_box enum_value = ObjectRef_box_Unsupport;
};

template<> struct ObjectRef_boxTraits<fbs::Upsample> {
  static const ObjectRef_box enum_value = ObjectRef_box_Upsample;
};

template<> struct ObjectRef_boxTraits<fbs::Where> {
  static const ObjectRef_box enum_value = ObjectRef_box_Where;
};

template<> struct ObjectRef_boxTraits<fbs::Operation> {
  static const ObjectRef_box enum_value = ObjectRef_box_Operation;
};

template<> struct ObjectRef_boxTraits<fbs::AlignedUnit> {
  static const ObjectRef_box enum_value = ObjectRef_box_AlignedUnit;
};

template<> struct ObjectRef_boxTraits<fbs::ObjectRef> {
  static const ObjectRef_box enum_value = ObjectRef_box_ObjectRef;
};

bool VerifyObjectRef_box(::flatbuffers::Verifier &verifier, const void *obj, ObjectRef_box type);
bool VerifyObjectRef_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Operation_box : uint8_t {
  Operation_box_NONE = 0,
  Operation_box_Input = 1,
  Operation_box_Output = 2,
  Operation_box_Abs = 3,
  Operation_box_ACos = 4,
  Operation_box_ACosh = 5,
  Operation_box_Add = 6,
  Operation_box_AlignAxis = 7,
  Operation_box_Argmax = 8,
  Operation_box_Argmin = 9,
  Operation_box_ASin = 10,
  Operation_box_ASinh = 11,
  Operation_box_ATan = 12,
  Operation_box_ATanh = 13,
  Operation_box_AvgPool1d = 14,
  Operation_box_AvgPool2d = 15,
  Operation_box_AvgPool3d = 16,
  Operation_box_BatchNorm1d = 17,
  Operation_box_BatchNorm2d = 18,
  Operation_box_BatchNorm3d = 19,
  Operation_box_Cast = 20,
  Operation_box_ChannelShuffle = 21,
  Operation_box_ClampScalar = 22,
  Operation_box_Concat = 23,
  Operation_box_Conv1d = 24,
  Operation_box_Conv2d = 25,
  Operation_box_Conv3d = 26,
  Operation_box_ConvTranspose1d = 27,
  Operation_box_ConvTranspose2d = 28,
  Operation_box_ConvTranspose3d = 29,
  Operation_box_Copy = 30,
  Operation_box_Cos = 31,
  Operation_box_Cosh = 32,
  Operation_box_Div = 33,
  Operation_box_DivideScalar = 34,
  Operation_box_Einsum = 35,
  Operation_box_ELU = 36,
  Operation_box_Equal = 37,
  Operation_box_Expand = 38,
  Operation_box_GELU = 39,
  Operation_box_Greater = 40,
  Operation_box_GreaterEqual = 41,
  Operation_box_HardOp = 42,
  Operation_box_Hardshrink = 43,
  Operation_box_Hardsigmoid = 44,
  Operation_box_Hardswish = 45,
  Operation_box_Hardtanh = 46,
  Operation_box_InstanceNorm1d = 47,
  Operation_box_InstanceNorm2d = 48,
  Operation_box_InstanceNorm3d = 49,
  Operation_box_LayerNorm = 50,
  Operation_box_Less = 51,
  Operation_box_LessEqual = 52,
  Operation_box_Log = 53,
  Operation_box_LogSigmoid = 54,
  Operation_box_LogSoftmax = 55,
  Operation_box_Matmul = 56,
  Operation_box_Max = 57,
  Operation_box_Maximum = 58,
  Operation_box_MaxPool1d = 59,
  Operation_box_MaxPool2d = 60,
  Operation_box_MaxPool3d = 61,
  Operation_box_Mean = 62,
  Operation_box_Min = 63,
  Operation_box_Minimum = 64,
  Operation_box_Mish = 65,
  Operation_box_Multiply = 66,
  Operation_box_Neg = 67,
  Operation_box_Normalize = 68,
  Operation_box_Not = 69,
  Operation_box_NotEqual = 70,
  Operation_box_Pad = 71,
  Operation_box_PixelShuffle = 72,
  Operation_box_Pow = 73,
  Operation_box_PReLU = 74,
  Operation_box_PruneAxis = 75,
  Operation_box_ReLU = 76,
  Operation_box_Reshape = 77,
  Operation_box_Resize = 78,
  Operation_box_Roll = 79,
  Operation_box_Sigmoid = 80,
  Operation_box_SiLU = 81,
  Operation_box_Sin = 82,
  Operation_box_Sinh = 83,
  Operation_box_Slice = 84,
  Operation_box_Softmax = 85,
  Operation_box_Softplus = 86,
  Operation_box_Softshrink = 87,
  Operation_box_Softsign = 88,
  Operation_box_Split = 89,
  Operation_box_Sqrt = 90,
  Operation_box_Squeeze = 91,
  Operation_box_Stack = 92,
  Operation_box_Sum = 93,
  Operation_box_SwapOrder = 94,
  Operation_box_Tan = 95,
  Operation_box_Tanh = 96,
  Operation_box_Tanhshrink = 97,
  Operation_box_Tile = 98,
  Operation_box_Transpose = 99,
  Operation_box_Unfold = 100,
  Operation_box_Unknown = 101,
  Operation_box_Unstack = 102,
  Operation_box_Unsupport = 103,
  Operation_box_Upsample = 104,
  Operation_box_Where = 105,
  Operation_box_Operation = 106,
  Operation_box_MIN = Operation_box_NONE,
  Operation_box_MAX = Operation_box_Operation
};

inline const Operation_box (&EnumValuesOperation_box())[107] {
  static const Operation_box values[] = {
    Operation_box_NONE,
    Operation_box_Input,
    Operation_box_Output,
    Operation_box_Abs,
    Operation_box_ACos,
    Operation_box_ACosh,
    Operation_box_Add,
    Operation_box_AlignAxis,
    Operation_box_Argmax,
    Operation_box_Argmin,
    Operation_box_ASin,
    Operation_box_ASinh,
    Operation_box_ATan,
    Operation_box_ATanh,
    Operation_box_AvgPool1d,
    Operation_box_AvgPool2d,
    Operation_box_AvgPool3d,
    Operation_box_BatchNorm1d,
    Operation_box_BatchNorm2d,
    Operation_box_BatchNorm3d,
    Operation_box_Cast,
    Operation_box_ChannelShuffle,
    Operation_box_ClampScalar,
    Operation_box_Concat,
    Operation_box_Conv1d,
    Operation_box_Conv2d,
    Operation_box_Conv3d,
    Operation_box_ConvTranspose1d,
    Operation_box_ConvTranspose2d,
    Operation_box_ConvTranspose3d,
    Operation_box_Copy,
    Operation_box_Cos,
    Operation_box_Cosh,
    Operation_box_Div,
    Operation_box_DivideScalar,
    Operation_box_Einsum,
    Operation_box_ELU,
    Operation_box_Equal,
    Operation_box_Expand,
    Operation_box_GELU,
    Operation_box_Greater,
    Operation_box_GreaterEqual,
    Operation_box_HardOp,
    Operation_box_Hardshrink,
    Operation_box_Hardsigmoid,
    Operation_box_Hardswish,
    Operation_box_Hardtanh,
    Operation_box_InstanceNorm1d,
    Operation_box_InstanceNorm2d,
    Operation_box_InstanceNorm3d,
    Operation_box_LayerNorm,
    Operation_box_Less,
    Operation_box_LessEqual,
    Operation_box_Log,
    Operation_box_LogSigmoid,
    Operation_box_LogSoftmax,
    Operation_box_Matmul,
    Operation_box_Max,
    Operation_box_Maximum,
    Operation_box_MaxPool1d,
    Operation_box_MaxPool2d,
    Operation_box_MaxPool3d,
    Operation_box_Mean,
    Operation_box_Min,
    Operation_box_Minimum,
    Operation_box_Mish,
    Operation_box_Multiply,
    Operation_box_Neg,
    Operation_box_Normalize,
    Operation_box_Not,
    Operation_box_NotEqual,
    Operation_box_Pad,
    Operation_box_PixelShuffle,
    Operation_box_Pow,
    Operation_box_PReLU,
    Operation_box_PruneAxis,
    Operation_box_ReLU,
    Operation_box_Reshape,
    Operation_box_Resize,
    Operation_box_Roll,
    Operation_box_Sigmoid,
    Operation_box_SiLU,
    Operation_box_Sin,
    Operation_box_Sinh,
    Operation_box_Slice,
    Operation_box_Softmax,
    Operation_box_Softplus,
    Operation_box_Softshrink,
    Operation_box_Softsign,
    Operation_box_Split,
    Operation_box_Sqrt,
    Operation_box_Squeeze,
    Operation_box_Stack,
    Operation_box_Sum,
    Operation_box_SwapOrder,
    Operation_box_Tan,
    Operation_box_Tanh,
    Operation_box_Tanhshrink,
    Operation_box_Tile,
    Operation_box_Transpose,
    Operation_box_Unfold,
    Operation_box_Unknown,
    Operation_box_Unstack,
    Operation_box_Unsupport,
    Operation_box_Upsample,
    Operation_box_Where,
    Operation_box_Operation
  };
  return values;
}

inline const char * const *EnumNamesOperation_box() {
  static const char * const names[108] = {
    "NONE",
    "Input",
    "Output",
    "Abs",
    "ACos",
    "ACosh",
    "Add",
    "AlignAxis",
    "Argmax",
    "Argmin",
    "ASin",
    "ASinh",
    "ATan",
    "ATanh",
    "AvgPool1d",
    "AvgPool2d",
    "AvgPool3d",
    "BatchNorm1d",
    "BatchNorm2d",
    "BatchNorm3d",
    "Cast",
    "ChannelShuffle",
    "ClampScalar",
    "Concat",
    "Conv1d",
    "Conv2d",
    "Conv3d",
    "ConvTranspose1d",
    "ConvTranspose2d",
    "ConvTranspose3d",
    "Copy",
    "Cos",
    "Cosh",
    "Div",
    "DivideScalar",
    "Einsum",
    "ELU",
    "Equal",
    "Expand",
    "GELU",
    "Greater",
    "GreaterEqual",
    "HardOp",
    "Hardshrink",
    "Hardsigmoid",
    "Hardswish",
    "Hardtanh",
    "InstanceNorm1d",
    "InstanceNorm2d",
    "InstanceNorm3d",
    "LayerNorm",
    "Less",
    "LessEqual",
    "Log",
    "LogSigmoid",
    "LogSoftmax",
    "Matmul",
    "Max",
    "Maximum",
    "MaxPool1d",
    "MaxPool2d",
    "MaxPool3d",
    "Mean",
    "Min",
    "Minimum",
    "Mish",
    "Multiply",
    "Neg",
    "Normalize",
    "Not",
    "NotEqual",
    "Pad",
    "PixelShuffle",
    "Pow",
    "PReLU",
    "PruneAxis",
    "ReLU",
    "Reshape",
    "Resize",
    "Roll",
    "Sigmoid",
    "SiLU",
    "Sin",
    "Sinh",
    "Slice",
    "Softmax",
    "Softplus",
    "Softshrink",
    "Softsign",
    "Split",
    "Sqrt",
    "Squeeze",
    "Stack",
    "Sum",
    "SwapOrder",
    "Tan",
    "Tanh",
    "Tanhshrink",
    "Tile",
    "Transpose",
    "Unfold",
    "Unknown",
    "Unstack",
    "Unsupport",
    "Upsample",
    "Where",
    "Operation",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperation_box(Operation_box e) {
  if (::flatbuffers::IsOutRange(e, Operation_box_NONE, Operation_box_Operation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperation_box()[index];
}

template<typename T> struct Operation_boxTraits {
  static const Operation_box enum_value = Operation_box_NONE;
};

template<> struct Operation_boxTraits<fbs::Input> {
  static const Operation_box enum_value = Operation_box_Input;
};

template<> struct Operation_boxTraits<fbs::Output> {
  static const Operation_box enum_value = Operation_box_Output;
};

template<> struct Operation_boxTraits<fbs::Abs> {
  static const Operation_box enum_value = Operation_box_Abs;
};

template<> struct Operation_boxTraits<fbs::ACos> {
  static const Operation_box enum_value = Operation_box_ACos;
};

template<> struct Operation_boxTraits<fbs::ACosh> {
  static const Operation_box enum_value = Operation_box_ACosh;
};

template<> struct Operation_boxTraits<fbs::Add> {
  static const Operation_box enum_value = Operation_box_Add;
};

template<> struct Operation_boxTraits<fbs::AlignAxis> {
  static const Operation_box enum_value = Operation_box_AlignAxis;
};

template<> struct Operation_boxTraits<fbs::Argmax> {
  static const Operation_box enum_value = Operation_box_Argmax;
};

template<> struct Operation_boxTraits<fbs::Argmin> {
  static const Operation_box enum_value = Operation_box_Argmin;
};

template<> struct Operation_boxTraits<fbs::ASin> {
  static const Operation_box enum_value = Operation_box_ASin;
};

template<> struct Operation_boxTraits<fbs::ASinh> {
  static const Operation_box enum_value = Operation_box_ASinh;
};

template<> struct Operation_boxTraits<fbs::ATan> {
  static const Operation_box enum_value = Operation_box_ATan;
};

template<> struct Operation_boxTraits<fbs::ATanh> {
  static const Operation_box enum_value = Operation_box_ATanh;
};

template<> struct Operation_boxTraits<fbs::AvgPool1d> {
  static const Operation_box enum_value = Operation_box_AvgPool1d;
};

template<> struct Operation_boxTraits<fbs::AvgPool2d> {
  static const Operation_box enum_value = Operation_box_AvgPool2d;
};

template<> struct Operation_boxTraits<fbs::AvgPool3d> {
  static const Operation_box enum_value = Operation_box_AvgPool3d;
};

template<> struct Operation_boxTraits<fbs::BatchNorm1d> {
  static const Operation_box enum_value = Operation_box_BatchNorm1d;
};

template<> struct Operation_boxTraits<fbs::BatchNorm2d> {
  static const Operation_box enum_value = Operation_box_BatchNorm2d;
};

template<> struct Operation_boxTraits<fbs::BatchNorm3d> {
  static const Operation_box enum_value = Operation_box_BatchNorm3d;
};

template<> struct Operation_boxTraits<fbs::Cast> {
  static const Operation_box enum_value = Operation_box_Cast;
};

template<> struct Operation_boxTraits<fbs::ChannelShuffle> {
  static const Operation_box enum_value = Operation_box_ChannelShuffle;
};

template<> struct Operation_boxTraits<fbs::ClampScalar> {
  static const Operation_box enum_value = Operation_box_ClampScalar;
};

template<> struct Operation_boxTraits<fbs::Concat> {
  static const Operation_box enum_value = Operation_box_Concat;
};

template<> struct Operation_boxTraits<fbs::Conv1d> {
  static const Operation_box enum_value = Operation_box_Conv1d;
};

template<> struct Operation_boxTraits<fbs::Conv2d> {
  static const Operation_box enum_value = Operation_box_Conv2d;
};

template<> struct Operation_boxTraits<fbs::Conv3d> {
  static const Operation_box enum_value = Operation_box_Conv3d;
};

template<> struct Operation_boxTraits<fbs::ConvTranspose1d> {
  static const Operation_box enum_value = Operation_box_ConvTranspose1d;
};

template<> struct Operation_boxTraits<fbs::ConvTranspose2d> {
  static const Operation_box enum_value = Operation_box_ConvTranspose2d;
};

template<> struct Operation_boxTraits<fbs::ConvTranspose3d> {
  static const Operation_box enum_value = Operation_box_ConvTranspose3d;
};

template<> struct Operation_boxTraits<fbs::Copy> {
  static const Operation_box enum_value = Operation_box_Copy;
};

template<> struct Operation_boxTraits<fbs::Cos> {
  static const Operation_box enum_value = Operation_box_Cos;
};

template<> struct Operation_boxTraits<fbs::Cosh> {
  static const Operation_box enum_value = Operation_box_Cosh;
};

template<> struct Operation_boxTraits<fbs::Div> {
  static const Operation_box enum_value = Operation_box_Div;
};

template<> struct Operation_boxTraits<fbs::DivideScalar> {
  static const Operation_box enum_value = Operation_box_DivideScalar;
};

template<> struct Operation_boxTraits<fbs::Einsum> {
  static const Operation_box enum_value = Operation_box_Einsum;
};

template<> struct Operation_boxTraits<fbs::ELU> {
  static const Operation_box enum_value = Operation_box_ELU;
};

template<> struct Operation_boxTraits<fbs::Equal> {
  static const Operation_box enum_value = Operation_box_Equal;
};

template<> struct Operation_boxTraits<fbs::Expand> {
  static const Operation_box enum_value = Operation_box_Expand;
};

template<> struct Operation_boxTraits<fbs::GELU> {
  static const Operation_box enum_value = Operation_box_GELU;
};

template<> struct Operation_boxTraits<fbs::Greater> {
  static const Operation_box enum_value = Operation_box_Greater;
};

template<> struct Operation_boxTraits<fbs::GreaterEqual> {
  static const Operation_box enum_value = Operation_box_GreaterEqual;
};

template<> struct Operation_boxTraits<fbs::HardOp> {
  static const Operation_box enum_value = Operation_box_HardOp;
};

template<> struct Operation_boxTraits<fbs::Hardshrink> {
  static const Operation_box enum_value = Operation_box_Hardshrink;
};

template<> struct Operation_boxTraits<fbs::Hardsigmoid> {
  static const Operation_box enum_value = Operation_box_Hardsigmoid;
};

template<> struct Operation_boxTraits<fbs::Hardswish> {
  static const Operation_box enum_value = Operation_box_Hardswish;
};

template<> struct Operation_boxTraits<fbs::Hardtanh> {
  static const Operation_box enum_value = Operation_box_Hardtanh;
};

template<> struct Operation_boxTraits<fbs::InstanceNorm1d> {
  static const Operation_box enum_value = Operation_box_InstanceNorm1d;
};

template<> struct Operation_boxTraits<fbs::InstanceNorm2d> {
  static const Operation_box enum_value = Operation_box_InstanceNorm2d;
};

template<> struct Operation_boxTraits<fbs::InstanceNorm3d> {
  static const Operation_box enum_value = Operation_box_InstanceNorm3d;
};

template<> struct Operation_boxTraits<fbs::LayerNorm> {
  static const Operation_box enum_value = Operation_box_LayerNorm;
};

template<> struct Operation_boxTraits<fbs::Less> {
  static const Operation_box enum_value = Operation_box_Less;
};

template<> struct Operation_boxTraits<fbs::LessEqual> {
  static const Operation_box enum_value = Operation_box_LessEqual;
};

template<> struct Operation_boxTraits<fbs::Log> {
  static const Operation_box enum_value = Operation_box_Log;
};

template<> struct Operation_boxTraits<fbs::LogSigmoid> {
  static const Operation_box enum_value = Operation_box_LogSigmoid;
};

template<> struct Operation_boxTraits<fbs::LogSoftmax> {
  static const Operation_box enum_value = Operation_box_LogSoftmax;
};

template<> struct Operation_boxTraits<fbs::Matmul> {
  static const Operation_box enum_value = Operation_box_Matmul;
};

template<> struct Operation_boxTraits<fbs::Max> {
  static const Operation_box enum_value = Operation_box_Max;
};

template<> struct Operation_boxTraits<fbs::Maximum> {
  static const Operation_box enum_value = Operation_box_Maximum;
};

template<> struct Operation_boxTraits<fbs::MaxPool1d> {
  static const Operation_box enum_value = Operation_box_MaxPool1d;
};

template<> struct Operation_boxTraits<fbs::MaxPool2d> {
  static const Operation_box enum_value = Operation_box_MaxPool2d;
};

template<> struct Operation_boxTraits<fbs::MaxPool3d> {
  static const Operation_box enum_value = Operation_box_MaxPool3d;
};

template<> struct Operation_boxTraits<fbs::Mean> {
  static const Operation_box enum_value = Operation_box_Mean;
};

template<> struct Operation_boxTraits<fbs::Min> {
  static const Operation_box enum_value = Operation_box_Min;
};

template<> struct Operation_boxTraits<fbs::Minimum> {
  static const Operation_box enum_value = Operation_box_Minimum;
};

template<> struct Operation_boxTraits<fbs::Mish> {
  static const Operation_box enum_value = Operation_box_Mish;
};

template<> struct Operation_boxTraits<fbs::Multiply> {
  static const Operation_box enum_value = Operation_box_Multiply;
};

template<> struct Operation_boxTraits<fbs::Neg> {
  static const Operation_box enum_value = Operation_box_Neg;
};

template<> struct Operation_boxTraits<fbs::Normalize> {
  static const Operation_box enum_value = Operation_box_Normalize;
};

template<> struct Operation_boxTraits<fbs::Not> {
  static const Operation_box enum_value = Operation_box_Not;
};

template<> struct Operation_boxTraits<fbs::NotEqual> {
  static const Operation_box enum_value = Operation_box_NotEqual;
};

template<> struct Operation_boxTraits<fbs::Pad> {
  static const Operation_box enum_value = Operation_box_Pad;
};

template<> struct Operation_boxTraits<fbs::PixelShuffle> {
  static const Operation_box enum_value = Operation_box_PixelShuffle;
};

template<> struct Operation_boxTraits<fbs::Pow> {
  static const Operation_box enum_value = Operation_box_Pow;
};

template<> struct Operation_boxTraits<fbs::PReLU> {
  static const Operation_box enum_value = Operation_box_PReLU;
};

template<> struct Operation_boxTraits<fbs::PruneAxis> {
  static const Operation_box enum_value = Operation_box_PruneAxis;
};

template<> struct Operation_boxTraits<fbs::ReLU> {
  static const Operation_box enum_value = Operation_box_ReLU;
};

template<> struct Operation_boxTraits<fbs::Reshape> {
  static const Operation_box enum_value = Operation_box_Reshape;
};

template<> struct Operation_boxTraits<fbs::Resize> {
  static const Operation_box enum_value = Operation_box_Resize;
};

template<> struct Operation_boxTraits<fbs::Roll> {
  static const Operation_box enum_value = Operation_box_Roll;
};

template<> struct Operation_boxTraits<fbs::Sigmoid> {
  static const Operation_box enum_value = Operation_box_Sigmoid;
};

template<> struct Operation_boxTraits<fbs::SiLU> {
  static const Operation_box enum_value = Operation_box_SiLU;
};

template<> struct Operation_boxTraits<fbs::Sin> {
  static const Operation_box enum_value = Operation_box_Sin;
};

template<> struct Operation_boxTraits<fbs::Sinh> {
  static const Operation_box enum_value = Operation_box_Sinh;
};

template<> struct Operation_boxTraits<fbs::Slice> {
  static const Operation_box enum_value = Operation_box_Slice;
};

template<> struct Operation_boxTraits<fbs::Softmax> {
  static const Operation_box enum_value = Operation_box_Softmax;
};

template<> struct Operation_boxTraits<fbs::Softplus> {
  static const Operation_box enum_value = Operation_box_Softplus;
};

template<> struct Operation_boxTraits<fbs::Softshrink> {
  static const Operation_box enum_value = Operation_box_Softshrink;
};

template<> struct Operation_boxTraits<fbs::Softsign> {
  static const Operation_box enum_value = Operation_box_Softsign;
};

template<> struct Operation_boxTraits<fbs::Split> {
  static const Operation_box enum_value = Operation_box_Split;
};

template<> struct Operation_boxTraits<fbs::Sqrt> {
  static const Operation_box enum_value = Operation_box_Sqrt;
};

template<> struct Operation_boxTraits<fbs::Squeeze> {
  static const Operation_box enum_value = Operation_box_Squeeze;
};

template<> struct Operation_boxTraits<fbs::Stack> {
  static const Operation_box enum_value = Operation_box_Stack;
};

template<> struct Operation_boxTraits<fbs::Sum> {
  static const Operation_box enum_value = Operation_box_Sum;
};

template<> struct Operation_boxTraits<fbs::SwapOrder> {
  static const Operation_box enum_value = Operation_box_SwapOrder;
};

template<> struct Operation_boxTraits<fbs::Tan> {
  static const Operation_box enum_value = Operation_box_Tan;
};

template<> struct Operation_boxTraits<fbs::Tanh> {
  static const Operation_box enum_value = Operation_box_Tanh;
};

template<> struct Operation_boxTraits<fbs::Tanhshrink> {
  static const Operation_box enum_value = Operation_box_Tanhshrink;
};

template<> struct Operation_boxTraits<fbs::Tile> {
  static const Operation_box enum_value = Operation_box_Tile;
};

template<> struct Operation_boxTraits<fbs::Transpose> {
  static const Operation_box enum_value = Operation_box_Transpose;
};

template<> struct Operation_boxTraits<fbs::Unfold> {
  static const Operation_box enum_value = Operation_box_Unfold;
};

template<> struct Operation_boxTraits<fbs::Unknown> {
  static const Operation_box enum_value = Operation_box_Unknown;
};

template<> struct Operation_boxTraits<fbs::Unstack> {
  static const Operation_box enum_value = Operation_box_Unstack;
};

template<> struct Operation_boxTraits<fbs::Unsupport> {
  static const Operation_box enum_value = Operation_box_Unsupport;
};

template<> struct Operation_boxTraits<fbs::Upsample> {
  static const Operation_box enum_value = Operation_box_Upsample;
};

template<> struct Operation_boxTraits<fbs::Where> {
  static const Operation_box enum_value = Operation_box_Where;
};

template<> struct Operation_boxTraits<fbs::Operation> {
  static const Operation_box enum_value = Operation_box_Operation;
};

bool VerifyOperation_box(::flatbuffers::Verifier &verifier, const void *obj, Operation_box type);
bool VerifyOperation_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum QuantizedScale_box : uint8_t {
  QuantizedScale_box_NONE = 0,
  QuantizedScale_box_ExpQuantizedScale = 1,
  QuantizedScale_box_QuantizedScale = 2,
  QuantizedScale_box_MIN = QuantizedScale_box_NONE,
  QuantizedScale_box_MAX = QuantizedScale_box_QuantizedScale
};

inline const QuantizedScale_box (&EnumValuesQuantizedScale_box())[3] {
  static const QuantizedScale_box values[] = {
    QuantizedScale_box_NONE,
    QuantizedScale_box_ExpQuantizedScale,
    QuantizedScale_box_QuantizedScale
  };
  return values;
}

inline const char * const *EnumNamesQuantizedScale_box() {
  static const char * const names[4] = {
    "NONE",
    "ExpQuantizedScale",
    "QuantizedScale",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizedScale_box(QuantizedScale_box e) {
  if (::flatbuffers::IsOutRange(e, QuantizedScale_box_NONE, QuantizedScale_box_QuantizedScale)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizedScale_box()[index];
}

template<typename T> struct QuantizedScale_boxTraits {
  static const QuantizedScale_box enum_value = QuantizedScale_box_NONE;
};

template<> struct QuantizedScale_boxTraits<fbs::ExpQuantizedScale> {
  static const QuantizedScale_box enum_value = QuantizedScale_box_ExpQuantizedScale;
};

template<> struct QuantizedScale_boxTraits<fbs::QuantizedScale> {
  static const QuantizedScale_box enum_value = QuantizedScale_box_QuantizedScale;
};

bool VerifyQuantizedScale_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedScale_box type);
bool VerifyQuantizedScale_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum QuantizedScaleArray_box : uint8_t {
  QuantizedScaleArray_box_NONE = 0,
  QuantizedScaleArray_box_ExpQuantizedScaleArray = 1,
  QuantizedScaleArray_box_QuantizedScaleArray = 2,
  QuantizedScaleArray_box_MIN = QuantizedScaleArray_box_NONE,
  QuantizedScaleArray_box_MAX = QuantizedScaleArray_box_QuantizedScaleArray
};

inline const QuantizedScaleArray_box (&EnumValuesQuantizedScaleArray_box())[3] {
  static const QuantizedScaleArray_box values[] = {
    QuantizedScaleArray_box_NONE,
    QuantizedScaleArray_box_ExpQuantizedScaleArray,
    QuantizedScaleArray_box_QuantizedScaleArray
  };
  return values;
}

inline const char * const *EnumNamesQuantizedScaleArray_box() {
  static const char * const names[4] = {
    "NONE",
    "ExpQuantizedScaleArray",
    "QuantizedScaleArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizedScaleArray_box(QuantizedScaleArray_box e) {
  if (::flatbuffers::IsOutRange(e, QuantizedScaleArray_box_NONE, QuantizedScaleArray_box_QuantizedScaleArray)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizedScaleArray_box()[index];
}

template<typename T> struct QuantizedScaleArray_boxTraits {
  static const QuantizedScaleArray_box enum_value = QuantizedScaleArray_box_NONE;
};

template<> struct QuantizedScaleArray_boxTraits<fbs::ExpQuantizedScaleArray> {
  static const QuantizedScaleArray_box enum_value = QuantizedScaleArray_box_ExpQuantizedScaleArray;
};

template<> struct QuantizedScaleArray_boxTraits<fbs::QuantizedScaleArray> {
  static const QuantizedScaleArray_box enum_value = QuantizedScaleArray_box_QuantizedScaleArray;
};

bool VerifyQuantizedScaleArray_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedScaleArray_box type);
bool VerifyQuantizedScaleArray_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum QuantizedType_box : uint8_t {
  QuantizedType_box_NONE = 0,
  QuantizedType_box_NormalizedQuantizedType = 1,
  QuantizedType_box_QuantizedType = 2,
  QuantizedType_box_MIN = QuantizedType_box_NONE,
  QuantizedType_box_MAX = QuantizedType_box_QuantizedType
};

inline const QuantizedType_box (&EnumValuesQuantizedType_box())[3] {
  static const QuantizedType_box values[] = {
    QuantizedType_box_NONE,
    QuantizedType_box_NormalizedQuantizedType,
    QuantizedType_box_QuantizedType
  };
  return values;
}

inline const char * const *EnumNamesQuantizedType_box() {
  static const char * const names[4] = {
    "NONE",
    "NormalizedQuantizedType",
    "QuantizedType",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizedType_box(QuantizedType_box e) {
  if (::flatbuffers::IsOutRange(e, QuantizedType_box_NONE, QuantizedType_box_QuantizedType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizedType_box()[index];
}

template<typename T> struct QuantizedType_boxTraits {
  static const QuantizedType_box enum_value = QuantizedType_box_NONE;
};

template<> struct QuantizedType_boxTraits<fbs::NormalizedQuantizedType> {
  static const QuantizedType_box enum_value = QuantizedType_box_NormalizedQuantizedType;
};

template<> struct QuantizedType_boxTraits<fbs::QuantizedType> {
  static const QuantizedType_box enum_value = QuantizedType_box_QuantizedType;
};

bool VerifyQuantizedType_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedType_box type);
bool VerifyQuantizedType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ScalarImm_box : uint8_t {
  ScalarImm_box_NONE = 0,
  ScalarImm_box_Bool = 1,
  ScalarImm_box_IntImm = 2,
  ScalarImm_box_FloatImm = 3,
  ScalarImm_box_ScalarImm = 4,
  ScalarImm_box_MIN = ScalarImm_box_NONE,
  ScalarImm_box_MAX = ScalarImm_box_ScalarImm
};

inline const ScalarImm_box (&EnumValuesScalarImm_box())[5] {
  static const ScalarImm_box values[] = {
    ScalarImm_box_NONE,
    ScalarImm_box_Bool,
    ScalarImm_box_IntImm,
    ScalarImm_box_FloatImm,
    ScalarImm_box_ScalarImm
  };
  return values;
}

inline const char * const *EnumNamesScalarImm_box() {
  static const char * const names[6] = {
    "NONE",
    "Bool",
    "IntImm",
    "FloatImm",
    "ScalarImm",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarImm_box(ScalarImm_box e) {
  if (::flatbuffers::IsOutRange(e, ScalarImm_box_NONE, ScalarImm_box_ScalarImm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarImm_box()[index];
}

template<typename T> struct ScalarImm_boxTraits {
  static const ScalarImm_box enum_value = ScalarImm_box_NONE;
};

template<> struct ScalarImm_boxTraits<fbs::Bool> {
  static const ScalarImm_box enum_value = ScalarImm_box_Bool;
};

template<> struct ScalarImm_boxTraits<fbs::IntImm> {
  static const ScalarImm_box enum_value = ScalarImm_box_IntImm;
};

template<> struct ScalarImm_boxTraits<fbs::FloatImm> {
  static const ScalarImm_box enum_value = ScalarImm_box_FloatImm;
};

template<> struct ScalarImm_boxTraits<fbs::ScalarImm> {
  static const ScalarImm_box enum_value = ScalarImm_box_ScalarImm;
};

bool VerifyScalarImm_box(::flatbuffers::Verifier &verifier, const void *obj, ScalarImm_box type);
bool VerifyScalarImm_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ScalarType_box : uint8_t {
  ScalarType_box_NONE = 0,
  ScalarType_box_BoolType = 1,
  ScalarType_box_IntegerType = 2,
  ScalarType_box_FloatType = 3,
  ScalarType_box_CalibratedType = 4,
  ScalarType_box_NormalizedType = 5,
  ScalarType_box_NormalizedQuantizedType = 6,
  ScalarType_box_QuantizedType = 7,
  ScalarType_box_BaseQuantizedType = 8,
  ScalarType_box_ScalarType = 9,
  ScalarType_box_MIN = ScalarType_box_NONE,
  ScalarType_box_MAX = ScalarType_box_ScalarType
};

inline const ScalarType_box (&EnumValuesScalarType_box())[10] {
  static const ScalarType_box values[] = {
    ScalarType_box_NONE,
    ScalarType_box_BoolType,
    ScalarType_box_IntegerType,
    ScalarType_box_FloatType,
    ScalarType_box_CalibratedType,
    ScalarType_box_NormalizedType,
    ScalarType_box_NormalizedQuantizedType,
    ScalarType_box_QuantizedType,
    ScalarType_box_BaseQuantizedType,
    ScalarType_box_ScalarType
  };
  return values;
}

inline const char * const *EnumNamesScalarType_box() {
  static const char * const names[11] = {
    "NONE",
    "BoolType",
    "IntegerType",
    "FloatType",
    "CalibratedType",
    "NormalizedType",
    "NormalizedQuantizedType",
    "QuantizedType",
    "BaseQuantizedType",
    "ScalarType",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarType_box(ScalarType_box e) {
  if (::flatbuffers::IsOutRange(e, ScalarType_box_NONE, ScalarType_box_ScalarType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarType_box()[index];
}

template<typename T> struct ScalarType_boxTraits {
  static const ScalarType_box enum_value = ScalarType_box_NONE;
};

template<> struct ScalarType_boxTraits<fbs::BoolType> {
  static const ScalarType_box enum_value = ScalarType_box_BoolType;
};

template<> struct ScalarType_boxTraits<fbs::IntegerType> {
  static const ScalarType_box enum_value = ScalarType_box_IntegerType;
};

template<> struct ScalarType_boxTraits<fbs::FloatType> {
  static const ScalarType_box enum_value = ScalarType_box_FloatType;
};

template<> struct ScalarType_boxTraits<fbs::CalibratedType> {
  static const ScalarType_box enum_value = ScalarType_box_CalibratedType;
};

template<> struct ScalarType_boxTraits<fbs::NormalizedType> {
  static const ScalarType_box enum_value = ScalarType_box_NormalizedType;
};

template<> struct ScalarType_boxTraits<fbs::NormalizedQuantizedType> {
  static const ScalarType_box enum_value = ScalarType_box_NormalizedQuantizedType;
};

template<> struct ScalarType_boxTraits<fbs::QuantizedType> {
  static const ScalarType_box enum_value = ScalarType_box_QuantizedType;
};

template<> struct ScalarType_boxTraits<fbs::BaseQuantizedType> {
  static const ScalarType_box enum_value = ScalarType_box_BaseQuantizedType;
};

template<> struct ScalarType_boxTraits<fbs::ScalarType> {
  static const ScalarType_box enum_value = ScalarType_box_ScalarType;
};

bool VerifyScalarType_box(::flatbuffers::Verifier &verifier, const void *obj, ScalarType_box type);
bool VerifyScalarType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Value_box : uint8_t {
  Value_box_NONE = 0,
  Value_box_Params = 1,
  Value_box_Value = 2,
  Value_box_MIN = Value_box_NONE,
  Value_box_MAX = Value_box_Value
};

inline const Value_box (&EnumValuesValue_box())[3] {
  static const Value_box values[] = {
    Value_box_NONE,
    Value_box_Params,
    Value_box_Value
  };
  return values;
}

inline const char * const *EnumNamesValue_box() {
  static const char * const names[4] = {
    "NONE",
    "Params",
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue_box(Value_box e) {
  if (::flatbuffers::IsOutRange(e, Value_box_NONE, Value_box_Value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue_box()[index];
}

template<typename T> struct Value_boxTraits {
  static const Value_box enum_value = Value_box_NONE;
};

template<> struct Value_boxTraits<fbs::Params> {
  static const Value_box enum_value = Value_box_Params;
};

template<> struct Value_boxTraits<fbs::Value> {
  static const Value_box enum_value = Value_box_Value;
};

bool VerifyValue_box(::flatbuffers::Verifier &verifier, const void *obj, Value_box type);
bool VerifyValue_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct ACos FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ACosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ACos::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ACos::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ACos::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ACos::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ACos::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ACos::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ACos::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ACosBuilder {
  typedef ACos Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ACos::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ACos::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ACos::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ACos::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ACos::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ACos::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ACos::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ACos::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ACos::VT_TAGS, tags);
  }
  explicit ACosBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ACos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ACos>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ACos> CreateACos(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ACosBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ACos> CreateACosDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateACos(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ACosh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ACoshBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ACosh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ACosh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ACosh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ACosh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ACosh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ACosh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ACosh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ACoshBuilder {
  typedef ACosh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ACosh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ACosh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ACosh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ACosh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ACosh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ACosh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ACosh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ACosh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ACosh::VT_TAGS, tags);
  }
  explicit ACoshBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ACosh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ACosh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ACosh> CreateACosh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ACoshBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ACosh> CreateACoshDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateACosh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ASin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ASinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ASin::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ASin::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ASin::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ASin::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ASin::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ASin::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ASin::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ASinBuilder {
  typedef ASin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ASin::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ASin::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ASin::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ASin::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ASin::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ASin::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ASin::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ASin::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ASin::VT_TAGS, tags);
  }
  explicit ASinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ASin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ASin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ASin> CreateASin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ASinBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ASin> CreateASinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateASin(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ASinh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ASinhBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ASinh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ASinh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ASinh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ASinh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ASinh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ASinh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ASinh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ASinhBuilder {
  typedef ASinh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ASinh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ASinh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ASinh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ASinh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ASinh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ASinh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ASinh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ASinh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ASinh::VT_TAGS, tags);
  }
  explicit ASinhBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ASinh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ASinh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ASinh> CreateASinh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ASinhBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ASinh> CreateASinhDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateASinh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ATan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ATanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ATan::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ATan::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ATan::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ATan::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ATan::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ATan::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ATan::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ATanBuilder {
  typedef ATan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ATan::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ATan::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ATan::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ATan::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ATan::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ATan::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ATan::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ATan::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ATan::VT_TAGS, tags);
  }
  explicit ATanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATan> CreateATan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ATanBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ATan> CreateATanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateATan(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ATanh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ATanhBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ATanh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ATanh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ATanh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ATanh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ATanh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ATanh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ATanh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ATanhBuilder {
  typedef ATanh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ATanh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ATanh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ATanh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ATanh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ATanh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ATanh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ATanh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ATanh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ATanh::VT_TAGS, tags);
  }
  explicit ATanhBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATanh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATanh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATanh> CreateATanh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ATanhBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ATanh> CreateATanhDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateATanh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Abs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AbsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Abs::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Abs::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Abs::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Abs::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Abs::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Abs::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Abs::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AbsBuilder {
  typedef Abs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Abs::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Abs::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Abs::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Abs::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Abs::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Abs::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Abs::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Abs::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Abs::VT_TAGS, tags);
  }
  explicit AbsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Abs> CreateAbs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AbsBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Abs> CreateAbsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAbs(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Add FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA_TYPE = 4,
    VT_ALPHA = 6,
    VT_BETA_TYPE = 8,
    VT_BETA = 10,
    VT_CUT_SCALE_TYPE = 12,
    VT_CUT_SCALE = 14,
    VT_OP_ID = 16,
    VT_NAME = 18,
    VT_INPUTS_TYPE = 20,
    VT_INPUTS = 22,
    VT_OUTPUTS_TYPE = 24,
    VT_OUTPUTS = 26,
    VT_COMPILE_TARGET_TYPE = 28,
    VT_COMPILE_TARGET = 30,
    VT_TAGS = 32
  };
  const ::flatbuffers::Vector<uint8_t> *alpha_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ALPHA_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *alpha() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_ALPHA);
  }
  const ::flatbuffers::Vector<uint8_t> *beta_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BETA_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *beta() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_BETA);
  }
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALPHA_TYPE) &&
           verifier.VerifyVector(alpha_type()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyVector(alpha()) &&
           VerifyScalarImm_boxVector(verifier, alpha(), alpha_type()) &&
           VerifyOffset(verifier, VT_BETA_TYPE) &&
           verifier.VerifyVector(beta_type()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyVector(beta()) &&
           VerifyScalarImm_boxVector(verifier, beta(), beta_type()) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Add::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Add::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Add::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Add::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Add::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Add::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Add::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Add::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Add::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AddBuilder {
  typedef Add Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> alpha_type) {
    fbb_.AddOffset(Add::VT_ALPHA_TYPE, alpha_type);
  }
  void add_alpha(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> alpha) {
    fbb_.AddOffset(Add::VT_ALPHA, alpha);
  }
  void add_beta_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> beta_type) {
    fbb_.AddOffset(Add::VT_BETA_TYPE, beta_type);
  }
  void add_beta(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> beta) {
    fbb_.AddOffset(Add::VT_BETA, beta);
  }
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Add::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Add::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Add::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Add::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Add::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Add::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Add::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Add::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Add::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Add::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Add::VT_TAGS, tags);
  }
  explicit AddBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Add> CreateAdd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> alpha_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> alpha = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> beta_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> beta = 0,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_beta(beta);
  builder_.add_beta_type(beta_type);
  builder_.add_alpha(alpha);
  builder_.add_alpha_type(alpha_type);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Add> CreateAddDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *alpha_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *alpha = nullptr,
    const std::vector<uint8_t> *beta_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *beta = nullptr,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto alpha_type__ = alpha_type ? _fbb.CreateVector<uint8_t>(*alpha_type) : 0;
  auto alpha__ = alpha ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*alpha) : 0;
  auto beta_type__ = beta_type ? _fbb.CreateVector<uint8_t>(*beta_type) : 0;
  auto beta__ = beta ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*beta) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAdd(
      _fbb,
      alpha_type__,
      alpha__,
      beta_type__,
      beta__,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AlignAxis FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlignAxisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGNED_UNITS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::AlignedUnit>> *aligned_units() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::AlignedUnit>> *>(VT_ALIGNED_UNITS);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALIGNED_UNITS) &&
           verifier.VerifyVector(aligned_units()) &&
           verifier.VerifyVectorOfTables(aligned_units()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *AlignAxis::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *AlignAxis::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *AlignAxis::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *AlignAxis::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *AlignAxis::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *AlignAxis::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *AlignAxis::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AlignAxisBuilder {
  typedef AlignAxis Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_aligned_units(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::AlignedUnit>>> aligned_units) {
    fbb_.AddOffset(AlignAxis::VT_ALIGNED_UNITS, aligned_units);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(AlignAxis::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AlignAxis::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(AlignAxis::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(AlignAxis::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(AlignAxis::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(AlignAxis::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(AlignAxis::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(AlignAxis::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(AlignAxis::VT_TAGS, tags);
  }
  explicit AlignAxisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlignAxis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlignAxis>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlignAxis> CreateAlignAxis(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::AlignedUnit>>> aligned_units = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AlignAxisBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_aligned_units(aligned_units);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlignAxis> CreateAlignAxisDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fbs::AlignedUnit>> *aligned_units = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto aligned_units__ = aligned_units ? _fbb.CreateVector<::flatbuffers::Offset<fbs::AlignedUnit>>(*aligned_units) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAlignAxis(
      _fbb,
      aligned_units__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AlignedUnit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlignedUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_UNIT = 6
  };
  const ::flatbuffers::Vector<int64_t> *index() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INDEX);
  }
  const ::flatbuffers::Vector<int64_t> *unit() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_UNIT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyVector(unit()) &&
           verifier.EndTable();
  }
};

struct AlignedUnitBuilder {
  typedef AlignedUnit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> index) {
    fbb_.AddOffset(AlignedUnit::VT_INDEX, index);
  }
  void add_unit(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> unit) {
    fbb_.AddOffset(AlignedUnit::VT_UNIT, unit);
  }
  explicit AlignedUnitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlignedUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlignedUnit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlignedUnit> CreateAlignedUnit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> unit = 0) {
  AlignedUnitBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_index(index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlignedUnit> CreateAlignedUnitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *index = nullptr,
    const std::vector<int64_t> *unit = nullptr) {
  auto index__ = index ? _fbb.CreateVector<int64_t>(*index) : 0;
  auto unit__ = unit ? _fbb.CreateVector<int64_t>(*unit) : 0;
  return fbs::CreateAlignedUnit(
      _fbb,
      index__,
      unit__);
}

struct Argmax FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgmaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::IntImm *dim() const {
    return GetPointer<const fbs::IntImm *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyTable(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Argmax::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Argmax::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Argmax::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Argmax::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Argmax::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Argmax::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Argmax::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ArgmaxBuilder {
  typedef Argmax Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<fbs::IntImm> dim) {
    fbb_.AddOffset(Argmax::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Argmax::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Argmax::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Argmax::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Argmax::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Argmax::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Argmax::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Argmax::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Argmax::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Argmax::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Argmax::VT_TAGS, tags);
  }
  explicit ArgmaxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Argmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Argmax>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Argmax> CreateArgmax(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ArgmaxBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Argmax> CreateArgmaxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateArgmax(
      _fbb,
      dim,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Argmin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgminBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::IntImm *dim() const {
    return GetPointer<const fbs::IntImm *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyTable(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Argmin::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Argmin::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Argmin::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Argmin::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Argmin::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Argmin::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Argmin::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ArgminBuilder {
  typedef Argmin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<fbs::IntImm> dim) {
    fbb_.AddOffset(Argmin::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Argmin::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Argmin::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Argmin::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Argmin::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Argmin::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Argmin::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Argmin::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Argmin::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Argmin::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Argmin::VT_TAGS, tags);
  }
  explicit ArgminBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Argmin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Argmin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Argmin> CreateArgmin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ArgminBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Argmin> CreateArgminDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateArgmin(
      _fbb,
      dim,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AvgPool1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AvgPool1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_WIDTH = 4,
    VT_STRIDE_WIDTH = 6,
    VT_PAD_LEFT = 8,
    VT_PAD_RIGHT = 10,
    VT_COUNT_INCLUDE_PAD = 12,
    VT_DIVISOR_OVERRIDE = 14,
    VT_OP_ID = 16,
    VT_NAME = 18,
    VT_INPUTS_TYPE = 20,
    VT_INPUTS = 22,
    VT_OUTPUTS_TYPE = 24,
    VT_OUTPUTS = 26,
    VT_COMPILE_TARGET_TYPE = 28,
    VT_COMPILE_TARGET = 30,
    VT_TAGS = 32
  };
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  bool count_include_pad() const {
    return GetField<uint8_t>(VT_COUNT_INCLUDE_PAD, 0) != 0;
  }
  int64_t divisor_override() const {
    return GetField<int64_t>(VT_DIVISOR_OVERRIDE, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<uint8_t>(verifier, VT_COUNT_INCLUDE_PAD, 1) &&
           VerifyField<int64_t>(verifier, VT_DIVISOR_OVERRIDE, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *AvgPool1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *AvgPool1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *AvgPool1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *AvgPool1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *AvgPool1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *AvgPool1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *AvgPool1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AvgPool1dBuilder {
  typedef AvgPool1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_count_include_pad(bool count_include_pad) {
    fbb_.AddElement<uint8_t>(AvgPool1d::VT_COUNT_INCLUDE_PAD, static_cast<uint8_t>(count_include_pad), 0);
  }
  void add_divisor_override(int64_t divisor_override) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_DIVISOR_OVERRIDE, divisor_override, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(AvgPool1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AvgPool1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(AvgPool1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(AvgPool1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(AvgPool1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(AvgPool1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(AvgPool1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(AvgPool1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(AvgPool1d::VT_TAGS, tags);
  }
  explicit AvgPool1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AvgPool1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AvgPool1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AvgPool1d> CreateAvgPool1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AvgPool1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_divisor_override(divisor_override);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_stride_width(stride_width);
  builder_.add_pool_width(pool_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_count_include_pad(count_include_pad);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AvgPool1d> CreateAvgPool1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAvgPool1d(
      _fbb,
      pool_width,
      stride_width,
      pad_left,
      pad_right,
      count_include_pad,
      divisor_override,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AvgPool2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AvgPool2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_WIDTH = 4,
    VT_POOL_HEIGHT = 6,
    VT_STRIDE_WIDTH = 8,
    VT_STRIDE_HEIGHT = 10,
    VT_PAD_TOP = 12,
    VT_PAD_BOTTOM = 14,
    VT_PAD_LEFT = 16,
    VT_PAD_RIGHT = 18,
    VT_COUNT_INCLUDE_PAD = 20,
    VT_DIVISOR_OVERRIDE = 22,
    VT_OP_ID = 24,
    VT_NAME = 26,
    VT_INPUTS_TYPE = 28,
    VT_INPUTS = 30,
    VT_OUTPUTS_TYPE = 32,
    VT_OUTPUTS = 34,
    VT_COMPILE_TARGET_TYPE = 36,
    VT_COMPILE_TARGET = 38,
    VT_TAGS = 40
  };
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t pool_height() const {
    return GetField<int64_t>(VT_POOL_HEIGHT, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  bool count_include_pad() const {
    return GetField<uint8_t>(VT_COUNT_INCLUDE_PAD, 0) != 0;
  }
  int64_t divisor_override() const {
    return GetField<int64_t>(VT_DIVISOR_OVERRIDE, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<uint8_t>(verifier, VT_COUNT_INCLUDE_PAD, 1) &&
           VerifyField<int64_t>(verifier, VT_DIVISOR_OVERRIDE, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *AvgPool2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *AvgPool2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *AvgPool2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *AvgPool2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *AvgPool2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *AvgPool2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *AvgPool2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AvgPool2dBuilder {
  typedef AvgPool2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_pool_height(int64_t pool_height) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_POOL_HEIGHT, pool_height, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_count_include_pad(bool count_include_pad) {
    fbb_.AddElement<uint8_t>(AvgPool2d::VT_COUNT_INCLUDE_PAD, static_cast<uint8_t>(count_include_pad), 0);
  }
  void add_divisor_override(int64_t divisor_override) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_DIVISOR_OVERRIDE, divisor_override, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(AvgPool2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AvgPool2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(AvgPool2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(AvgPool2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(AvgPool2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(AvgPool2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(AvgPool2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(AvgPool2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(AvgPool2d::VT_TAGS, tags);
  }
  explicit AvgPool2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AvgPool2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AvgPool2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AvgPool2d> CreateAvgPool2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AvgPool2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_divisor_override(divisor_override);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_pool_height(pool_height);
  builder_.add_pool_width(pool_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_count_include_pad(count_include_pad);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AvgPool2d> CreateAvgPool2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAvgPool2d(
      _fbb,
      pool_width,
      pool_height,
      stride_width,
      stride_height,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      count_include_pad,
      divisor_override,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AvgPool3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AvgPool3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_DEPTH = 4,
    VT_POOL_WIDTH = 6,
    VT_POOL_HEIGHT = 8,
    VT_STRIDE_DEPTH = 10,
    VT_STRIDE_WIDTH = 12,
    VT_STRIDE_HEIGHT = 14,
    VT_PAD_FRONT = 16,
    VT_PAD_BACK = 18,
    VT_PAD_TOP = 20,
    VT_PAD_BOTTOM = 22,
    VT_PAD_LEFT = 24,
    VT_PAD_RIGHT = 26,
    VT_COUNT_INCLUDE_PAD = 28,
    VT_DIVISOR_OVERRIDE = 30,
    VT_OP_ID = 32,
    VT_NAME = 34,
    VT_INPUTS_TYPE = 36,
    VT_INPUTS = 38,
    VT_OUTPUTS_TYPE = 40,
    VT_OUTPUTS = 42,
    VT_COMPILE_TARGET_TYPE = 44,
    VT_COMPILE_TARGET = 46,
    VT_TAGS = 48
  };
  int64_t pool_depth() const {
    return GetField<int64_t>(VT_POOL_DEPTH, 0);
  }
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t pool_height() const {
    return GetField<int64_t>(VT_POOL_HEIGHT, 0);
  }
  int64_t stride_depth() const {
    return GetField<int64_t>(VT_STRIDE_DEPTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_front() const {
    return GetField<int64_t>(VT_PAD_FRONT, 0);
  }
  int64_t pad_back() const {
    return GetField<int64_t>(VT_PAD_BACK, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  bool count_include_pad() const {
    return GetField<uint8_t>(VT_COUNT_INCLUDE_PAD, 0) != 0;
  }
  int64_t divisor_override() const {
    return GetField<int64_t>(VT_DIVISOR_OVERRIDE, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_FRONT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BACK, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<uint8_t>(verifier, VT_COUNT_INCLUDE_PAD, 1) &&
           VerifyField<int64_t>(verifier, VT_DIVISOR_OVERRIDE, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *AvgPool3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *AvgPool3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *AvgPool3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *AvgPool3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *AvgPool3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *AvgPool3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *AvgPool3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct AvgPool3dBuilder {
  typedef AvgPool3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_depth(int64_t pool_depth) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_POOL_DEPTH, pool_depth, 0);
  }
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_pool_height(int64_t pool_height) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_POOL_HEIGHT, pool_height, 0);
  }
  void add_stride_depth(int64_t stride_depth) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_STRIDE_DEPTH, stride_depth, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_front(int64_t pad_front) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_FRONT, pad_front, 0);
  }
  void add_pad_back(int64_t pad_back) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_BACK, pad_back, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_count_include_pad(bool count_include_pad) {
    fbb_.AddElement<uint8_t>(AvgPool3d::VT_COUNT_INCLUDE_PAD, static_cast<uint8_t>(count_include_pad), 0);
  }
  void add_divisor_override(int64_t divisor_override) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_DIVISOR_OVERRIDE, divisor_override, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(AvgPool3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AvgPool3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(AvgPool3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(AvgPool3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(AvgPool3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(AvgPool3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(AvgPool3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(AvgPool3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(AvgPool3d::VT_TAGS, tags);
  }
  explicit AvgPool3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AvgPool3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AvgPool3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AvgPool3d> CreateAvgPool3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_depth = 0,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  AvgPool3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_divisor_override(divisor_override);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_pad_back(pad_back);
  builder_.add_pad_front(pad_front);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_stride_depth(stride_depth);
  builder_.add_pool_height(pool_height);
  builder_.add_pool_width(pool_width);
  builder_.add_pool_depth(pool_depth);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_count_include_pad(count_include_pad);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AvgPool3d> CreateAvgPool3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_depth = 0,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    bool count_include_pad = false,
    int64_t divisor_override = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateAvgPool3d(
      _fbb,
      pool_depth,
      pool_width,
      pool_height,
      stride_depth,
      stride_width,
      stride_height,
      pad_front,
      pad_back,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      count_include_pad,
      divisor_override,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct AxisName FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AxisNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct AxisNameBuilder {
  typedef AxisName Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AxisName::VT_NAME, name);
  }
  explicit AxisNameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AxisName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AxisName>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AxisName> CreateAxisName(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  AxisNameBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AxisName> CreateAxisNameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fbs::CreateAxisName(
      _fbb,
      name__);
}

struct AxisUnit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AxisUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4,
    VT_NAME = 6
  };
  uint64_t unit() const {
    return GetField<uint64_t>(VT_UNIT, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UNIT, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct AxisUnitBuilder {
  typedef AxisUnit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unit(uint64_t unit) {
    fbb_.AddElement<uint64_t>(AxisUnit::VT_UNIT, unit, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AxisUnit::VT_NAME, name);
  }
  explicit AxisUnitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AxisUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AxisUnit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AxisUnit> CreateAxisUnit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t unit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  AxisUnitBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AxisUnit> CreateAxisUnitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t unit = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fbs::CreateAxisUnit(
      _fbb,
      unit,
      name__);
}

struct BaseQuantizedType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BaseQuantizedTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE_DTYPE_TYPE = 4,
    VT_STORAGE_DTYPE = 6,
    VT_EXPRESSED_DTYPE_TYPE = 8,
    VT_EXPRESSED_DTYPE = 10
  };
  fbs::ScalarType_box storage_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_STORAGE_DTYPE_TYPE, 0));
  }
  const void *storage_dtype() const {
    return GetPointer<const void *>(VT_STORAGE_DTYPE);
  }
  template<typename T> const T *storage_dtype_as() const;
  const fbs::BoolType *storage_dtype_as_BoolType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(storage_dtype()) : nullptr;
  }
  const fbs::IntegerType *storage_dtype_as_IntegerType() const {
    return storage_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(storage_dtype()) : nullptr;
  }
  const fbs::FloatType *storage_dtype_as_FloatType() const {
    return storage_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(storage_dtype()) : nullptr;
  }
  const fbs::CalibratedType *storage_dtype_as_CalibratedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedType *storage_dtype_as_NormalizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *storage_dtype_as_NormalizedQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::QuantizedType *storage_dtype_as_QuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *storage_dtype_as_BaseQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::ScalarType *storage_dtype_as_ScalarType() const {
    return storage_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(storage_dtype()) : nullptr;
  }
  fbs::ScalarType_box expressed_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_EXPRESSED_DTYPE_TYPE, 0));
  }
  const void *expressed_dtype() const {
    return GetPointer<const void *>(VT_EXPRESSED_DTYPE);
  }
  template<typename T> const T *expressed_dtype_as() const;
  const fbs::BoolType *expressed_dtype_as_BoolType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(expressed_dtype()) : nullptr;
  }
  const fbs::IntegerType *expressed_dtype_as_IntegerType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(expressed_dtype()) : nullptr;
  }
  const fbs::FloatType *expressed_dtype_as_FloatType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(expressed_dtype()) : nullptr;
  }
  const fbs::CalibratedType *expressed_dtype_as_CalibratedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedType *expressed_dtype_as_NormalizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *expressed_dtype_as_NormalizedQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::QuantizedType *expressed_dtype_as_QuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *expressed_dtype_as_BaseQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::ScalarType *expressed_dtype_as_ScalarType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(expressed_dtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_DTYPE) &&
           VerifyScalarType_box(verifier, storage_dtype(), storage_dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSED_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXPRESSED_DTYPE) &&
           VerifyScalarType_box(verifier, expressed_dtype(), expressed_dtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *BaseQuantizedType::storage_dtype_as<fbs::BoolType>() const {
  return storage_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *BaseQuantizedType::storage_dtype_as<fbs::IntegerType>() const {
  return storage_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *BaseQuantizedType::storage_dtype_as<fbs::FloatType>() const {
  return storage_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *BaseQuantizedType::storage_dtype_as<fbs::CalibratedType>() const {
  return storage_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *BaseQuantizedType::storage_dtype_as<fbs::NormalizedType>() const {
  return storage_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *BaseQuantizedType::storage_dtype_as<fbs::NormalizedQuantizedType>() const {
  return storage_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *BaseQuantizedType::storage_dtype_as<fbs::QuantizedType>() const {
  return storage_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *BaseQuantizedType::storage_dtype_as<fbs::BaseQuantizedType>() const {
  return storage_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *BaseQuantizedType::storage_dtype_as<fbs::ScalarType>() const {
  return storage_dtype_as_ScalarType();
}

template<> inline const fbs::BoolType *BaseQuantizedType::expressed_dtype_as<fbs::BoolType>() const {
  return expressed_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *BaseQuantizedType::expressed_dtype_as<fbs::IntegerType>() const {
  return expressed_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *BaseQuantizedType::expressed_dtype_as<fbs::FloatType>() const {
  return expressed_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *BaseQuantizedType::expressed_dtype_as<fbs::CalibratedType>() const {
  return expressed_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *BaseQuantizedType::expressed_dtype_as<fbs::NormalizedType>() const {
  return expressed_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *BaseQuantizedType::expressed_dtype_as<fbs::NormalizedQuantizedType>() const {
  return expressed_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *BaseQuantizedType::expressed_dtype_as<fbs::QuantizedType>() const {
  return expressed_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *BaseQuantizedType::expressed_dtype_as<fbs::BaseQuantizedType>() const {
  return expressed_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *BaseQuantizedType::expressed_dtype_as<fbs::ScalarType>() const {
  return expressed_dtype_as_ScalarType();
}

struct BaseQuantizedTypeBuilder {
  typedef BaseQuantizedType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_storage_dtype_type(fbs::ScalarType_box storage_dtype_type) {
    fbb_.AddElement<uint8_t>(BaseQuantizedType::VT_STORAGE_DTYPE_TYPE, static_cast<uint8_t>(storage_dtype_type), 0);
  }
  void add_storage_dtype(::flatbuffers::Offset<void> storage_dtype) {
    fbb_.AddOffset(BaseQuantizedType::VT_STORAGE_DTYPE, storage_dtype);
  }
  void add_expressed_dtype_type(fbs::ScalarType_box expressed_dtype_type) {
    fbb_.AddElement<uint8_t>(BaseQuantizedType::VT_EXPRESSED_DTYPE_TYPE, static_cast<uint8_t>(expressed_dtype_type), 0);
  }
  void add_expressed_dtype(::flatbuffers::Offset<void> expressed_dtype) {
    fbb_.AddOffset(BaseQuantizedType::VT_EXPRESSED_DTYPE, expressed_dtype);
  }
  explicit BaseQuantizedTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BaseQuantizedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BaseQuantizedType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BaseQuantizedType> CreateBaseQuantizedType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  BaseQuantizedTypeBuilder builder_(_fbb);
  builder_.add_expressed_dtype(expressed_dtype);
  builder_.add_storage_dtype(storage_dtype);
  builder_.add_expressed_dtype_type(expressed_dtype_type);
  builder_.add_storage_dtype_type(storage_dtype_type);
  return builder_.Finish();
}

struct BatchNorm1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchNorm1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIANCE = 4,
    VT_MEAN = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::Params *variance() const {
    return GetPointer<const fbs::Params *>(VT_VARIANCE);
  }
  const fbs::Params *mean() const {
    return GetPointer<const fbs::Params *>(VT_MEAN);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyTable(variance()) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *BatchNorm1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *BatchNorm1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *BatchNorm1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *BatchNorm1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *BatchNorm1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *BatchNorm1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *BatchNorm1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct BatchNorm1dBuilder {
  typedef BatchNorm1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_variance(::flatbuffers::Offset<fbs::Params> variance) {
    fbb_.AddOffset(BatchNorm1d::VT_VARIANCE, variance);
  }
  void add_mean(::flatbuffers::Offset<fbs::Params> mean) {
    fbb_.AddOffset(BatchNorm1d::VT_MEAN, mean);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(BatchNorm1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(BatchNorm1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(BatchNorm1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(BatchNorm1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(BatchNorm1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(BatchNorm1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(BatchNorm1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(BatchNorm1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(BatchNorm1d::VT_TAGS, tags);
  }
  explicit BatchNorm1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchNorm1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchNorm1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchNorm1d> CreateBatchNorm1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  BatchNorm1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_mean(mean);
  builder_.add_variance(variance);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchNorm1d> CreateBatchNorm1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateBatchNorm1d(
      _fbb,
      variance,
      mean,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct BatchNorm2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchNorm2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIANCE = 4,
    VT_MEAN = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::Params *variance() const {
    return GetPointer<const fbs::Params *>(VT_VARIANCE);
  }
  const fbs::Params *mean() const {
    return GetPointer<const fbs::Params *>(VT_MEAN);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyTable(variance()) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *BatchNorm2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *BatchNorm2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *BatchNorm2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *BatchNorm2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *BatchNorm2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *BatchNorm2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *BatchNorm2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct BatchNorm2dBuilder {
  typedef BatchNorm2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_variance(::flatbuffers::Offset<fbs::Params> variance) {
    fbb_.AddOffset(BatchNorm2d::VT_VARIANCE, variance);
  }
  void add_mean(::flatbuffers::Offset<fbs::Params> mean) {
    fbb_.AddOffset(BatchNorm2d::VT_MEAN, mean);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(BatchNorm2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(BatchNorm2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(BatchNorm2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(BatchNorm2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(BatchNorm2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(BatchNorm2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(BatchNorm2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(BatchNorm2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(BatchNorm2d::VT_TAGS, tags);
  }
  explicit BatchNorm2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchNorm2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchNorm2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchNorm2d> CreateBatchNorm2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  BatchNorm2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_mean(mean);
  builder_.add_variance(variance);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchNorm2d> CreateBatchNorm2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateBatchNorm2d(
      _fbb,
      variance,
      mean,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct BatchNorm3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchNorm3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIANCE = 4,
    VT_MEAN = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::Params *variance() const {
    return GetPointer<const fbs::Params *>(VT_VARIANCE);
  }
  const fbs::Params *mean() const {
    return GetPointer<const fbs::Params *>(VT_MEAN);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyTable(variance()) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *BatchNorm3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *BatchNorm3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *BatchNorm3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *BatchNorm3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *BatchNorm3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *BatchNorm3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *BatchNorm3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct BatchNorm3dBuilder {
  typedef BatchNorm3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_variance(::flatbuffers::Offset<fbs::Params> variance) {
    fbb_.AddOffset(BatchNorm3d::VT_VARIANCE, variance);
  }
  void add_mean(::flatbuffers::Offset<fbs::Params> mean) {
    fbb_.AddOffset(BatchNorm3d::VT_MEAN, mean);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(BatchNorm3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(BatchNorm3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(BatchNorm3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(BatchNorm3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(BatchNorm3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(BatchNorm3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(BatchNorm3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(BatchNorm3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(BatchNorm3d::VT_TAGS, tags);
  }
  explicit BatchNorm3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchNorm3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchNorm3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchNorm3d> CreateBatchNorm3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  BatchNorm3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_mean(mean);
  builder_.add_variance(variance);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchNorm3d> CreateBatchNorm3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> variance = 0,
    ::flatbuffers::Offset<fbs::Params> mean = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateBatchNorm3d(
      _fbb,
      variance,
      mean,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DTYPE_TYPE = 6,
    VT_DTYPE = 8,
    VT_MTYPE_TYPE = 10,
    VT_MTYPE = 12
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *Bool::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *Bool::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *Bool::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *Bool::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *Bool::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *Bool::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *Bool::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *Bool::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *Bool::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *Bool::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *Bool::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *Bool::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *Bool::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *Bool::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *Bool::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *Bool::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(Bool::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(Bool::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(Bool::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(Bool::VT_MTYPE, mtype);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  BoolBuilder builder_(_fbb);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BoolType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolTypeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BoolTypeBuilder {
  typedef BoolType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BoolTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolType> CreateBoolType(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BoolTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BuyiTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BuyiTargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BuyiTargetBuilder {
  typedef BuyiTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit BuyiTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BuyiTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BuyiTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BuyiTarget> CreateBuyiTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  BuyiTargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CalibratedType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalibratedTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SAT = 8,
    VT_STORAGE_DTYPE_TYPE = 10,
    VT_STORAGE_DTYPE = 12,
    VT_EXPRESSED_DTYPE_TYPE = 14,
    VT_EXPRESSED_DTYPE = 16
  };
  const ::flatbuffers::Vector<float> *min() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MIN);
  }
  const ::flatbuffers::Vector<float> *max() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAX);
  }
  const ::flatbuffers::Vector<float> *sat() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SAT);
  }
  fbs::ScalarType_box storage_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_STORAGE_DTYPE_TYPE, 0));
  }
  const void *storage_dtype() const {
    return GetPointer<const void *>(VT_STORAGE_DTYPE);
  }
  template<typename T> const T *storage_dtype_as() const;
  const fbs::BoolType *storage_dtype_as_BoolType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(storage_dtype()) : nullptr;
  }
  const fbs::IntegerType *storage_dtype_as_IntegerType() const {
    return storage_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(storage_dtype()) : nullptr;
  }
  const fbs::FloatType *storage_dtype_as_FloatType() const {
    return storage_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(storage_dtype()) : nullptr;
  }
  const fbs::CalibratedType *storage_dtype_as_CalibratedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedType *storage_dtype_as_NormalizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *storage_dtype_as_NormalizedQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::QuantizedType *storage_dtype_as_QuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *storage_dtype_as_BaseQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::ScalarType *storage_dtype_as_ScalarType() const {
    return storage_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(storage_dtype()) : nullptr;
  }
  fbs::ScalarType_box expressed_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_EXPRESSED_DTYPE_TYPE, 0));
  }
  const void *expressed_dtype() const {
    return GetPointer<const void *>(VT_EXPRESSED_DTYPE);
  }
  template<typename T> const T *expressed_dtype_as() const;
  const fbs::BoolType *expressed_dtype_as_BoolType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(expressed_dtype()) : nullptr;
  }
  const fbs::IntegerType *expressed_dtype_as_IntegerType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(expressed_dtype()) : nullptr;
  }
  const fbs::FloatType *expressed_dtype_as_FloatType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(expressed_dtype()) : nullptr;
  }
  const fbs::CalibratedType *expressed_dtype_as_CalibratedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedType *expressed_dtype_as_NormalizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *expressed_dtype_as_NormalizedQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::QuantizedType *expressed_dtype_as_QuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *expressed_dtype_as_BaseQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::ScalarType *expressed_dtype_as_ScalarType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(expressed_dtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SAT) &&
           verifier.VerifyVector(sat()) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_DTYPE) &&
           VerifyScalarType_box(verifier, storage_dtype(), storage_dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSED_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXPRESSED_DTYPE) &&
           VerifyScalarType_box(verifier, expressed_dtype(), expressed_dtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *CalibratedType::storage_dtype_as<fbs::BoolType>() const {
  return storage_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *CalibratedType::storage_dtype_as<fbs::IntegerType>() const {
  return storage_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *CalibratedType::storage_dtype_as<fbs::FloatType>() const {
  return storage_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *CalibratedType::storage_dtype_as<fbs::CalibratedType>() const {
  return storage_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *CalibratedType::storage_dtype_as<fbs::NormalizedType>() const {
  return storage_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *CalibratedType::storage_dtype_as<fbs::NormalizedQuantizedType>() const {
  return storage_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *CalibratedType::storage_dtype_as<fbs::QuantizedType>() const {
  return storage_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *CalibratedType::storage_dtype_as<fbs::BaseQuantizedType>() const {
  return storage_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *CalibratedType::storage_dtype_as<fbs::ScalarType>() const {
  return storage_dtype_as_ScalarType();
}

template<> inline const fbs::BoolType *CalibratedType::expressed_dtype_as<fbs::BoolType>() const {
  return expressed_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *CalibratedType::expressed_dtype_as<fbs::IntegerType>() const {
  return expressed_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *CalibratedType::expressed_dtype_as<fbs::FloatType>() const {
  return expressed_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *CalibratedType::expressed_dtype_as<fbs::CalibratedType>() const {
  return expressed_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *CalibratedType::expressed_dtype_as<fbs::NormalizedType>() const {
  return expressed_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *CalibratedType::expressed_dtype_as<fbs::NormalizedQuantizedType>() const {
  return expressed_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *CalibratedType::expressed_dtype_as<fbs::QuantizedType>() const {
  return expressed_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *CalibratedType::expressed_dtype_as<fbs::BaseQuantizedType>() const {
  return expressed_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *CalibratedType::expressed_dtype_as<fbs::ScalarType>() const {
  return expressed_dtype_as_ScalarType();
}

struct CalibratedTypeBuilder {
  typedef CalibratedType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(::flatbuffers::Offset<::flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(CalibratedType::VT_MIN, min);
  }
  void add_max(::flatbuffers::Offset<::flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(CalibratedType::VT_MAX, max);
  }
  void add_sat(::flatbuffers::Offset<::flatbuffers::Vector<float>> sat) {
    fbb_.AddOffset(CalibratedType::VT_SAT, sat);
  }
  void add_storage_dtype_type(fbs::ScalarType_box storage_dtype_type) {
    fbb_.AddElement<uint8_t>(CalibratedType::VT_STORAGE_DTYPE_TYPE, static_cast<uint8_t>(storage_dtype_type), 0);
  }
  void add_storage_dtype(::flatbuffers::Offset<void> storage_dtype) {
    fbb_.AddOffset(CalibratedType::VT_STORAGE_DTYPE, storage_dtype);
  }
  void add_expressed_dtype_type(fbs::ScalarType_box expressed_dtype_type) {
    fbb_.AddElement<uint8_t>(CalibratedType::VT_EXPRESSED_DTYPE_TYPE, static_cast<uint8_t>(expressed_dtype_type), 0);
  }
  void add_expressed_dtype(::flatbuffers::Offset<void> expressed_dtype) {
    fbb_.AddOffset(CalibratedType::VT_EXPRESSED_DTYPE, expressed_dtype);
  }
  explicit CalibratedTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalibratedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalibratedType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalibratedType> CreateCalibratedType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> min = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> max = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> sat = 0,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  CalibratedTypeBuilder builder_(_fbb);
  builder_.add_expressed_dtype(expressed_dtype);
  builder_.add_storage_dtype(storage_dtype);
  builder_.add_sat(sat);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_expressed_dtype_type(expressed_dtype_type);
  builder_.add_storage_dtype_type(storage_dtype_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CalibratedType> CreateCalibratedTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *sat = nullptr,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto sat__ = sat ? _fbb.CreateVector<float>(*sat) : 0;
  return fbs::CreateCalibratedType(
      _fbb,
      min__,
      max__,
      sat__,
      storage_dtype_type,
      storage_dtype,
      expressed_dtype_type,
      expressed_dtype);
}

struct Cast FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CastBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_DTYPE = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const fbs::TensorType *target_dtype() const {
    return GetPointer<const fbs::TensorType *>(VT_TARGET_DTYPE);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET_DTYPE) &&
           verifier.VerifyTable(target_dtype()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Cast::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Cast::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Cast::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Cast::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Cast::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Cast::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Cast::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct CastBuilder {
  typedef Cast Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_dtype(::flatbuffers::Offset<fbs::TensorType> target_dtype) {
    fbb_.AddOffset(Cast::VT_TARGET_DTYPE, target_dtype);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Cast::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Cast::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Cast::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Cast::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Cast::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Cast::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Cast::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Cast::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Cast::VT_TAGS, tags);
  }
  explicit CastBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Cast> CreateCast(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::TensorType> target_dtype = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  CastBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_target_dtype(target_dtype);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Cast> CreateCastDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::TensorType> target_dtype = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateCast(
      _fbb,
      target_dtype,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ChannelShuffle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelShuffleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ChannelShuffle::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ChannelShuffle::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ChannelShuffle::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ChannelShuffle::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ChannelShuffle::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ChannelShuffle::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ChannelShuffle::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ChannelShuffleBuilder {
  typedef ChannelShuffle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(ChannelShuffle::VT_GROUPS, groups, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ChannelShuffle::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ChannelShuffle::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ChannelShuffle::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ChannelShuffle::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ChannelShuffle::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ChannelShuffle::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ChannelShuffle::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ChannelShuffle::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ChannelShuffle::VT_TAGS, tags);
  }
  explicit ChannelShuffleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelShuffle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelShuffle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelShuffle> CreateChannelShuffle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t groups = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ChannelShuffleBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChannelShuffle> CreateChannelShuffleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t groups = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateChannelShuffle(
      _fbb,
      groups,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ChunkMem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkMemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_ID = 4,
    VT_OFFSET = 6
  };
  uint64_t chunk_id() const {
    return GetField<uint64_t>(VT_CHUNK_ID, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHUNK_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           verifier.EndTable();
  }
};

struct ChunkMemBuilder {
  typedef ChunkMem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunk_id(uint64_t chunk_id) {
    fbb_.AddElement<uint64_t>(ChunkMem::VT_CHUNK_ID, chunk_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(ChunkMem::VT_OFFSET, offset, 0);
  }
  explicit ChunkMemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkMem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkMem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkMem> CreateChunkMem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t chunk_id = 0,
    uint64_t offset = 0) {
  ChunkMemBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_chunk_id(chunk_id);
  return builder_.Finish();
}

struct ClampScalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClampScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ClampScalar::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ClampScalar::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ClampScalar::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ClampScalar::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ClampScalar::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ClampScalar::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ClampScalar::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ClampScalarBuilder {
  typedef ClampScalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(ClampScalar::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(ClampScalar::VT_MAX, max, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ClampScalar::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ClampScalar::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ClampScalar::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ClampScalar::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ClampScalar::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ClampScalar::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ClampScalar::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ClampScalar::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ClampScalar::VT_TAGS, tags);
  }
  explicit ClampScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClampScalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClampScalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClampScalar> CreateClampScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ClampScalarBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClampScalar> CreateClampScalarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateClampScalar(
      _fbb,
      min,
      max,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct CompileTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompileTargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CompileTargetBuilder {
  typedef CompileTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CompileTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompileTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompileTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompileTarget> CreateCompileTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CompileTargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Concat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConcatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Concat::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Concat::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Concat::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Concat::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Concat::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Concat::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Concat::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ConcatBuilder {
  typedef Concat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Concat::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Concat::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Concat::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Concat::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Concat::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Concat::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Concat::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Concat::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Concat::VT_TAGS, tags);
  }
  explicit ConcatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Concat> CreateConcat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_axis(axis);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Concat> CreateConcatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConcat(
      _fbb,
      axis,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Conv1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_WIDTH = 4,
    VT_PAD_LEFT = 6,
    VT_PAD_RIGHT = 8,
    VT_DILATION_WIDTH = 10,
    VT_GROUPS = 12,
    VT_PADDING_MODE = 14,
    VT_CUT_SCALE_TYPE = 16,
    VT_CUT_SCALE = 18,
    VT_OP_ID = 20,
    VT_NAME = 22,
    VT_INPUTS_TYPE = 24,
    VT_INPUTS = 26,
    VT_OUTPUTS_TYPE = 28,
    VT_OUTPUTS = 30,
    VT_COMPILE_TARGET_TYPE = 32,
    VT_COMPILE_TARGET = 34,
    VT_TAGS = 36
  };
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  const ::flatbuffers::String *padding_mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PADDING_MODE);
  }
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyOffset(verifier, VT_PADDING_MODE) &&
           verifier.VerifyString(padding_mode()) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Conv1d::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Conv1d::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Conv1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Conv1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Conv1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Conv1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Conv1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Conv1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Conv1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct Conv1dBuilder {
  typedef Conv1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(Conv1d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(Conv1d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(Conv1d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(Conv1d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(Conv1d::VT_GROUPS, groups, 0);
  }
  void add_padding_mode(::flatbuffers::Offset<::flatbuffers::String> padding_mode) {
    fbb_.AddOffset(Conv1d::VT_PADDING_MODE, padding_mode);
  }
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Conv1d::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Conv1d::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Conv1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Conv1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Conv1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Conv1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Conv1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Conv1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Conv1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Conv1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Conv1d::VT_TAGS, tags);
  }
  explicit Conv1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv1d> CreateConv1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t groups = 0,
    ::flatbuffers::Offset<::flatbuffers::String> padding_mode = 0,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  Conv1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_stride_width(stride_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_padding_mode(padding_mode);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conv1d> CreateConv1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t groups = 0,
    const char *padding_mode = nullptr,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto padding_mode__ = padding_mode ? _fbb.CreateString(padding_mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConv1d(
      _fbb,
      stride_width,
      pad_left,
      pad_right,
      dilation_width,
      groups,
      padding_mode__,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Conv2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_WIDTH = 4,
    VT_STRIDE_HEIGHT = 6,
    VT_PAD_TOP = 8,
    VT_PAD_BOTTOM = 10,
    VT_PAD_LEFT = 12,
    VT_PAD_RIGHT = 14,
    VT_DILATION_WIDTH = 16,
    VT_DILATION_HEIGHT = 18,
    VT_GROUPS = 20,
    VT_PADDING_MODE = 22,
    VT_CUT_SCALE_TYPE = 24,
    VT_CUT_SCALE = 26,
    VT_OP_ID = 28,
    VT_NAME = 30,
    VT_INPUTS_TYPE = 32,
    VT_INPUTS = 34,
    VT_OUTPUTS_TYPE = 36,
    VT_OUTPUTS = 38,
    VT_COMPILE_TARGET_TYPE = 40,
    VT_COMPILE_TARGET = 42,
    VT_TAGS = 44
  };
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  const ::flatbuffers::String *padding_mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PADDING_MODE);
  }
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyOffset(verifier, VT_PADDING_MODE) &&
           verifier.VerifyString(padding_mode()) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Conv2d::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Conv2d::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Conv2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Conv2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Conv2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Conv2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Conv2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Conv2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Conv2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct Conv2dBuilder {
  typedef Conv2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(Conv2d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(Conv2d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(Conv2d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(Conv2d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(Conv2d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(Conv2d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(Conv2d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(Conv2d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(Conv2d::VT_GROUPS, groups, 0);
  }
  void add_padding_mode(::flatbuffers::Offset<::flatbuffers::String> padding_mode) {
    fbb_.AddOffset(Conv2d::VT_PADDING_MODE, padding_mode);
  }
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Conv2d::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Conv2d::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Conv2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Conv2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Conv2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Conv2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Conv2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Conv2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Conv2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Conv2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Conv2d::VT_TAGS, tags);
  }
  explicit Conv2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv2d> CreateConv2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t groups = 0,
    ::flatbuffers::Offset<::flatbuffers::String> padding_mode = 0,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  Conv2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_padding_mode(padding_mode);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conv2d> CreateConv2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t groups = 0,
    const char *padding_mode = nullptr,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto padding_mode__ = padding_mode ? _fbb.CreateString(padding_mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConv2d(
      _fbb,
      stride_width,
      stride_height,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_width,
      dilation_height,
      groups,
      padding_mode__,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Conv3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_DEPTH = 4,
    VT_STRIDE_WIDTH = 6,
    VT_STRIDE_HEIGHT = 8,
    VT_PAD_FRONT = 10,
    VT_PAD_BACK = 12,
    VT_PAD_TOP = 14,
    VT_PAD_BOTTOM = 16,
    VT_PAD_LEFT = 18,
    VT_PAD_RIGHT = 20,
    VT_DILATION_DEPTH = 22,
    VT_DILATION_WIDTH = 24,
    VT_DILATION_HEIGHT = 26,
    VT_GROUPS = 28,
    VT_PADDING_MODE = 30,
    VT_CUT_SCALE_TYPE = 32,
    VT_CUT_SCALE = 34,
    VT_OP_ID = 36,
    VT_NAME = 38,
    VT_INPUTS_TYPE = 40,
    VT_INPUTS = 42,
    VT_OUTPUTS_TYPE = 44,
    VT_OUTPUTS = 46,
    VT_COMPILE_TARGET_TYPE = 48,
    VT_COMPILE_TARGET = 50,
    VT_TAGS = 52
  };
  int64_t stride_depth() const {
    return GetField<int64_t>(VT_STRIDE_DEPTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_front() const {
    return GetField<int64_t>(VT_PAD_FRONT, 0);
  }
  int64_t pad_back() const {
    return GetField<int64_t>(VT_PAD_BACK, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_depth() const {
    return GetField<int64_t>(VT_DILATION_DEPTH, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  const ::flatbuffers::String *padding_mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PADDING_MODE);
  }
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_FRONT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BACK, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyOffset(verifier, VT_PADDING_MODE) &&
           verifier.VerifyString(padding_mode()) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Conv3d::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Conv3d::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Conv3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Conv3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Conv3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Conv3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Conv3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Conv3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Conv3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct Conv3dBuilder {
  typedef Conv3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_depth(int64_t stride_depth) {
    fbb_.AddElement<int64_t>(Conv3d::VT_STRIDE_DEPTH, stride_depth, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(Conv3d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(Conv3d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_front(int64_t pad_front) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_FRONT, pad_front, 0);
  }
  void add_pad_back(int64_t pad_back) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_BACK, pad_back, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(Conv3d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_depth(int64_t dilation_depth) {
    fbb_.AddElement<int64_t>(Conv3d::VT_DILATION_DEPTH, dilation_depth, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(Conv3d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(Conv3d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(Conv3d::VT_GROUPS, groups, 0);
  }
  void add_padding_mode(::flatbuffers::Offset<::flatbuffers::String> padding_mode) {
    fbb_.AddOffset(Conv3d::VT_PADDING_MODE, padding_mode);
  }
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Conv3d::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Conv3d::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Conv3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Conv3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Conv3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Conv3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Conv3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Conv3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Conv3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Conv3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Conv3d::VT_TAGS, tags);
  }
  explicit Conv3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv3d> CreateConv3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t groups = 0,
    ::flatbuffers::Offset<::flatbuffers::String> padding_mode = 0,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  Conv3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_dilation_depth(dilation_depth);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_pad_back(pad_back);
  builder_.add_pad_front(pad_front);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_stride_depth(stride_depth);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_padding_mode(padding_mode);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conv3d> CreateConv3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t groups = 0,
    const char *padding_mode = nullptr,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto padding_mode__ = padding_mode ? _fbb.CreateString(padding_mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConv3d(
      _fbb,
      stride_depth,
      stride_width,
      stride_height,
      pad_front,
      pad_back,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_depth,
      dilation_width,
      dilation_height,
      groups,
      padding_mode__,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ConvTranspose1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConvTranspose1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_WIDTH = 4,
    VT_PAD_LEFT = 6,
    VT_PAD_RIGHT = 8,
    VT_DILATION_WIDTH = 10,
    VT_OUTPUT_PAD_WIDTH = 12,
    VT_GROUPS = 14,
    VT_OP_ID = 16,
    VT_NAME = 18,
    VT_INPUTS_TYPE = 20,
    VT_INPUTS = 22,
    VT_OUTPUTS_TYPE = 24,
    VT_OUTPUTS = 26,
    VT_COMPILE_TARGET_TYPE = 28,
    VT_COMPILE_TARGET = 30,
    VT_TAGS = 32
  };
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t output_pad_width() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_WIDTH, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ConvTranspose1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ConvTranspose1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ConvTranspose1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ConvTranspose1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ConvTranspose1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ConvTranspose1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ConvTranspose1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ConvTranspose1dBuilder {
  typedef ConvTranspose1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_output_pad_width(int64_t output_pad_width) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_OUTPUT_PAD_WIDTH, output_pad_width, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_GROUPS, groups, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ConvTranspose1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ConvTranspose1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ConvTranspose1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ConvTranspose1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ConvTranspose1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ConvTranspose1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ConvTranspose1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ConvTranspose1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ConvTranspose1d::VT_TAGS, tags);
  }
  explicit ConvTranspose1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConvTranspose1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConvTranspose1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConvTranspose1d> CreateConvTranspose1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t output_pad_width = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ConvTranspose1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_output_pad_width(output_pad_width);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_stride_width(stride_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConvTranspose1d> CreateConvTranspose1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t output_pad_width = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConvTranspose1d(
      _fbb,
      stride_width,
      pad_left,
      pad_right,
      dilation_width,
      output_pad_width,
      groups,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ConvTranspose2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConvTranspose2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_WIDTH = 4,
    VT_STRIDE_HEIGHT = 6,
    VT_PAD_TOP = 8,
    VT_PAD_BOTTOM = 10,
    VT_PAD_LEFT = 12,
    VT_PAD_RIGHT = 14,
    VT_DILATION_WIDTH = 16,
    VT_DILATION_HEIGHT = 18,
    VT_OUTPUT_PAD_WIDTH = 20,
    VT_OUTPUT_PAD_HEIGHT = 22,
    VT_GROUPS = 24,
    VT_OP_ID = 26,
    VT_NAME = 28,
    VT_INPUTS_TYPE = 30,
    VT_INPUTS = 32,
    VT_OUTPUTS_TYPE = 34,
    VT_OUTPUTS = 36,
    VT_COMPILE_TARGET_TYPE = 38,
    VT_COMPILE_TARGET = 40,
    VT_TAGS = 42
  };
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t output_pad_width() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_WIDTH, 0);
  }
  int64_t output_pad_height() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_HEIGHT, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ConvTranspose2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ConvTranspose2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ConvTranspose2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ConvTranspose2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ConvTranspose2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ConvTranspose2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ConvTranspose2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ConvTranspose2dBuilder {
  typedef ConvTranspose2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_output_pad_width(int64_t output_pad_width) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_OUTPUT_PAD_WIDTH, output_pad_width, 0);
  }
  void add_output_pad_height(int64_t output_pad_height) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_OUTPUT_PAD_HEIGHT, output_pad_height, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_GROUPS, groups, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ConvTranspose2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ConvTranspose2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ConvTranspose2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ConvTranspose2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ConvTranspose2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ConvTranspose2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ConvTranspose2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ConvTranspose2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ConvTranspose2d::VT_TAGS, tags);
  }
  explicit ConvTranspose2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConvTranspose2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConvTranspose2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConvTranspose2d> CreateConvTranspose2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t output_pad_width = 0,
    int64_t output_pad_height = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ConvTranspose2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_output_pad_height(output_pad_height);
  builder_.add_output_pad_width(output_pad_width);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConvTranspose2d> CreateConvTranspose2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t output_pad_width = 0,
    int64_t output_pad_height = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConvTranspose2d(
      _fbb,
      stride_width,
      stride_height,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_width,
      dilation_height,
      output_pad_width,
      output_pad_height,
      groups,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ConvTranspose3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConvTranspose3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE_DEPTH = 4,
    VT_STRIDE_WIDTH = 6,
    VT_STRIDE_HEIGHT = 8,
    VT_PAD_FRONT = 10,
    VT_PAD_BACK = 12,
    VT_PAD_TOP = 14,
    VT_PAD_BOTTOM = 16,
    VT_PAD_LEFT = 18,
    VT_PAD_RIGHT = 20,
    VT_DILATION_DEPTH = 22,
    VT_DILATION_WIDTH = 24,
    VT_DILATION_HEIGHT = 26,
    VT_OUTPUT_PAD_DEPTH = 28,
    VT_OUTPUT_PAD_WIDTH = 30,
    VT_OUTPUT_PAD_HEIGHT = 32,
    VT_GROUPS = 34,
    VT_OP_ID = 36,
    VT_NAME = 38,
    VT_INPUTS_TYPE = 40,
    VT_INPUTS = 42,
    VT_OUTPUTS_TYPE = 44,
    VT_OUTPUTS = 46,
    VT_COMPILE_TARGET_TYPE = 48,
    VT_COMPILE_TARGET = 50,
    VT_TAGS = 52
  };
  int64_t stride_depth() const {
    return GetField<int64_t>(VT_STRIDE_DEPTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_front() const {
    return GetField<int64_t>(VT_PAD_FRONT, 0);
  }
  int64_t pad_back() const {
    return GetField<int64_t>(VT_PAD_BACK, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_depth() const {
    return GetField<int64_t>(VT_DILATION_DEPTH, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t output_pad_depth() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_DEPTH, 0);
  }
  int64_t output_pad_width() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_WIDTH, 0);
  }
  int64_t output_pad_height() const {
    return GetField<int64_t>(VT_OUTPUT_PAD_HEIGHT, 0);
  }
  int64_t groups() const {
    return GetField<int64_t>(VT_GROUPS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_FRONT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BACK, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_PAD_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_GROUPS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ConvTranspose3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ConvTranspose3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ConvTranspose3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ConvTranspose3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ConvTranspose3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ConvTranspose3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ConvTranspose3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ConvTranspose3dBuilder {
  typedef ConvTranspose3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stride_depth(int64_t stride_depth) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_STRIDE_DEPTH, stride_depth, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_front(int64_t pad_front) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_FRONT, pad_front, 0);
  }
  void add_pad_back(int64_t pad_back) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_BACK, pad_back, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_depth(int64_t dilation_depth) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_DILATION_DEPTH, dilation_depth, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_output_pad_depth(int64_t output_pad_depth) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_OUTPUT_PAD_DEPTH, output_pad_depth, 0);
  }
  void add_output_pad_width(int64_t output_pad_width) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_OUTPUT_PAD_WIDTH, output_pad_width, 0);
  }
  void add_output_pad_height(int64_t output_pad_height) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_OUTPUT_PAD_HEIGHT, output_pad_height, 0);
  }
  void add_groups(int64_t groups) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_GROUPS, groups, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ConvTranspose3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ConvTranspose3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ConvTranspose3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ConvTranspose3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ConvTranspose3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ConvTranspose3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ConvTranspose3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ConvTranspose3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ConvTranspose3d::VT_TAGS, tags);
  }
  explicit ConvTranspose3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConvTranspose3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConvTranspose3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConvTranspose3d> CreateConvTranspose3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t output_pad_depth = 0,
    int64_t output_pad_width = 0,
    int64_t output_pad_height = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ConvTranspose3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_groups(groups);
  builder_.add_output_pad_height(output_pad_height);
  builder_.add_output_pad_width(output_pad_width);
  builder_.add_output_pad_depth(output_pad_depth);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_dilation_depth(dilation_depth);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_pad_back(pad_back);
  builder_.add_pad_front(pad_front);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_stride_depth(stride_depth);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConvTranspose3d> CreateConvTranspose3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t output_pad_depth = 0,
    int64_t output_pad_width = 0,
    int64_t output_pad_height = 0,
    int64_t groups = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateConvTranspose3d(
      _fbb,
      stride_depth,
      stride_width,
      stride_height,
      pad_front,
      pad_back,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_depth,
      dilation_width,
      dilation_height,
      output_pad_depth,
      output_pad_width,
      output_pad_height,
      groups,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Copy FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CopyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Copy::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Copy::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Copy::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Copy::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Copy::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Copy::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Copy::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct CopyBuilder {
  typedef Copy Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Copy::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Copy::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Copy::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Copy::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Copy::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Copy::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Copy::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Copy::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Copy::VT_TAGS, tags);
  }
  explicit CopyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Copy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Copy>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Copy> CreateCopy(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  CopyBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Copy> CreateCopyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateCopy(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Cos FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Cos::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Cos::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Cos::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Cos::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Cos::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Cos::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Cos::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct CosBuilder {
  typedef Cos Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Cos::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Cos::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Cos::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Cos::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Cos::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Cos::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Cos::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Cos::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Cos::VT_TAGS, tags);
  }
  explicit CosBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Cos> CreateCos(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  CosBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Cos> CreateCosDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateCos(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Cosh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CoshBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Cosh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Cosh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Cosh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Cosh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Cosh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Cosh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Cosh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct CoshBuilder {
  typedef Cosh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Cosh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Cosh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Cosh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Cosh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Cosh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Cosh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Cosh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Cosh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Cosh::VT_TAGS, tags);
  }
  explicit CoshBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Cosh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Cosh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Cosh> CreateCosh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  CoshBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Cosh> CreateCoshDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateCosh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct CustomTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomTargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CustomTargetBuilder {
  typedef CustomTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit CustomTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomTarget> CreateCustomTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  CustomTargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Data FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE_TYPE = 4,
    VT_DTYPE = 6,
    VT_MTYPE_TYPE = 8,
    VT_MTYPE = 10
  };
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *Data::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *Data::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *Data::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *Data::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *Data::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *Data::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *Data::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *Data::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *Data::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *Data::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *Data::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *Data::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *Data::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *Data::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *Data::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *Data::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct DataBuilder {
  typedef Data Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(Data::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(Data::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(Data::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(Data::VT_MTYPE, mtype);
  }
  explicit DataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Data>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Data> CreateData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  DataBuilder builder_(_fbb);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  return builder_.Finish();
}

struct DataType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataTypeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DataTypeBuilder {
  typedef DataType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit DataTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataType> CreateDataType(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  DataTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Div FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DivBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUNDING_MODE = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::String *rounding_mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROUNDING_MODE);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUNDING_MODE) &&
           verifier.VerifyString(rounding_mode()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Div::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Div::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Div::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Div::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Div::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Div::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Div::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct DivBuilder {
  typedef Div Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rounding_mode(::flatbuffers::Offset<::flatbuffers::String> rounding_mode) {
    fbb_.AddOffset(Div::VT_ROUNDING_MODE, rounding_mode);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Div::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Div::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Div::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Div::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Div::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Div::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Div::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Div::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Div::VT_TAGS, tags);
  }
  explicit DivBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Div> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Div>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Div> CreateDiv(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> rounding_mode = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  DivBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_rounding_mode(rounding_mode);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Div> CreateDivDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *rounding_mode = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto rounding_mode__ = rounding_mode ? _fbb.CreateString(rounding_mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateDiv(
      _fbb,
      rounding_mode__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct DivideScalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DivideScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIVISOR = 4,
    VT_ROUNDING_MODE = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  float divisor() const {
    return GetField<float>(VT_DIVISOR, 0.0f);
  }
  const ::flatbuffers::String *rounding_mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROUNDING_MODE);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DIVISOR, 4) &&
           VerifyOffset(verifier, VT_ROUNDING_MODE) &&
           verifier.VerifyString(rounding_mode()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *DivideScalar::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *DivideScalar::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *DivideScalar::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *DivideScalar::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *DivideScalar::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *DivideScalar::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *DivideScalar::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct DivideScalarBuilder {
  typedef DivideScalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_divisor(float divisor) {
    fbb_.AddElement<float>(DivideScalar::VT_DIVISOR, divisor, 0.0f);
  }
  void add_rounding_mode(::flatbuffers::Offset<::flatbuffers::String> rounding_mode) {
    fbb_.AddOffset(DivideScalar::VT_ROUNDING_MODE, rounding_mode);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(DivideScalar::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DivideScalar::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(DivideScalar::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(DivideScalar::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(DivideScalar::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(DivideScalar::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(DivideScalar::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(DivideScalar::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(DivideScalar::VT_TAGS, tags);
  }
  explicit DivideScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DivideScalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DivideScalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DivideScalar> CreateDivideScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float divisor = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> rounding_mode = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  DivideScalarBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_rounding_mode(rounding_mode);
  builder_.add_divisor(divisor);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DivideScalar> CreateDivideScalarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float divisor = 0.0f,
    const char *rounding_mode = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto rounding_mode__ = rounding_mode ? _fbb.CreateString(rounding_mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateDivideScalar(
      _fbb,
      divisor,
      rounding_mode__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ELU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ELUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ELU::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ELU::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ELU::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ELU::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ELU::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ELU::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ELU::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ELUBuilder {
  typedef ELU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ELU::VT_ALPHA, alpha, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ELU::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ELU::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ELU::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ELU::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ELU::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ELU::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ELU::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ELU::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ELU::VT_TAGS, tags);
  }
  explicit ELUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ELU> CreateELU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ELUBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_alpha(alpha);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ELU> CreateELUDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateELU(
      _fbb,
      alpha,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Einsum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EinsumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EQUATION = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::String *equation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EQUATION);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EQUATION) &&
           verifier.VerifyString(equation()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Einsum::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Einsum::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Einsum::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Einsum::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Einsum::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Einsum::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Einsum::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct EinsumBuilder {
  typedef Einsum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_equation(::flatbuffers::Offset<::flatbuffers::String> equation) {
    fbb_.AddOffset(Einsum::VT_EQUATION, equation);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Einsum::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Einsum::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Einsum::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Einsum::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Einsum::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Einsum::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Einsum::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Einsum::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Einsum::VT_TAGS, tags);
  }
  explicit EinsumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Einsum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Einsum>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Einsum> CreateEinsum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> equation = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  EinsumBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_equation(equation);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Einsum> CreateEinsumDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *equation = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto equation__ = equation ? _fbb.CreateString(equation) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateEinsum(
      _fbb,
      equation__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Equal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EqualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Equal::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Equal::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Equal::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Equal::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Equal::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Equal::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Equal::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct EqualBuilder {
  typedef Equal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Equal::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Equal::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Equal::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Equal::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Equal::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Equal::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Equal::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Equal::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Equal::VT_TAGS, tags);
  }
  explicit EqualBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Equal> CreateEqual(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  EqualBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Equal> CreateEqualDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateEqual(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ExpQuantizedScale FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpQuantizedScaleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M = 4,
    VT_EXP = 6,
    VT_ORIGIN_SCALE = 8
  };
  int64_t m() const {
    return GetField<int64_t>(VT_M, 0);
  }
  int64_t exp() const {
    return GetField<int64_t>(VT_EXP, 0);
  }
  float origin_scale() const {
    return GetField<float>(VT_ORIGIN_SCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_M, 8) &&
           VerifyField<int64_t>(verifier, VT_EXP, 8) &&
           VerifyField<float>(verifier, VT_ORIGIN_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct ExpQuantizedScaleBuilder {
  typedef ExpQuantizedScale Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m(int64_t m) {
    fbb_.AddElement<int64_t>(ExpQuantizedScale::VT_M, m, 0);
  }
  void add_exp(int64_t exp) {
    fbb_.AddElement<int64_t>(ExpQuantizedScale::VT_EXP, exp, 0);
  }
  void add_origin_scale(float origin_scale) {
    fbb_.AddElement<float>(ExpQuantizedScale::VT_ORIGIN_SCALE, origin_scale, 0.0f);
  }
  explicit ExpQuantizedScaleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpQuantizedScale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpQuantizedScale>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpQuantizedScale> CreateExpQuantizedScale(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t m = 0,
    int64_t exp = 0,
    float origin_scale = 0.0f) {
  ExpQuantizedScaleBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_m(m);
  builder_.add_origin_scale(origin_scale);
  return builder_.Finish();
}

struct ExpQuantizedScaleArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpQuantizedScaleArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M = 4,
    VT_EXP = 6,
    VT_AXIS = 8,
    VT_ORIGIN_SCALE = 10
  };
  const ::flatbuffers::Vector<int64_t> *m() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_M);
  }
  const ::flatbuffers::Vector<int64_t> *exp() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXP);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const ::flatbuffers::Vector<float> *origin_scale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ORIGIN_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M) &&
           verifier.VerifyVector(m()) &&
           VerifyOffset(verifier, VT_EXP) &&
           verifier.VerifyVector(exp()) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyOffset(verifier, VT_ORIGIN_SCALE) &&
           verifier.VerifyVector(origin_scale()) &&
           verifier.EndTable();
  }
};

struct ExpQuantizedScaleArrayBuilder {
  typedef ExpQuantizedScaleArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> m) {
    fbb_.AddOffset(ExpQuantizedScaleArray::VT_M, m);
  }
  void add_exp(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> exp) {
    fbb_.AddOffset(ExpQuantizedScaleArray::VT_EXP, exp);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ExpQuantizedScaleArray::VT_AXIS, axis, 0);
  }
  void add_origin_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> origin_scale) {
    fbb_.AddOffset(ExpQuantizedScaleArray::VT_ORIGIN_SCALE, origin_scale);
  }
  explicit ExpQuantizedScaleArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpQuantizedScaleArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpQuantizedScaleArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpQuantizedScaleArray> CreateExpQuantizedScaleArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> m = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> exp = 0,
    int64_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> origin_scale = 0) {
  ExpQuantizedScaleArrayBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_origin_scale(origin_scale);
  builder_.add_exp(exp);
  builder_.add_m(m);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ExpQuantizedScaleArray> CreateExpQuantizedScaleArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *m = nullptr,
    const std::vector<int64_t> *exp = nullptr,
    int64_t axis = 0,
    const std::vector<float> *origin_scale = nullptr) {
  auto m__ = m ? _fbb.CreateVector<int64_t>(*m) : 0;
  auto exp__ = exp ? _fbb.CreateVector<int64_t>(*exp) : 0;
  auto origin_scale__ = origin_scale ? _fbb.CreateVector<float>(*origin_scale) : 0;
  return fbs::CreateExpQuantizedScaleArray(
      _fbb,
      m__,
      exp__,
      axis,
      origin_scale__);
}

struct Expand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZES = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::Vector<int64_t> *sizes() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SIZES);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIZES) &&
           verifier.VerifyVector(sizes()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Expand::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Expand::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Expand::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Expand::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Expand::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Expand::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Expand::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ExpandBuilder {
  typedef Expand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sizes(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> sizes) {
    fbb_.AddOffset(Expand::VT_SIZES, sizes);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Expand::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Expand::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Expand::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Expand::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Expand::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Expand::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Expand::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Expand::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Expand::VT_TAGS, tags);
  }
  explicit ExpandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Expand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Expand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Expand> CreateExpand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> sizes = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ExpandBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_sizes(sizes);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Expand> CreateExpandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *sizes = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto sizes__ = sizes ? _fbb.CreateVector<int64_t>(*sizes) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateExpand(
      _fbb,
      sizes__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ExternalMem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExternalMemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4
  };
  uint64_t addr() const {
    return GetField<uint64_t>(VT_ADDR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDR, 8) &&
           verifier.EndTable();
  }
};

struct ExternalMemBuilder {
  typedef ExternalMem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_addr(uint64_t addr) {
    fbb_.AddElement<uint64_t>(ExternalMem::VT_ADDR, addr, 0);
  }
  explicit ExternalMemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExternalMem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExternalMem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExternalMem> CreateExternalMem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t addr = 0) {
  ExternalMemBuilder builder_(_fbb);
  builder_.add_addr(addr);
  return builder_.Finish();
}

struct FPGATarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FPGATargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FPGATargetBuilder {
  typedef FPGATarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FPGATargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FPGATarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FPGATarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FPGATarget> CreateFPGATarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FPGATargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloatImm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatImmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DTYPE_TYPE = 6,
    VT_DTYPE = 8,
    VT_MTYPE_TYPE = 10,
    VT_MTYPE = 12
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *FloatImm::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *FloatImm::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *FloatImm::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *FloatImm::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *FloatImm::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *FloatImm::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *FloatImm::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *FloatImm::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *FloatImm::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *FloatImm::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *FloatImm::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *FloatImm::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *FloatImm::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *FloatImm::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *FloatImm::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *FloatImm::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct FloatImmBuilder {
  typedef FloatImm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FloatImm::VT_VALUE, value, 0.0f);
  }
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(FloatImm::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(FloatImm::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(FloatImm::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(FloatImm::VT_MTYPE, mtype);
  }
  explicit FloatImmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatImm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatImm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatImm> CreateFloatImm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  FloatImmBuilder builder_(_fbb);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_value(value);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  return builder_.Finish();
}

struct FloatType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMAX = 4,
    VT_EMIN = 6,
    VT_PRECISION = 8,
    VT_FBITS = 10
  };
  int64_t emax() const {
    return GetField<int64_t>(VT_EMAX, 0);
  }
  int64_t emin() const {
    return GetField<int64_t>(VT_EMIN, 0);
  }
  uint64_t precision() const {
    return GetField<uint64_t>(VT_PRECISION, 0);
  }
  uint64_t fbits() const {
    return GetField<uint64_t>(VT_FBITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_EMAX, 8) &&
           VerifyField<int64_t>(verifier, VT_EMIN, 8) &&
           VerifyField<uint64_t>(verifier, VT_PRECISION, 8) &&
           VerifyField<uint64_t>(verifier, VT_FBITS, 8) &&
           verifier.EndTable();
  }
};

struct FloatTypeBuilder {
  typedef FloatType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_emax(int64_t emax) {
    fbb_.AddElement<int64_t>(FloatType::VT_EMAX, emax, 0);
  }
  void add_emin(int64_t emin) {
    fbb_.AddElement<int64_t>(FloatType::VT_EMIN, emin, 0);
  }
  void add_precision(uint64_t precision) {
    fbb_.AddElement<uint64_t>(FloatType::VT_PRECISION, precision, 0);
  }
  void add_fbits(uint64_t fbits) {
    fbb_.AddElement<uint64_t>(FloatType::VT_FBITS, fbits, 0);
  }
  explicit FloatTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatType> CreateFloatType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t emax = 0,
    int64_t emin = 0,
    uint64_t precision = 0,
    uint64_t fbits = 0) {
  FloatTypeBuilder builder_(_fbb);
  builder_.add_fbits(fbits);
  builder_.add_precision(precision);
  builder_.add_emin(emin);
  builder_.add_emax(emax);
  return builder_.Finish();
}

struct GELU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GELUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *GELU::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *GELU::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *GELU::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *GELU::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *GELU::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *GELU::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *GELU::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct GELUBuilder {
  typedef GELU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(GELU::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GELU::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(GELU::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(GELU::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(GELU::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(GELU::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(GELU::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(GELU::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(GELU::VT_TAGS, tags);
  }
  explicit GELUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GELU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GELU> CreateGELU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  GELUBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GELU> CreateGELUDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateGELU(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Greater FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GreaterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Greater::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Greater::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Greater::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Greater::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Greater::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Greater::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Greater::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct GreaterBuilder {
  typedef Greater Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Greater::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Greater::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Greater::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Greater::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Greater::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Greater::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Greater::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Greater::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Greater::VT_TAGS, tags);
  }
  explicit GreaterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Greater> CreateGreater(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  GreaterBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Greater> CreateGreaterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateGreater(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GreaterEqualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *GreaterEqual::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *GreaterEqual::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *GreaterEqual::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *GreaterEqual::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *GreaterEqual::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *GreaterEqual::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *GreaterEqual::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct GreaterEqualBuilder {
  typedef GreaterEqual Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(GreaterEqual::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GreaterEqual::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(GreaterEqual::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(GreaterEqual::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(GreaterEqual::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(GreaterEqual::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(GreaterEqual::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(GreaterEqual::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(GreaterEqual::VT_TAGS, tags);
  }
  explicit GreaterEqualBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  GreaterEqualBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GreaterEqual> CreateGreaterEqualDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateGreaterEqual(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct HardOp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTR = 4,
    VT_PARAMS = 6,
    VT_ORIGIN_OPS_ID = 8,
    VT_DEVICE_INFO = 10,
    VT_LAYER_COUNT = 12,
    VT_SUB_HARD_OPS = 14,
    VT_OP_ID = 16,
    VT_NAME = 18,
    VT_INPUTS_TYPE = 20,
    VT_INPUTS = 22,
    VT_OUTPUTS_TYPE = 24,
    VT_OUTPUTS = 26,
    VT_COMPILE_TARGET_TYPE = 28,
    VT_COMPILE_TARGET = 30,
    VT_TAGS = 32
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>> *instr() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>> *>(VT_INSTR);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>> *params() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>> *>(VT_PARAMS);
  }
  const ::flatbuffers::Vector<int64_t> *origin_ops_id() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ORIGIN_OPS_ID);
  }
  const ::flatbuffers::String *device_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEVICE_INFO);
  }
  int64_t layer_count() const {
    return GetField<int64_t>(VT_LAYER_COUNT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::HardOp>> *sub_hard_ops() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::HardOp>> *>(VT_SUB_HARD_OPS);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTR) &&
           verifier.VerifyVector(instr()) &&
           verifier.VerifyVectorOfTables(instr()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           VerifyOffset(verifier, VT_ORIGIN_OPS_ID) &&
           verifier.VerifyVector(origin_ops_id()) &&
           VerifyOffset(verifier, VT_DEVICE_INFO) &&
           verifier.VerifyString(device_info()) &&
           VerifyField<int64_t>(verifier, VT_LAYER_COUNT, 8) &&
           VerifyOffset(verifier, VT_SUB_HARD_OPS) &&
           verifier.VerifyVector(sub_hard_ops()) &&
           verifier.VerifyVectorOfTables(sub_hard_ops()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *HardOp::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *HardOp::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *HardOp::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *HardOp::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *HardOp::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *HardOp::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *HardOp::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct HardOpBuilder {
  typedef HardOp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instr(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>>> instr) {
    fbb_.AddOffset(HardOp::VT_INSTR, instr);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>>> params) {
    fbb_.AddOffset(HardOp::VT_PARAMS, params);
  }
  void add_origin_ops_id(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> origin_ops_id) {
    fbb_.AddOffset(HardOp::VT_ORIGIN_OPS_ID, origin_ops_id);
  }
  void add_device_info(::flatbuffers::Offset<::flatbuffers::String> device_info) {
    fbb_.AddOffset(HardOp::VT_DEVICE_INFO, device_info);
  }
  void add_layer_count(int64_t layer_count) {
    fbb_.AddElement<int64_t>(HardOp::VT_LAYER_COUNT, layer_count, 0);
  }
  void add_sub_hard_ops(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::HardOp>>> sub_hard_ops) {
    fbb_.AddOffset(HardOp::VT_SUB_HARD_OPS, sub_hard_ops);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(HardOp::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(HardOp::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(HardOp::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(HardOp::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(HardOp::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(HardOp::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(HardOp::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(HardOp::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(HardOp::VT_TAGS, tags);
  }
  explicit HardOpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HardOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HardOp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HardOp> CreateHardOp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>>> instr = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::Params>>> params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> origin_ops_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> device_info = 0,
    int64_t layer_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::HardOp>>> sub_hard_ops = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  HardOpBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_layer_count(layer_count);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_sub_hard_ops(sub_hard_ops);
  builder_.add_device_info(device_info);
  builder_.add_origin_ops_id(origin_ops_id);
  builder_.add_params(params);
  builder_.add_instr(instr);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HardOp> CreateHardOpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fbs::Params>> *instr = nullptr,
    const std::vector<::flatbuffers::Offset<fbs::Params>> *params = nullptr,
    const std::vector<int64_t> *origin_ops_id = nullptr,
    const char *device_info = nullptr,
    int64_t layer_count = 0,
    const std::vector<::flatbuffers::Offset<fbs::HardOp>> *sub_hard_ops = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto instr__ = instr ? _fbb.CreateVector<::flatbuffers::Offset<fbs::Params>>(*instr) : 0;
  auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<fbs::Params>>(*params) : 0;
  auto origin_ops_id__ = origin_ops_id ? _fbb.CreateVector<int64_t>(*origin_ops_id) : 0;
  auto device_info__ = device_info ? _fbb.CreateString(device_info) : 0;
  auto sub_hard_ops__ = sub_hard_ops ? _fbb.CreateVector<::flatbuffers::Offset<fbs::HardOp>>(*sub_hard_ops) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateHardOp(
      _fbb,
      instr__,
      params__,
      origin_ops_id__,
      device_info__,
      layer_count,
      sub_hard_ops__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Hardshrink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardshrinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAMBDA = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  float lambda() const {
    return GetField<float>(VT_LAMBDA, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LAMBDA, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Hardshrink::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Hardshrink::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Hardshrink::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Hardshrink::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Hardshrink::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Hardshrink::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Hardshrink::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct HardshrinkBuilder {
  typedef Hardshrink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lambda(float lambda) {
    fbb_.AddElement<float>(Hardshrink::VT_LAMBDA, lambda, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Hardshrink::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Hardshrink::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Hardshrink::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Hardshrink::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Hardshrink::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Hardshrink::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Hardshrink::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Hardshrink::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Hardshrink::VT_TAGS, tags);
  }
  explicit HardshrinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Hardshrink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Hardshrink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Hardshrink> CreateHardshrink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lambda = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  HardshrinkBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_lambda(lambda);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Hardshrink> CreateHardshrinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lambda = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateHardshrink(
      _fbb,
      lambda,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Hardsigmoid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardsigmoidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Hardsigmoid::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Hardsigmoid::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Hardsigmoid::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Hardsigmoid::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Hardsigmoid::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Hardsigmoid::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Hardsigmoid::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct HardsigmoidBuilder {
  typedef Hardsigmoid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Hardsigmoid::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(Hardsigmoid::VT_BETA, beta, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Hardsigmoid::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Hardsigmoid::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Hardsigmoid::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Hardsigmoid::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Hardsigmoid::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Hardsigmoid::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Hardsigmoid::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Hardsigmoid::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Hardsigmoid::VT_TAGS, tags);
  }
  explicit HardsigmoidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Hardsigmoid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Hardsigmoid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Hardsigmoid> CreateHardsigmoid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float beta = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  HardsigmoidBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Hardsigmoid> CreateHardsigmoidDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float beta = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateHardsigmoid(
      _fbb,
      alpha,
      beta,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Hardswish FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardswishBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Hardswish::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Hardswish::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Hardswish::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Hardswish::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Hardswish::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Hardswish::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Hardswish::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct HardswishBuilder {
  typedef Hardswish Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Hardswish::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Hardswish::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Hardswish::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Hardswish::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Hardswish::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Hardswish::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Hardswish::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Hardswish::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Hardswish::VT_TAGS, tags);
  }
  explicit HardswishBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Hardswish> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Hardswish>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Hardswish> CreateHardswish(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  HardswishBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Hardswish> CreateHardswishDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateHardswish(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Hardtanh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HardtanhBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_VAL = 4,
    VT_MAX_VAL = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, 0.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN_VAL, 4) &&
           VerifyField<float>(verifier, VT_MAX_VAL, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Hardtanh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Hardtanh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Hardtanh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Hardtanh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Hardtanh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Hardtanh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Hardtanh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct HardtanhBuilder {
  typedef Hardtanh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(Hardtanh::VT_MIN_VAL, min_val, 0.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(Hardtanh::VT_MAX_VAL, max_val, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Hardtanh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Hardtanh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Hardtanh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Hardtanh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Hardtanh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Hardtanh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Hardtanh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Hardtanh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Hardtanh::VT_TAGS, tags);
  }
  explicit HardtanhBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Hardtanh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Hardtanh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Hardtanh> CreateHardtanh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float min_val = 0.0f,
    float max_val = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  HardtanhBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Hardtanh> CreateHardtanhDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float min_val = 0.0f,
    float max_val = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateHardtanh(
      _fbb,
      min_val,
      max_val,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct HostMem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HostMemBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HostMemBuilder {
  typedef HostMem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HostMemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HostMem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HostMem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HostMem> CreateHostMem(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HostMemBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HostTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HostTargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HostTargetBuilder {
  typedef HostTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HostTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HostTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HostTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HostTarget> CreateHostTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HostTargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Input FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Input::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Input::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Input::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Input::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Input::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Input::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Input::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct InputBuilder {
  typedef Input Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Input::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Input::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Input::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Input::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Input::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Input::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Input::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Input::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Input::VT_TAGS, tags);
  }
  explicit InputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Input> CreateInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Input> CreateInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateInput(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct InstanceNorm1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstanceNorm1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_GAMMA = 6,
    VT_BETA = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const fbs::Params *gamma() const {
    return GetPointer<const fbs::Params *>(VT_GAMMA);
  }
  const fbs::Params *beta() const {
    return GetPointer<const fbs::Params *>(VT_BETA);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyTable(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyTable(beta()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *InstanceNorm1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *InstanceNorm1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *InstanceNorm1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *InstanceNorm1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *InstanceNorm1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *InstanceNorm1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *InstanceNorm1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct InstanceNorm1dBuilder {
  typedef InstanceNorm1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(InstanceNorm1d::VT_EPS, eps, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<fbs::Params> gamma) {
    fbb_.AddOffset(InstanceNorm1d::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<fbs::Params> beta) {
    fbb_.AddOffset(InstanceNorm1d::VT_BETA, beta);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(InstanceNorm1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(InstanceNorm1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(InstanceNorm1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(InstanceNorm1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(InstanceNorm1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(InstanceNorm1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(InstanceNorm1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(InstanceNorm1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(InstanceNorm1d::VT_TAGS, tags);
  }
  explicit InstanceNorm1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstanceNorm1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstanceNorm1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstanceNorm1d> CreateInstanceNorm1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  InstanceNorm1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_eps(eps);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstanceNorm1d> CreateInstanceNorm1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateInstanceNorm1d(
      _fbb,
      eps,
      gamma,
      beta,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct InstanceNorm2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstanceNorm2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_GAMMA = 6,
    VT_BETA = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const fbs::Params *gamma() const {
    return GetPointer<const fbs::Params *>(VT_GAMMA);
  }
  const fbs::Params *beta() const {
    return GetPointer<const fbs::Params *>(VT_BETA);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyTable(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyTable(beta()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *InstanceNorm2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *InstanceNorm2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *InstanceNorm2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *InstanceNorm2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *InstanceNorm2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *InstanceNorm2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *InstanceNorm2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct InstanceNorm2dBuilder {
  typedef InstanceNorm2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(InstanceNorm2d::VT_EPS, eps, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<fbs::Params> gamma) {
    fbb_.AddOffset(InstanceNorm2d::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<fbs::Params> beta) {
    fbb_.AddOffset(InstanceNorm2d::VT_BETA, beta);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(InstanceNorm2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(InstanceNorm2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(InstanceNorm2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(InstanceNorm2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(InstanceNorm2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(InstanceNorm2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(InstanceNorm2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(InstanceNorm2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(InstanceNorm2d::VT_TAGS, tags);
  }
  explicit InstanceNorm2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstanceNorm2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstanceNorm2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstanceNorm2d> CreateInstanceNorm2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  InstanceNorm2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_eps(eps);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstanceNorm2d> CreateInstanceNorm2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateInstanceNorm2d(
      _fbb,
      eps,
      gamma,
      beta,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct InstanceNorm3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstanceNorm3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_GAMMA = 6,
    VT_BETA = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const fbs::Params *gamma() const {
    return GetPointer<const fbs::Params *>(VT_GAMMA);
  }
  const fbs::Params *beta() const {
    return GetPointer<const fbs::Params *>(VT_BETA);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyTable(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyTable(beta()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *InstanceNorm3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *InstanceNorm3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *InstanceNorm3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *InstanceNorm3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *InstanceNorm3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *InstanceNorm3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *InstanceNorm3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct InstanceNorm3dBuilder {
  typedef InstanceNorm3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(InstanceNorm3d::VT_EPS, eps, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<fbs::Params> gamma) {
    fbb_.AddOffset(InstanceNorm3d::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<fbs::Params> beta) {
    fbb_.AddOffset(InstanceNorm3d::VT_BETA, beta);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(InstanceNorm3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(InstanceNorm3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(InstanceNorm3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(InstanceNorm3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(InstanceNorm3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(InstanceNorm3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(InstanceNorm3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(InstanceNorm3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(InstanceNorm3d::VT_TAGS, tags);
  }
  explicit InstanceNorm3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstanceNorm3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstanceNorm3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InstanceNorm3d> CreateInstanceNorm3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  InstanceNorm3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_eps(eps);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstanceNorm3d> CreateInstanceNorm3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateInstanceNorm3d(
      _fbb,
      eps,
      gamma,
      beta,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct IntImm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntImmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DTYPE_TYPE = 6,
    VT_DTYPE = 8,
    VT_MTYPE_TYPE = 10,
    VT_MTYPE = 12
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *IntImm::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *IntImm::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *IntImm::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *IntImm::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *IntImm::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *IntImm::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *IntImm::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *IntImm::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *IntImm::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *IntImm::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *IntImm::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *IntImm::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *IntImm::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *IntImm::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *IntImm::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *IntImm::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct IntImmBuilder {
  typedef IntImm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(IntImm::VT_VALUE, value, 0);
  }
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(IntImm::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(IntImm::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(IntImm::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(IntImm::VT_MTYPE, mtype);
  }
  explicit IntImmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntImm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntImm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntImm> CreateIntImm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  IntImmBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  return builder_.Finish();
}

struct IntegerType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGN = 4,
    VT_IBITS = 6
  };
  bool sign() const {
    return GetField<uint8_t>(VT_SIGN, 0) != 0;
  }
  uint64_t ibits() const {
    return GetField<uint64_t>(VT_IBITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SIGN, 1) &&
           VerifyField<uint64_t>(verifier, VT_IBITS, 8) &&
           verifier.EndTable();
  }
};

struct IntegerTypeBuilder {
  typedef IntegerType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sign(bool sign) {
    fbb_.AddElement<uint8_t>(IntegerType::VT_SIGN, static_cast<uint8_t>(sign), 0);
  }
  void add_ibits(uint64_t ibits) {
    fbb_.AddElement<uint64_t>(IntegerType::VT_IBITS, ibits, 0);
  }
  explicit IntegerTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerType> CreateIntegerType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool sign = false,
    uint64_t ibits = 0) {
  IntegerTypeBuilder builder_(_fbb);
  builder_.add_ibits(ibits);
  builder_.add_sign(sign);
  return builder_.Finish();
}

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPS = 6,
    VT_GAMMA = 8,
    VT_BETA = 10,
    VT_OP_ID = 12,
    VT_NAME = 14,
    VT_INPUTS_TYPE = 16,
    VT_INPUTS = 18,
    VT_OUTPUTS_TYPE = 20,
    VT_OUTPUTS = 22,
    VT_COMPILE_TARGET_TYPE = 24,
    VT_COMPILE_TARGET = 26,
    VT_TAGS = 28
  };
  const ::flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const fbs::Params *gamma() const {
    return GetPointer<const fbs::Params *>(VT_GAMMA);
  }
  const fbs::Params *beta() const {
    return GetPointer<const fbs::Params *>(VT_BETA);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyTable(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyTable(beta()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *LayerNorm::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *LayerNorm::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *LayerNorm::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *LayerNorm::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *LayerNorm::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *LayerNorm::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *LayerNorm::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LayerNormBuilder {
  typedef LayerNorm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(LayerNorm::VT_AXIS, axis);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(LayerNorm::VT_EPS, eps, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<fbs::Params> gamma) {
    fbb_.AddOffset(LayerNorm::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<fbs::Params> beta) {
    fbb_.AddOffset(LayerNorm::VT_BETA, beta);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(LayerNorm::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LayerNorm::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(LayerNorm::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(LayerNorm::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(LayerNorm::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(LayerNorm::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(LayerNorm::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(LayerNorm::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(LayerNorm::VT_TAGS, tags);
  }
  explicit LayerNormBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis = 0,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_eps(eps);
  builder_.add_axis(axis);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LayerNorm> CreateLayerNormDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr,
    float eps = 0.0f,
    ::flatbuffers::Offset<fbs::Params> gamma = 0,
    ::flatbuffers::Offset<fbs::Params> beta = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLayerNorm(
      _fbb,
      axis__,
      eps,
      gamma,
      beta,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Layout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS_NAMES_TYPE = 4,
    VT_AXIS_NAMES = 6
  };
  const ::flatbuffers::Vector<uint8_t> *axis_names_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_AXIS_NAMES_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *axis_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_AXIS_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS_NAMES_TYPE) &&
           verifier.VerifyVector(axis_names_type()) &&
           VerifyOffset(verifier, VT_AXIS_NAMES) &&
           verifier.VerifyVector(axis_names()) &&
           VerifyAxisName_boxVector(verifier, axis_names(), axis_names_type()) &&
           verifier.EndTable();
  }
};

struct LayoutBuilder {
  typedef Layout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis_names_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> axis_names_type) {
    fbb_.AddOffset(Layout::VT_AXIS_NAMES_TYPE, axis_names_type);
  }
  void add_axis_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> axis_names) {
    fbb_.AddOffset(Layout::VT_AXIS_NAMES, axis_names);
  }
  explicit LayoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Layout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Layout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Layout> CreateLayout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> axis_names_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> axis_names = 0) {
  LayoutBuilder builder_(_fbb);
  builder_.add_axis_names(axis_names);
  builder_.add_axis_names_type(axis_names_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Layout> CreateLayoutDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *axis_names_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *axis_names = nullptr) {
  auto axis_names_type__ = axis_names_type ? _fbb.CreateVector<uint8_t>(*axis_names_type) : 0;
  auto axis_names__ = axis_names ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*axis_names) : 0;
  return fbs::CreateLayout(
      _fbb,
      axis_names_type__,
      axis_names__);
}

struct Less FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Less::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Less::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Less::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Less::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Less::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Less::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Less::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LessBuilder {
  typedef Less Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Less::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Less::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Less::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Less::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Less::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Less::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Less::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Less::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Less::VT_TAGS, tags);
  }
  explicit LessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Less> CreateLess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LessBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Less> CreateLessDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLess(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct LessEqual FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LessEqualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *LessEqual::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *LessEqual::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *LessEqual::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *LessEqual::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *LessEqual::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *LessEqual::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *LessEqual::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LessEqualBuilder {
  typedef LessEqual Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(LessEqual::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LessEqual::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(LessEqual::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(LessEqual::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(LessEqual::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(LessEqual::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(LessEqual::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(LessEqual::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(LessEqual::VT_TAGS, tags);
  }
  explicit LessEqualBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LessEqual> CreateLessEqual(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LessEqualBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LessEqual> CreateLessEqualDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLessEqual(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Log::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Log::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Log::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Log::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Log::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Log::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Log::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LogBuilder {
  typedef Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Log::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Log::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Log::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Log::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Log::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Log::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Log::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Log::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Log::VT_TAGS, tags);
  }
  explicit LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Log> CreateLog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Log> CreateLogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLog(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct LogSigmoid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogSigmoidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *LogSigmoid::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *LogSigmoid::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *LogSigmoid::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *LogSigmoid::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *LogSigmoid::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *LogSigmoid::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *LogSigmoid::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LogSigmoidBuilder {
  typedef LogSigmoid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(LogSigmoid::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LogSigmoid::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(LogSigmoid::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(LogSigmoid::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(LogSigmoid::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(LogSigmoid::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(LogSigmoid::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(LogSigmoid::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(LogSigmoid::VT_TAGS, tags);
  }
  explicit LogSigmoidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogSigmoid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogSigmoid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogSigmoid> CreateLogSigmoid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LogSigmoidBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogSigmoid> CreateLogSigmoidDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLogSigmoid(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct LogSoftmax FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogSoftmaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *LogSoftmax::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *LogSoftmax::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *LogSoftmax::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *LogSoftmax::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *LogSoftmax::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *LogSoftmax::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *LogSoftmax::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct LogSoftmaxBuilder {
  typedef LogSoftmax Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(LogSoftmax::VT_AXIS, axis, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(LogSoftmax::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LogSoftmax::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(LogSoftmax::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(LogSoftmax::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(LogSoftmax::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(LogSoftmax::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(LogSoftmax::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(LogSoftmax::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(LogSoftmax::VT_TAGS, tags);
  }
  explicit LogSoftmaxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogSoftmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogSoftmax>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  LogSoftmaxBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_axis(axis);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogSoftmax> CreateLogSoftmaxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateLogSoftmax(
      _fbb,
      axis,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Matmul FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatmulBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUT_SCALE_TYPE = 4,
    VT_CUT_SCALE = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Matmul::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Matmul::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Matmul::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Matmul::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Matmul::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Matmul::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Matmul::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Matmul::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Matmul::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MatmulBuilder {
  typedef Matmul Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Matmul::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Matmul::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Matmul::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Matmul::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Matmul::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Matmul::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Matmul::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Matmul::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Matmul::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Matmul::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Matmul::VT_TAGS, tags);
  }
  explicit MatmulBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Matmul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Matmul>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Matmul> CreateMatmul(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MatmulBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Matmul> CreateMatmulDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMatmul(
      _fbb,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Max FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::IntImm *dim() const {
    return GetPointer<const fbs::IntImm *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyTable(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Max::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Max::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Max::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Max::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Max::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Max::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Max::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MaxBuilder {
  typedef Max Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<fbs::IntImm> dim) {
    fbb_.AddOffset(Max::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Max::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Max::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Max::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Max::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Max::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Max::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Max::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Max::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Max::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Max::VT_TAGS, tags);
  }
  explicit MaxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Max> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Max>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Max> CreateMax(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MaxBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Max> CreateMaxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMax(
      _fbb,
      dim,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct MaxPool1d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaxPool1dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_WIDTH = 4,
    VT_STRIDE_WIDTH = 6,
    VT_PAD_LEFT = 8,
    VT_PAD_RIGHT = 10,
    VT_DILATION_WIDTH = 12,
    VT_OP_ID = 14,
    VT_NAME = 16,
    VT_INPUTS_TYPE = 18,
    VT_INPUTS = 20,
    VT_OUTPUTS_TYPE = 22,
    VT_OUTPUTS = 24,
    VT_COMPILE_TARGET_TYPE = 26,
    VT_COMPILE_TARGET = 28,
    VT_TAGS = 30
  };
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *MaxPool1d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *MaxPool1d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *MaxPool1d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *MaxPool1d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *MaxPool1d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *MaxPool1d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *MaxPool1d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MaxPool1dBuilder {
  typedef MaxPool1d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(MaxPool1d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaxPool1d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(MaxPool1d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(MaxPool1d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(MaxPool1d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(MaxPool1d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(MaxPool1d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(MaxPool1d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(MaxPool1d::VT_TAGS, tags);
  }
  explicit MaxPool1dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaxPool1d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaxPool1d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaxPool1d> CreateMaxPool1d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MaxPool1dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_stride_width(stride_width);
  builder_.add_pool_width(pool_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaxPool1d> CreateMaxPool1dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t stride_width = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMaxPool1d(
      _fbb,
      pool_width,
      stride_width,
      pad_left,
      pad_right,
      dilation_width,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct MaxPool2d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaxPool2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_WIDTH = 4,
    VT_POOL_HEIGHT = 6,
    VT_STRIDE_WIDTH = 8,
    VT_STRIDE_HEIGHT = 10,
    VT_PAD_TOP = 12,
    VT_PAD_BOTTOM = 14,
    VT_PAD_LEFT = 16,
    VT_PAD_RIGHT = 18,
    VT_DILATION_WIDTH = 20,
    VT_DILATION_HEIGHT = 22,
    VT_OP_ID = 24,
    VT_NAME = 26,
    VT_INPUTS_TYPE = 28,
    VT_INPUTS = 30,
    VT_OUTPUTS_TYPE = 32,
    VT_OUTPUTS = 34,
    VT_COMPILE_TARGET_TYPE = 36,
    VT_COMPILE_TARGET = 38,
    VT_TAGS = 40
  };
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t pool_height() const {
    return GetField<int64_t>(VT_POOL_HEIGHT, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *MaxPool2d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *MaxPool2d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *MaxPool2d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *MaxPool2d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *MaxPool2d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *MaxPool2d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *MaxPool2d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MaxPool2dBuilder {
  typedef MaxPool2d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_pool_height(int64_t pool_height) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_POOL_HEIGHT, pool_height, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(MaxPool2d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaxPool2d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(MaxPool2d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(MaxPool2d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(MaxPool2d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(MaxPool2d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(MaxPool2d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(MaxPool2d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(MaxPool2d::VT_TAGS, tags);
  }
  explicit MaxPool2dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaxPool2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaxPool2d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaxPool2d> CreateMaxPool2d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MaxPool2dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_pool_height(pool_height);
  builder_.add_pool_width(pool_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaxPool2d> CreateMaxPool2dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMaxPool2d(
      _fbb,
      pool_width,
      pool_height,
      stride_width,
      stride_height,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_width,
      dilation_height,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct MaxPool3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaxPool3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOL_DEPTH = 4,
    VT_POOL_WIDTH = 6,
    VT_POOL_HEIGHT = 8,
    VT_STRIDE_DEPTH = 10,
    VT_STRIDE_WIDTH = 12,
    VT_STRIDE_HEIGHT = 14,
    VT_PAD_FRONT = 16,
    VT_PAD_BACK = 18,
    VT_PAD_TOP = 20,
    VT_PAD_BOTTOM = 22,
    VT_PAD_LEFT = 24,
    VT_PAD_RIGHT = 26,
    VT_DILATION_DEPTH = 28,
    VT_DILATION_WIDTH = 30,
    VT_DILATION_HEIGHT = 32,
    VT_OP_ID = 34,
    VT_NAME = 36,
    VT_INPUTS_TYPE = 38,
    VT_INPUTS = 40,
    VT_OUTPUTS_TYPE = 42,
    VT_OUTPUTS = 44,
    VT_COMPILE_TARGET_TYPE = 46,
    VT_COMPILE_TARGET = 48,
    VT_TAGS = 50
  };
  int64_t pool_depth() const {
    return GetField<int64_t>(VT_POOL_DEPTH, 0);
  }
  int64_t pool_width() const {
    return GetField<int64_t>(VT_POOL_WIDTH, 0);
  }
  int64_t pool_height() const {
    return GetField<int64_t>(VT_POOL_HEIGHT, 0);
  }
  int64_t stride_depth() const {
    return GetField<int64_t>(VT_STRIDE_DEPTH, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_front() const {
    return GetField<int64_t>(VT_PAD_FRONT, 0);
  }
  int64_t pad_back() const {
    return GetField<int64_t>(VT_PAD_BACK, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_depth() const {
    return GetField<int64_t>(VT_DILATION_DEPTH, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOL_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_POOL_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_FRONT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BACK, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_DEPTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *MaxPool3d::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *MaxPool3d::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *MaxPool3d::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *MaxPool3d::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *MaxPool3d::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *MaxPool3d::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *MaxPool3d::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MaxPool3dBuilder {
  typedef MaxPool3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pool_depth(int64_t pool_depth) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_POOL_DEPTH, pool_depth, 0);
  }
  void add_pool_width(int64_t pool_width) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_POOL_WIDTH, pool_width, 0);
  }
  void add_pool_height(int64_t pool_height) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_POOL_HEIGHT, pool_height, 0);
  }
  void add_stride_depth(int64_t stride_depth) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_STRIDE_DEPTH, stride_depth, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_front(int64_t pad_front) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_FRONT, pad_front, 0);
  }
  void add_pad_back(int64_t pad_back) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_BACK, pad_back, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_depth(int64_t dilation_depth) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_DILATION_DEPTH, dilation_depth, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(MaxPool3d::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaxPool3d::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(MaxPool3d::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(MaxPool3d::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(MaxPool3d::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(MaxPool3d::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(MaxPool3d::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(MaxPool3d::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(MaxPool3d::VT_TAGS, tags);
  }
  explicit MaxPool3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaxPool3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaxPool3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MaxPool3d> CreateMaxPool3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_depth = 0,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MaxPool3dBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_dilation_depth(dilation_depth);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_pad_back(pad_back);
  builder_.add_pad_front(pad_front);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_stride_depth(stride_depth);
  builder_.add_pool_height(pool_height);
  builder_.add_pool_width(pool_width);
  builder_.add_pool_depth(pool_depth);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaxPool3d> CreateMaxPool3dDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pool_depth = 0,
    int64_t pool_width = 0,
    int64_t pool_height = 0,
    int64_t stride_depth = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_front = 0,
    int64_t pad_back = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_depth = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMaxPool3d(
      _fbb,
      pool_depth,
      pool_width,
      pool_height,
      stride_depth,
      stride_width,
      stride_height,
      pad_front,
      pad_back,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_depth,
      dilation_width,
      dilation_height,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Maximum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaximumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Maximum::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Maximum::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Maximum::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Maximum::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Maximum::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Maximum::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Maximum::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MaximumBuilder {
  typedef Maximum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Maximum::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Maximum::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Maximum::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Maximum::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Maximum::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Maximum::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Maximum::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Maximum::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Maximum::VT_TAGS, tags);
  }
  explicit MaximumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Maximum> CreateMaximum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MaximumBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Maximum> CreateMaximumDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMaximum(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Mean FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MeanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Mean::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Mean::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Mean::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Mean::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Mean::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Mean::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Mean::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MeanBuilder {
  typedef Mean Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dim) {
    fbb_.AddOffset(Mean::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Mean::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Mean::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Mean::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Mean::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Mean::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Mean::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Mean::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Mean::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Mean::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Mean::VT_TAGS, tags);
  }
  explicit MeanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Mean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Mean>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Mean> CreateMean(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MeanBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Mean> CreateMeanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dim = nullptr,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<int64_t>(*dim) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMean(
      _fbb,
      dim__,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct MemType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemTypeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MemTypeBuilder {
  typedef MemType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MemTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemType> CreateMemType(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MemTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MergedAxisDistr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MergedAxisDistrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MERGED_AXIS = 4,
    VT_VALID_MASK = 6,
    VT_UVALUE = 8
  };
  const ::flatbuffers::Vector<int64_t> *merged_axis() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_MERGED_AXIS);
  }
  const ::flatbuffers::Vector<uint8_t> *valid_mask() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALID_MASK);
  }
  const ::flatbuffers::String *uvalue() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UVALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MERGED_AXIS) &&
           verifier.VerifyVector(merged_axis()) &&
           VerifyOffset(verifier, VT_VALID_MASK) &&
           verifier.VerifyVector(valid_mask()) &&
           VerifyOffset(verifier, VT_UVALUE) &&
           verifier.VerifyString(uvalue()) &&
           verifier.EndTable();
  }
};

struct MergedAxisDistrBuilder {
  typedef MergedAxisDistr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_merged_axis(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> merged_axis) {
    fbb_.AddOffset(MergedAxisDistr::VT_MERGED_AXIS, merged_axis);
  }
  void add_valid_mask(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> valid_mask) {
    fbb_.AddOffset(MergedAxisDistr::VT_VALID_MASK, valid_mask);
  }
  void add_uvalue(::flatbuffers::Offset<::flatbuffers::String> uvalue) {
    fbb_.AddOffset(MergedAxisDistr::VT_UVALUE, uvalue);
  }
  explicit MergedAxisDistrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MergedAxisDistr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MergedAxisDistr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MergedAxisDistr> CreateMergedAxisDistr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> merged_axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> valid_mask = 0,
    ::flatbuffers::Offset<::flatbuffers::String> uvalue = 0) {
  MergedAxisDistrBuilder builder_(_fbb);
  builder_.add_uvalue(uvalue);
  builder_.add_valid_mask(valid_mask);
  builder_.add_merged_axis(merged_axis);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MergedAxisDistr> CreateMergedAxisDistrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *merged_axis = nullptr,
    const std::vector<uint8_t> *valid_mask = nullptr,
    const char *uvalue = nullptr) {
  auto merged_axis__ = merged_axis ? _fbb.CreateVector<int64_t>(*merged_axis) : 0;
  auto valid_mask__ = valid_mask ? _fbb.CreateVector<uint8_t>(*valid_mask) : 0;
  auto uvalue__ = uvalue ? _fbb.CreateString(uvalue) : 0;
  return fbs::CreateMergedAxisDistr(
      _fbb,
      merged_axis__,
      valid_mask__,
      uvalue__);
}

struct Min FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const fbs::IntImm *dim() const {
    return GetPointer<const fbs::IntImm *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyTable(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Min::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Min::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Min::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Min::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Min::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Min::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Min::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MinBuilder {
  typedef Min Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<fbs::IntImm> dim) {
    fbb_.AddOffset(Min::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Min::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Min::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Min::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Min::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Min::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Min::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Min::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Min::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Min::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Min::VT_TAGS, tags);
  }
  explicit MinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Min> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Min>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Min> CreateMin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MinBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Min> CreateMinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::IntImm> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMin(
      _fbb,
      dim,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Minimum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MinimumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Minimum::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Minimum::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Minimum::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Minimum::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Minimum::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Minimum::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Minimum::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MinimumBuilder {
  typedef Minimum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Minimum::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Minimum::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Minimum::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Minimum::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Minimum::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Minimum::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Minimum::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Minimum::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Minimum::VT_TAGS, tags);
  }
  explicit MinimumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Minimum> CreateMinimum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MinimumBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Minimum> CreateMinimumDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMinimum(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Mish FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MishBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Mish::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Mish::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Mish::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Mish::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Mish::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Mish::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Mish::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MishBuilder {
  typedef Mish Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Mish::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Mish::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Mish::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Mish::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Mish::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Mish::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Mish::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Mish::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Mish::VT_TAGS, tags);
  }
  explicit MishBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Mish> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Mish>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Mish> CreateMish(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MishBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Mish> CreateMishDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMish(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Multiply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUT_SCALE_TYPE = 4,
    VT_CUT_SCALE = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  fbs::QuantizedScaleArray_box cut_scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_CUT_SCALE_TYPE, 0));
  }
  const void *cut_scale() const {
    return GetPointer<const void *>(VT_CUT_SCALE);
  }
  template<typename T> const T *cut_scale_as() const;
  const fbs::ExpQuantizedScaleArray *cut_scale_as_ExpQuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *cut_scale_as_QuantizedScaleArray() const {
    return cut_scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(cut_scale()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CUT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CUT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, cut_scale(), cut_scale_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *Multiply::cut_scale_as<fbs::ExpQuantizedScaleArray>() const {
  return cut_scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *Multiply::cut_scale_as<fbs::QuantizedScaleArray>() const {
  return cut_scale_as_QuantizedScaleArray();
}

template<> inline const fbs::HostTarget *Multiply::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Multiply::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Multiply::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Multiply::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Multiply::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Multiply::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Multiply::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct MultiplyBuilder {
  typedef Multiply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cut_scale_type(fbs::QuantizedScaleArray_box cut_scale_type) {
    fbb_.AddElement<uint8_t>(Multiply::VT_CUT_SCALE_TYPE, static_cast<uint8_t>(cut_scale_type), 0);
  }
  void add_cut_scale(::flatbuffers::Offset<void> cut_scale) {
    fbb_.AddOffset(Multiply::VT_CUT_SCALE, cut_scale);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Multiply::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Multiply::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Multiply::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Multiply::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Multiply::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Multiply::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Multiply::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Multiply::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Multiply::VT_TAGS, tags);
  }
  explicit MultiplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Multiply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Multiply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Multiply> CreateMultiply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  MultiplyBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_cut_scale(cut_scale);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_cut_scale_type(cut_scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Multiply> CreateMultiplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box cut_scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> cut_scale = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateMultiply(
      _fbb,
      cut_scale_type,
      cut_scale,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Neg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Neg::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Neg::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Neg::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Neg::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Neg::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Neg::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Neg::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct NegBuilder {
  typedef Neg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Neg::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Neg::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Neg::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Neg::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Neg::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Neg::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Neg::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Neg::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Neg::VT_TAGS, tags);
  }
  explicit NegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Neg> CreateNeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  NegBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Neg> CreateNegDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateNeg(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Network FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRAMEWORK_KIND = 6,
    VT_FRAMEWORK_VERSION = 8,
    VT_ICRAFT_XIR_VERSION = 10,
    VT_ICRAFT_VERSION = 12,
    VT_PARAMS_BYTES = 14,
    VT_PARAMS_MD5 = 16,
    VT_TAGS = 18,
    VT_OPS_TYPE = 20,
    VT_OPS = 22,
    VT_AI_TARGET_TYPE = 24,
    VT_AI_TARGET = 26
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *framework_kind() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAMEWORK_KIND);
  }
  const ::flatbuffers::String *framework_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAMEWORK_VERSION);
  }
  const ::flatbuffers::String *icraft_xir_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICRAFT_XIR_VERSION);
  }
  const ::flatbuffers::String *icraft_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICRAFT_VERSION);
  }
  uint64_t params_bytes() const {
    return GetField<uint64_t>(VT_PARAMS_BYTES, 0);
  }
  const ::flatbuffers::String *params_md5() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMS_MD5);
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  const ::flatbuffers::Vector<uint8_t> *ops_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OPS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *ops() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OPS);
  }
  fbs::CompileTarget_box ai_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_AI_TARGET_TYPE, 0));
  }
  const void *ai_target() const {
    return GetPointer<const void *>(VT_AI_TARGET);
  }
  template<typename T> const T *ai_target_as() const;
  const fbs::HostTarget *ai_target_as_HostTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(ai_target()) : nullptr;
  }
  const fbs::FPGATarget *ai_target_as_FPGATarget() const {
    return ai_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(ai_target()) : nullptr;
  }
  const fbs::CustomTarget *ai_target_as_CustomTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(ai_target()) : nullptr;
  }
  const fbs::BuyiTarget *ai_target_as_BuyiTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(ai_target()) : nullptr;
  }
  const fbs::ZhugeTarget *ai_target_as_ZhugeTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(ai_target()) : nullptr;
  }
  const fbs::WolongTarget *ai_target_as_WolongTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(ai_target()) : nullptr;
  }
  const fbs::CompileTarget *ai_target_as_CompileTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(ai_target()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FRAMEWORK_KIND) &&
           verifier.VerifyString(framework_kind()) &&
           VerifyOffset(verifier, VT_FRAMEWORK_VERSION) &&
           verifier.VerifyString(framework_version()) &&
           VerifyOffset(verifier, VT_ICRAFT_XIR_VERSION) &&
           verifier.VerifyString(icraft_xir_version()) &&
           VerifyOffset(verifier, VT_ICRAFT_VERSION) &&
           verifier.VerifyString(icraft_version()) &&
           VerifyField<uint64_t>(verifier, VT_PARAMS_BYTES, 8) &&
           VerifyOffset(verifier, VT_PARAMS_MD5) &&
           verifier.VerifyString(params_md5()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           VerifyOffset(verifier, VT_OPS_TYPE) &&
           verifier.VerifyVector(ops_type()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           VerifyOperation_boxVector(verifier, ops(), ops_type()) &&
           VerifyField<uint8_t>(verifier, VT_AI_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_AI_TARGET) &&
           VerifyCompileTarget_box(verifier, ai_target(), ai_target_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Network::ai_target_as<fbs::HostTarget>() const {
  return ai_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Network::ai_target_as<fbs::FPGATarget>() const {
  return ai_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Network::ai_target_as<fbs::CustomTarget>() const {
  return ai_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Network::ai_target_as<fbs::BuyiTarget>() const {
  return ai_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Network::ai_target_as<fbs::ZhugeTarget>() const {
  return ai_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Network::ai_target_as<fbs::WolongTarget>() const {
  return ai_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Network::ai_target_as<fbs::CompileTarget>() const {
  return ai_target_as_CompileTarget();
}

struct NetworkBuilder {
  typedef Network Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Network::VT_NAME, name);
  }
  void add_framework_kind(::flatbuffers::Offset<::flatbuffers::String> framework_kind) {
    fbb_.AddOffset(Network::VT_FRAMEWORK_KIND, framework_kind);
  }
  void add_framework_version(::flatbuffers::Offset<::flatbuffers::String> framework_version) {
    fbb_.AddOffset(Network::VT_FRAMEWORK_VERSION, framework_version);
  }
  void add_icraft_xir_version(::flatbuffers::Offset<::flatbuffers::String> icraft_xir_version) {
    fbb_.AddOffset(Network::VT_ICRAFT_XIR_VERSION, icraft_xir_version);
  }
  void add_icraft_version(::flatbuffers::Offset<::flatbuffers::String> icraft_version) {
    fbb_.AddOffset(Network::VT_ICRAFT_VERSION, icraft_version);
  }
  void add_params_bytes(uint64_t params_bytes) {
    fbb_.AddElement<uint64_t>(Network::VT_PARAMS_BYTES, params_bytes, 0);
  }
  void add_params_md5(::flatbuffers::Offset<::flatbuffers::String> params_md5) {
    fbb_.AddOffset(Network::VT_PARAMS_MD5, params_md5);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Network::VT_TAGS, tags);
  }
  void add_ops_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ops_type) {
    fbb_.AddOffset(Network::VT_OPS_TYPE, ops_type);
  }
  void add_ops(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> ops) {
    fbb_.AddOffset(Network::VT_OPS, ops);
  }
  void add_ai_target_type(fbs::CompileTarget_box ai_target_type) {
    fbb_.AddElement<uint8_t>(Network::VT_AI_TARGET_TYPE, static_cast<uint8_t>(ai_target_type), 0);
  }
  void add_ai_target(::flatbuffers::Offset<void> ai_target) {
    fbb_.AddOffset(Network::VT_AI_TARGET, ai_target);
  }
  explicit NetworkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Network> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Network>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Network> CreateNetwork(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> framework_kind = 0,
    ::flatbuffers::Offset<::flatbuffers::String> framework_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> icraft_xir_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> icraft_version = 0,
    uint64_t params_bytes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> params_md5 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ops_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> ops = 0,
    fbs::CompileTarget_box ai_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> ai_target = 0) {
  NetworkBuilder builder_(_fbb);
  builder_.add_params_bytes(params_bytes);
  builder_.add_ai_target(ai_target);
  builder_.add_ops(ops);
  builder_.add_ops_type(ops_type);
  builder_.add_tags(tags);
  builder_.add_params_md5(params_md5);
  builder_.add_icraft_version(icraft_version);
  builder_.add_icraft_xir_version(icraft_xir_version);
  builder_.add_framework_version(framework_version);
  builder_.add_framework_kind(framework_kind);
  builder_.add_name(name);
  builder_.add_ai_target_type(ai_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Network> CreateNetworkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *framework_kind = nullptr,
    const char *framework_version = nullptr,
    const char *icraft_xir_version = nullptr,
    const char *icraft_version = nullptr,
    uint64_t params_bytes = 0,
    const char *params_md5 = nullptr,
    const char *tags = nullptr,
    const std::vector<uint8_t> *ops_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *ops = nullptr,
    fbs::CompileTarget_box ai_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> ai_target = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto framework_kind__ = framework_kind ? _fbb.CreateString(framework_kind) : 0;
  auto framework_version__ = framework_version ? _fbb.CreateString(framework_version) : 0;
  auto icraft_xir_version__ = icraft_xir_version ? _fbb.CreateString(icraft_xir_version) : 0;
  auto icraft_version__ = icraft_version ? _fbb.CreateString(icraft_version) : 0;
  auto params_md5__ = params_md5 ? _fbb.CreateString(params_md5) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  auto ops_type__ = ops_type ? _fbb.CreateVector<uint8_t>(*ops_type) : 0;
  auto ops__ = ops ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*ops) : 0;
  return fbs::CreateNetwork(
      _fbb,
      name__,
      framework_kind__,
      framework_version__,
      icraft_xir_version__,
      icraft_version__,
      params_bytes,
      params_md5__,
      tags__,
      ops_type__,
      ops__,
      ai_target_type,
      ai_target);
}

struct NetworkBase FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetworkBaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPS_TYPE = 4,
    VT_OPS = 6,
    VT_AI_TARGET_TYPE = 8,
    VT_AI_TARGET = 10
  };
  const ::flatbuffers::Vector<uint8_t> *ops_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OPS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *ops() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OPS);
  }
  fbs::CompileTarget_box ai_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_AI_TARGET_TYPE, 0));
  }
  const void *ai_target() const {
    return GetPointer<const void *>(VT_AI_TARGET);
  }
  template<typename T> const T *ai_target_as() const;
  const fbs::HostTarget *ai_target_as_HostTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(ai_target()) : nullptr;
  }
  const fbs::FPGATarget *ai_target_as_FPGATarget() const {
    return ai_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(ai_target()) : nullptr;
  }
  const fbs::CustomTarget *ai_target_as_CustomTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(ai_target()) : nullptr;
  }
  const fbs::BuyiTarget *ai_target_as_BuyiTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(ai_target()) : nullptr;
  }
  const fbs::ZhugeTarget *ai_target_as_ZhugeTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(ai_target()) : nullptr;
  }
  const fbs::WolongTarget *ai_target_as_WolongTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(ai_target()) : nullptr;
  }
  const fbs::CompileTarget *ai_target_as_CompileTarget() const {
    return ai_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(ai_target()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPS_TYPE) &&
           verifier.VerifyVector(ops_type()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           VerifyOperation_boxVector(verifier, ops(), ops_type()) &&
           VerifyField<uint8_t>(verifier, VT_AI_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_AI_TARGET) &&
           VerifyCompileTarget_box(verifier, ai_target(), ai_target_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *NetworkBase::ai_target_as<fbs::HostTarget>() const {
  return ai_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *NetworkBase::ai_target_as<fbs::FPGATarget>() const {
  return ai_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *NetworkBase::ai_target_as<fbs::CustomTarget>() const {
  return ai_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *NetworkBase::ai_target_as<fbs::BuyiTarget>() const {
  return ai_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *NetworkBase::ai_target_as<fbs::ZhugeTarget>() const {
  return ai_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *NetworkBase::ai_target_as<fbs::WolongTarget>() const {
  return ai_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *NetworkBase::ai_target_as<fbs::CompileTarget>() const {
  return ai_target_as_CompileTarget();
}

struct NetworkBaseBuilder {
  typedef NetworkBase Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ops_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ops_type) {
    fbb_.AddOffset(NetworkBase::VT_OPS_TYPE, ops_type);
  }
  void add_ops(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> ops) {
    fbb_.AddOffset(NetworkBase::VT_OPS, ops);
  }
  void add_ai_target_type(fbs::CompileTarget_box ai_target_type) {
    fbb_.AddElement<uint8_t>(NetworkBase::VT_AI_TARGET_TYPE, static_cast<uint8_t>(ai_target_type), 0);
  }
  void add_ai_target(::flatbuffers::Offset<void> ai_target) {
    fbb_.AddOffset(NetworkBase::VT_AI_TARGET, ai_target);
  }
  explicit NetworkBaseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NetworkBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NetworkBase>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NetworkBase> CreateNetworkBase(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ops_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> ops = 0,
    fbs::CompileTarget_box ai_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> ai_target = 0) {
  NetworkBaseBuilder builder_(_fbb);
  builder_.add_ai_target(ai_target);
  builder_.add_ops(ops);
  builder_.add_ops_type(ops_type);
  builder_.add_ai_target_type(ai_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NetworkBase> CreateNetworkBaseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ops_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *ops = nullptr,
    fbs::CompileTarget_box ai_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> ai_target = 0) {
  auto ops_type__ = ops_type ? _fbb.CreateVector<uint8_t>(*ops_type) : 0;
  auto ops__ = ops ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*ops) : 0;
  return fbs::CreateNetworkBase(
      _fbb,
      ops_type__,
      ops__,
      ai_target_type,
      ai_target);
}

struct Normalize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormalizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_P = 6,
    VT_EPS = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  const ::flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  float p() const {
    return GetField<float>(VT_P, 0.0f);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_P, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Normalize::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Normalize::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Normalize::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Normalize::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Normalize::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Normalize::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Normalize::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct NormalizeBuilder {
  typedef Normalize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Normalize::VT_AXIS, axis);
  }
  void add_p(float p) {
    fbb_.AddElement<float>(Normalize::VT_P, p, 0.0f);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(Normalize::VT_EPS, eps, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Normalize::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Normalize::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Normalize::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Normalize::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Normalize::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Normalize::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Normalize::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Normalize::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Normalize::VT_TAGS, tags);
  }
  explicit NormalizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Normalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Normalize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Normalize> CreateNormalize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis = 0,
    float p = 0.0f,
    float eps = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  NormalizeBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_eps(eps);
  builder_.add_p(p);
  builder_.add_axis(axis);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Normalize> CreateNormalizeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr,
    float p = 0.0f,
    float eps = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateNormalize(
      _fbb,
      axis__,
      p,
      eps,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct NormalizedQuantizedType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormalizedQuantizedTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORMRATIO = 4,
    VT_SCALE_TYPE = 6,
    VT_SCALE = 8,
    VT_ZERO_POINTS = 10,
    VT_STORAGE_DTYPE_TYPE = 12,
    VT_STORAGE_DTYPE = 14,
    VT_EXPRESSED_DTYPE_TYPE = 16,
    VT_EXPRESSED_DTYPE = 18
  };
  const fbs::NormratioArray *normratio() const {
    return GetPointer<const fbs::NormratioArray *>(VT_NORMRATIO);
  }
  fbs::QuantizedScaleArray_box scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_SCALE_TYPE, 0));
  }
  const void *scale() const {
    return GetPointer<const void *>(VT_SCALE);
  }
  template<typename T> const T *scale_as() const;
  const fbs::ExpQuantizedScaleArray *scale_as_ExpQuantizedScaleArray() const {
    return scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *scale_as_QuantizedScaleArray() const {
    return scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(scale()) : nullptr;
  }
  const ::flatbuffers::Vector<int64_t> *zero_points() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ZERO_POINTS);
  }
  fbs::ScalarType_box storage_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_STORAGE_DTYPE_TYPE, 0));
  }
  const void *storage_dtype() const {
    return GetPointer<const void *>(VT_STORAGE_DTYPE);
  }
  template<typename T> const T *storage_dtype_as() const;
  const fbs::BoolType *storage_dtype_as_BoolType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(storage_dtype()) : nullptr;
  }
  const fbs::IntegerType *storage_dtype_as_IntegerType() const {
    return storage_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(storage_dtype()) : nullptr;
  }
  const fbs::FloatType *storage_dtype_as_FloatType() const {
    return storage_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(storage_dtype()) : nullptr;
  }
  const fbs::CalibratedType *storage_dtype_as_CalibratedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedType *storage_dtype_as_NormalizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *storage_dtype_as_NormalizedQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::QuantizedType *storage_dtype_as_QuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *storage_dtype_as_BaseQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::ScalarType *storage_dtype_as_ScalarType() const {
    return storage_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(storage_dtype()) : nullptr;
  }
  fbs::ScalarType_box expressed_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_EXPRESSED_DTYPE_TYPE, 0));
  }
  const void *expressed_dtype() const {
    return GetPointer<const void *>(VT_EXPRESSED_DTYPE);
  }
  template<typename T> const T *expressed_dtype_as() const;
  const fbs::BoolType *expressed_dtype_as_BoolType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(expressed_dtype()) : nullptr;
  }
  const fbs::IntegerType *expressed_dtype_as_IntegerType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(expressed_dtype()) : nullptr;
  }
  const fbs::FloatType *expressed_dtype_as_FloatType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(expressed_dtype()) : nullptr;
  }
  const fbs::CalibratedType *expressed_dtype_as_CalibratedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedType *expressed_dtype_as_NormalizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *expressed_dtype_as_NormalizedQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::QuantizedType *expressed_dtype_as_QuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *expressed_dtype_as_BaseQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::ScalarType *expressed_dtype_as_ScalarType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(expressed_dtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORMRATIO) &&
           verifier.VerifyTable(normratio()) &&
           VerifyField<uint8_t>(verifier, VT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, scale(), scale_type()) &&
           VerifyOffset(verifier, VT_ZERO_POINTS) &&
           verifier.VerifyVector(zero_points()) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_DTYPE) &&
           VerifyScalarType_box(verifier, storage_dtype(), storage_dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSED_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXPRESSED_DTYPE) &&
           VerifyScalarType_box(verifier, expressed_dtype(), expressed_dtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *NormalizedQuantizedType::scale_as<fbs::ExpQuantizedScaleArray>() const {
  return scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *NormalizedQuantizedType::scale_as<fbs::QuantizedScaleArray>() const {
  return scale_as_QuantizedScaleArray();
}

template<> inline const fbs::BoolType *NormalizedQuantizedType::storage_dtype_as<fbs::BoolType>() const {
  return storage_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *NormalizedQuantizedType::storage_dtype_as<fbs::IntegerType>() const {
  return storage_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *NormalizedQuantizedType::storage_dtype_as<fbs::FloatType>() const {
  return storage_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *NormalizedQuantizedType::storage_dtype_as<fbs::CalibratedType>() const {
  return storage_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *NormalizedQuantizedType::storage_dtype_as<fbs::NormalizedType>() const {
  return storage_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *NormalizedQuantizedType::storage_dtype_as<fbs::NormalizedQuantizedType>() const {
  return storage_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *NormalizedQuantizedType::storage_dtype_as<fbs::QuantizedType>() const {
  return storage_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *NormalizedQuantizedType::storage_dtype_as<fbs::BaseQuantizedType>() const {
  return storage_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *NormalizedQuantizedType::storage_dtype_as<fbs::ScalarType>() const {
  return storage_dtype_as_ScalarType();
}

template<> inline const fbs::BoolType *NormalizedQuantizedType::expressed_dtype_as<fbs::BoolType>() const {
  return expressed_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *NormalizedQuantizedType::expressed_dtype_as<fbs::IntegerType>() const {
  return expressed_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *NormalizedQuantizedType::expressed_dtype_as<fbs::FloatType>() const {
  return expressed_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *NormalizedQuantizedType::expressed_dtype_as<fbs::CalibratedType>() const {
  return expressed_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *NormalizedQuantizedType::expressed_dtype_as<fbs::NormalizedType>() const {
  return expressed_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *NormalizedQuantizedType::expressed_dtype_as<fbs::NormalizedQuantizedType>() const {
  return expressed_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *NormalizedQuantizedType::expressed_dtype_as<fbs::QuantizedType>() const {
  return expressed_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *NormalizedQuantizedType::expressed_dtype_as<fbs::BaseQuantizedType>() const {
  return expressed_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *NormalizedQuantizedType::expressed_dtype_as<fbs::ScalarType>() const {
  return expressed_dtype_as_ScalarType();
}

struct NormalizedQuantizedTypeBuilder {
  typedef NormalizedQuantizedType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_normratio(::flatbuffers::Offset<fbs::NormratioArray> normratio) {
    fbb_.AddOffset(NormalizedQuantizedType::VT_NORMRATIO, normratio);
  }
  void add_scale_type(fbs::QuantizedScaleArray_box scale_type) {
    fbb_.AddElement<uint8_t>(NormalizedQuantizedType::VT_SCALE_TYPE, static_cast<uint8_t>(scale_type), 0);
  }
  void add_scale(::flatbuffers::Offset<void> scale) {
    fbb_.AddOffset(NormalizedQuantizedType::VT_SCALE, scale);
  }
  void add_zero_points(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_points) {
    fbb_.AddOffset(NormalizedQuantizedType::VT_ZERO_POINTS, zero_points);
  }
  void add_storage_dtype_type(fbs::ScalarType_box storage_dtype_type) {
    fbb_.AddElement<uint8_t>(NormalizedQuantizedType::VT_STORAGE_DTYPE_TYPE, static_cast<uint8_t>(storage_dtype_type), 0);
  }
  void add_storage_dtype(::flatbuffers::Offset<void> storage_dtype) {
    fbb_.AddOffset(NormalizedQuantizedType::VT_STORAGE_DTYPE, storage_dtype);
  }
  void add_expressed_dtype_type(fbs::ScalarType_box expressed_dtype_type) {
    fbb_.AddElement<uint8_t>(NormalizedQuantizedType::VT_EXPRESSED_DTYPE_TYPE, static_cast<uint8_t>(expressed_dtype_type), 0);
  }
  void add_expressed_dtype(::flatbuffers::Offset<void> expressed_dtype) {
    fbb_.AddOffset(NormalizedQuantizedType::VT_EXPRESSED_DTYPE, expressed_dtype);
  }
  explicit NormalizedQuantizedTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NormalizedQuantizedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NormalizedQuantizedType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NormalizedQuantizedType> CreateNormalizedQuantizedType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::NormratioArray> normratio = 0,
    fbs::QuantizedScaleArray_box scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> scale = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_points = 0,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  NormalizedQuantizedTypeBuilder builder_(_fbb);
  builder_.add_expressed_dtype(expressed_dtype);
  builder_.add_storage_dtype(storage_dtype);
  builder_.add_zero_points(zero_points);
  builder_.add_scale(scale);
  builder_.add_normratio(normratio);
  builder_.add_expressed_dtype_type(expressed_dtype_type);
  builder_.add_storage_dtype_type(storage_dtype_type);
  builder_.add_scale_type(scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NormalizedQuantizedType> CreateNormalizedQuantizedTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::NormratioArray> normratio = 0,
    fbs::QuantizedScaleArray_box scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> scale = 0,
    const std::vector<int64_t> *zero_points = nullptr,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  auto zero_points__ = zero_points ? _fbb.CreateVector<int64_t>(*zero_points) : 0;
  return fbs::CreateNormalizedQuantizedType(
      _fbb,
      normratio,
      scale_type,
      scale,
      zero_points__,
      storage_dtype_type,
      storage_dtype,
      expressed_dtype_type,
      expressed_dtype);
}

struct NormalizedType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormalizedTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORMRATIO = 4,
    VT_STORAGE_DTYPE_TYPE = 6,
    VT_STORAGE_DTYPE = 8,
    VT_EXPRESSED_DTYPE_TYPE = 10,
    VT_EXPRESSED_DTYPE = 12
  };
  const fbs::NormratioArray *normratio() const {
    return GetPointer<const fbs::NormratioArray *>(VT_NORMRATIO);
  }
  fbs::ScalarType_box storage_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_STORAGE_DTYPE_TYPE, 0));
  }
  const void *storage_dtype() const {
    return GetPointer<const void *>(VT_STORAGE_DTYPE);
  }
  template<typename T> const T *storage_dtype_as() const;
  const fbs::BoolType *storage_dtype_as_BoolType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(storage_dtype()) : nullptr;
  }
  const fbs::IntegerType *storage_dtype_as_IntegerType() const {
    return storage_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(storage_dtype()) : nullptr;
  }
  const fbs::FloatType *storage_dtype_as_FloatType() const {
    return storage_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(storage_dtype()) : nullptr;
  }
  const fbs::CalibratedType *storage_dtype_as_CalibratedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedType *storage_dtype_as_NormalizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *storage_dtype_as_NormalizedQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::QuantizedType *storage_dtype_as_QuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *storage_dtype_as_BaseQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::ScalarType *storage_dtype_as_ScalarType() const {
    return storage_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(storage_dtype()) : nullptr;
  }
  fbs::ScalarType_box expressed_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_EXPRESSED_DTYPE_TYPE, 0));
  }
  const void *expressed_dtype() const {
    return GetPointer<const void *>(VT_EXPRESSED_DTYPE);
  }
  template<typename T> const T *expressed_dtype_as() const;
  const fbs::BoolType *expressed_dtype_as_BoolType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(expressed_dtype()) : nullptr;
  }
  const fbs::IntegerType *expressed_dtype_as_IntegerType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(expressed_dtype()) : nullptr;
  }
  const fbs::FloatType *expressed_dtype_as_FloatType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(expressed_dtype()) : nullptr;
  }
  const fbs::CalibratedType *expressed_dtype_as_CalibratedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedType *expressed_dtype_as_NormalizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *expressed_dtype_as_NormalizedQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::QuantizedType *expressed_dtype_as_QuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *expressed_dtype_as_BaseQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::ScalarType *expressed_dtype_as_ScalarType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(expressed_dtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORMRATIO) &&
           verifier.VerifyTable(normratio()) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_DTYPE) &&
           VerifyScalarType_box(verifier, storage_dtype(), storage_dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSED_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXPRESSED_DTYPE) &&
           VerifyScalarType_box(verifier, expressed_dtype(), expressed_dtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *NormalizedType::storage_dtype_as<fbs::BoolType>() const {
  return storage_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *NormalizedType::storage_dtype_as<fbs::IntegerType>() const {
  return storage_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *NormalizedType::storage_dtype_as<fbs::FloatType>() const {
  return storage_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *NormalizedType::storage_dtype_as<fbs::CalibratedType>() const {
  return storage_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *NormalizedType::storage_dtype_as<fbs::NormalizedType>() const {
  return storage_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *NormalizedType::storage_dtype_as<fbs::NormalizedQuantizedType>() const {
  return storage_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *NormalizedType::storage_dtype_as<fbs::QuantizedType>() const {
  return storage_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *NormalizedType::storage_dtype_as<fbs::BaseQuantizedType>() const {
  return storage_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *NormalizedType::storage_dtype_as<fbs::ScalarType>() const {
  return storage_dtype_as_ScalarType();
}

template<> inline const fbs::BoolType *NormalizedType::expressed_dtype_as<fbs::BoolType>() const {
  return expressed_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *NormalizedType::expressed_dtype_as<fbs::IntegerType>() const {
  return expressed_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *NormalizedType::expressed_dtype_as<fbs::FloatType>() const {
  return expressed_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *NormalizedType::expressed_dtype_as<fbs::CalibratedType>() const {
  return expressed_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *NormalizedType::expressed_dtype_as<fbs::NormalizedType>() const {
  return expressed_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *NormalizedType::expressed_dtype_as<fbs::NormalizedQuantizedType>() const {
  return expressed_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *NormalizedType::expressed_dtype_as<fbs::QuantizedType>() const {
  return expressed_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *NormalizedType::expressed_dtype_as<fbs::BaseQuantizedType>() const {
  return expressed_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *NormalizedType::expressed_dtype_as<fbs::ScalarType>() const {
  return expressed_dtype_as_ScalarType();
}

struct NormalizedTypeBuilder {
  typedef NormalizedType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_normratio(::flatbuffers::Offset<fbs::NormratioArray> normratio) {
    fbb_.AddOffset(NormalizedType::VT_NORMRATIO, normratio);
  }
  void add_storage_dtype_type(fbs::ScalarType_box storage_dtype_type) {
    fbb_.AddElement<uint8_t>(NormalizedType::VT_STORAGE_DTYPE_TYPE, static_cast<uint8_t>(storage_dtype_type), 0);
  }
  void add_storage_dtype(::flatbuffers::Offset<void> storage_dtype) {
    fbb_.AddOffset(NormalizedType::VT_STORAGE_DTYPE, storage_dtype);
  }
  void add_expressed_dtype_type(fbs::ScalarType_box expressed_dtype_type) {
    fbb_.AddElement<uint8_t>(NormalizedType::VT_EXPRESSED_DTYPE_TYPE, static_cast<uint8_t>(expressed_dtype_type), 0);
  }
  void add_expressed_dtype(::flatbuffers::Offset<void> expressed_dtype) {
    fbb_.AddOffset(NormalizedType::VT_EXPRESSED_DTYPE, expressed_dtype);
  }
  explicit NormalizedTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NormalizedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NormalizedType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NormalizedType> CreateNormalizedType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::NormratioArray> normratio = 0,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  NormalizedTypeBuilder builder_(_fbb);
  builder_.add_expressed_dtype(expressed_dtype);
  builder_.add_storage_dtype(storage_dtype);
  builder_.add_normratio(normratio);
  builder_.add_expressed_dtype_type(expressed_dtype_type);
  builder_.add_storage_dtype_type(storage_dtype_type);
  return builder_.Finish();
}

struct NormratioArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormratioArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_DATA = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const ::flatbuffers::Vector<float> *data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NormratioArrayBuilder {
  typedef NormratioArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(NormratioArray::VT_AXIS, axis, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(NormratioArray::VT_DATA, data);
  }
  explicit NormratioArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NormratioArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NormratioArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NormratioArray> CreateNormratioArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> data = 0) {
  NormratioArrayBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NormratioArray> CreateNormratioArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return fbs::CreateNormratioArray(
      _fbb,
      axis,
      data__);
}

struct Not FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Not::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Not::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Not::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Not::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Not::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Not::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Not::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct NotBuilder {
  typedef Not Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Not::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Not::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Not::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Not::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Not::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Not::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Not::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Not::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Not::VT_TAGS, tags);
  }
  explicit NotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Not> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Not>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Not> CreateNot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  NotBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Not> CreateNotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateNot(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct NotEqual FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotEqualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *NotEqual::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *NotEqual::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *NotEqual::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *NotEqual::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *NotEqual::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *NotEqual::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *NotEqual::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct NotEqualBuilder {
  typedef NotEqual Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(NotEqual::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NotEqual::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(NotEqual::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(NotEqual::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(NotEqual::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(NotEqual::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(NotEqual::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(NotEqual::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(NotEqual::VT_TAGS, tags);
  }
  explicit NotEqualBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotEqual> CreateNotEqual(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  NotEqualBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NotEqual> CreateNotEqualDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateNotEqual(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ObjectRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectRefBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ObjectRefBuilder {
  typedef ObjectRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ObjectRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectRef> CreateObjectRef(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ObjectRefBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OnChipMem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnChipMemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4
  };
  uint64_t addr() const {
    return GetField<uint64_t>(VT_ADDR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDR, 8) &&
           verifier.EndTable();
  }
};

struct OnChipMemBuilder {
  typedef OnChipMem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_addr(uint64_t addr) {
    fbb_.AddElement<uint64_t>(OnChipMem::VT_ADDR, addr, 0);
  }
  explicit OnChipMemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnChipMem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnChipMem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnChipMem> CreateOnChipMem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t addr = 0) {
  OnChipMemBuilder builder_(_fbb);
  builder_.add_addr(addr);
  return builder_.Finish();
}

struct Operation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperationBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OperationBuilder {
  typedef Operation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit OperationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operation> CreateOperation(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  OperationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Output FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Output::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Output::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Output::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Output::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Output::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Output::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Output::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct OutputBuilder {
  typedef Output Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Output::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Output::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Output::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Output::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Output::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Output::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Output::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Output::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Output::VT_TAGS, tags);
  }
  explicit OutputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Output> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Output>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Output> CreateOutput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  OutputBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Output> CreateOutputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateOutput(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct PReLU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PReLUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const fbs::Params *alpha() const {
    return GetPointer<const fbs::Params *>(VT_ALPHA);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyTable(alpha()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *PReLU::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *PReLU::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *PReLU::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *PReLU::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *PReLU::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *PReLU::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *PReLU::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct PReLUBuilder {
  typedef PReLU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(::flatbuffers::Offset<fbs::Params> alpha) {
    fbb_.AddOffset(PReLU::VT_ALPHA, alpha);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(PReLU::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PReLU::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(PReLU::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(PReLU::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(PReLU::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(PReLU::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(PReLU::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(PReLU::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(PReLU::VT_TAGS, tags);
  }
  explicit PReLUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PReLU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PReLU> CreatePReLU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> alpha = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  PReLUBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_alpha(alpha);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PReLU> CreatePReLUDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fbs::Params> alpha = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreatePReLU(
      _fbb,
      alpha,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Pad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_MODE = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10,
    VT_OP_ID = 12,
    VT_NAME = 14,
    VT_INPUTS_TYPE = 16,
    VT_INPUTS = 18,
    VT_OUTPUTS_TYPE = 20,
    VT_OUTPUTS = 22,
    VT_COMPILE_TARGET_TYPE = 24,
    VT_COMPILE_TARGET = 26,
    VT_TAGS = 28
  };
  const ::flatbuffers::Vector<int64_t> *padding() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_PADDING);
  }
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  fbs::ScalarImm_box value_type() const {
    return static_cast<fbs::ScalarImm_box>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const fbs::Bool *value_as_Bool() const {
    return value_type() == fbs::ScalarImm_box_Bool ? static_cast<const fbs::Bool *>(value()) : nullptr;
  }
  const fbs::IntImm *value_as_IntImm() const {
    return value_type() == fbs::ScalarImm_box_IntImm ? static_cast<const fbs::IntImm *>(value()) : nullptr;
  }
  const fbs::FloatImm *value_as_FloatImm() const {
    return value_type() == fbs::ScalarImm_box_FloatImm ? static_cast<const fbs::FloatImm *>(value()) : nullptr;
  }
  const fbs::ScalarImm *value_as_ScalarImm() const {
    return value_type() == fbs::ScalarImm_box_ScalarImm ? static_cast<const fbs::ScalarImm *>(value()) : nullptr;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyScalarImm_box(verifier, value(), value_type()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::Bool *Pad::value_as<fbs::Bool>() const {
  return value_as_Bool();
}

template<> inline const fbs::IntImm *Pad::value_as<fbs::IntImm>() const {
  return value_as_IntImm();
}

template<> inline const fbs::FloatImm *Pad::value_as<fbs::FloatImm>() const {
  return value_as_FloatImm();
}

template<> inline const fbs::ScalarImm *Pad::value_as<fbs::ScalarImm>() const {
  return value_as_ScalarImm();
}

template<> inline const fbs::HostTarget *Pad::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Pad::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Pad::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Pad::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Pad::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Pad::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Pad::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct PadBuilder {
  typedef Pad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padding(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding) {
    fbb_.AddOffset(Pad::VT_PADDING, padding);
  }
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(Pad::VT_MODE, mode);
  }
  void add_value_type(fbs::ScalarImm_box value_type) {
    fbb_.AddElement<uint8_t>(Pad::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Pad::VT_VALUE, value);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Pad::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Pad::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Pad::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Pad::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Pad::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Pad::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Pad::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Pad::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Pad::VT_TAGS, tags);
  }
  explicit PadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pad> CreatePad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> padding = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    fbs::ScalarImm_box value_type = fbs::ScalarImm_box_NONE,
    ::flatbuffers::Offset<void> value = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  PadBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_value(value);
  builder_.add_mode(mode);
  builder_.add_padding(padding);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pad> CreatePadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *padding = nullptr,
    const char *mode = nullptr,
    fbs::ScalarImm_box value_type = fbs::ScalarImm_box_NONE,
    ::flatbuffers::Offset<void> value = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto padding__ = padding ? _fbb.CreateVector<int64_t>(*padding) : 0;
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreatePad(
      _fbb,
      padding__,
      mode__,
      value_type,
      value,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Params FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__ALLOW_NO_DATA = 4,
    VT_V_ID = 6,
    VT_NAME = 8,
    VT_TAGS = 10,
    VT_DTYPE_TYPE = 12,
    VT_DTYPE = 14,
    VT_MTYPE_TYPE = 16,
    VT_MTYPE = 18,
    VT__DATA = 20
  };
  bool _allow_no_data() const {
    return GetField<uint8_t>(VT__ALLOW_NO_DATA, 0) != 0;
  }
  int64_t v_id() const {
    return GetField<int64_t>(VT_V_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  const ::flatbuffers::Vector<uint8_t> *_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT__DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT__ALLOW_NO_DATA, 1) &&
           VerifyField<int64_t>(verifier, VT_V_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           VerifyOffset(verifier, VT__DATA) &&
           verifier.VerifyVector(_data()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *Params::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *Params::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *Params::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *Params::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *Params::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *Params::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *Params::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *Params::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *Params::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *Params::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *Params::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *Params::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *Params::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *Params::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *Params::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *Params::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct ParamsBuilder {
  typedef Params Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add__allow_no_data(bool _allow_no_data) {
    fbb_.AddElement<uint8_t>(Params::VT__ALLOW_NO_DATA, static_cast<uint8_t>(_allow_no_data), 0);
  }
  void add_v_id(int64_t v_id) {
    fbb_.AddElement<int64_t>(Params::VT_V_ID, v_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Params::VT_NAME, name);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Params::VT_TAGS, tags);
  }
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(Params::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(Params::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(Params::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(Params::VT_MTYPE, mtype);
  }
  void add__data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> _data) {
    fbb_.AddOffset(Params::VT__DATA, _data);
  }
  explicit ParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Params> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Params>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Params> CreateParams(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool _allow_no_data = false,
    int64_t v_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> _data = 0) {
  ParamsBuilder builder_(_fbb);
  builder_.add_v_id(v_id);
  builder_.add__data(_data);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_tags(tags);
  builder_.add_name(name);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  builder_.add__allow_no_data(_allow_no_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Params> CreateParamsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool _allow_no_data = false,
    int64_t v_id = 0,
    const char *name = nullptr,
    const char *tags = nullptr,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0,
    const std::vector<uint8_t> *_data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  if (_data) { _fbb.ForceVectorAlignment(_data->size(), sizeof(uint8_t), 4096); }
  auto _data__ = _data ? _fbb.CreateVector<uint8_t>(*_data) : 0;
  return fbs::CreateParams(
      _fbb,
      _allow_no_data,
      v_id,
      name__,
      tags__,
      dtype_type,
      dtype,
      mtype_type,
      mtype,
      _data__);
}

struct PixelShuffle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PixelShuffleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPSCALE_FACTOR = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t upscale_factor() const {
    return GetField<int64_t>(VT_UPSCALE_FACTOR, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UPSCALE_FACTOR, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *PixelShuffle::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *PixelShuffle::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *PixelShuffle::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *PixelShuffle::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *PixelShuffle::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *PixelShuffle::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *PixelShuffle::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct PixelShuffleBuilder {
  typedef PixelShuffle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_upscale_factor(int64_t upscale_factor) {
    fbb_.AddElement<int64_t>(PixelShuffle::VT_UPSCALE_FACTOR, upscale_factor, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(PixelShuffle::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PixelShuffle::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(PixelShuffle::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(PixelShuffle::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(PixelShuffle::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(PixelShuffle::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(PixelShuffle::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(PixelShuffle::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(PixelShuffle::VT_TAGS, tags);
  }
  explicit PixelShuffleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PixelShuffle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PixelShuffle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PixelShuffle> CreatePixelShuffle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upscale_factor = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  PixelShuffleBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_upscale_factor(upscale_factor);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PixelShuffle> CreatePixelShuffleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t upscale_factor = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreatePixelShuffle(
      _fbb,
      upscale_factor,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Pow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Pow::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Pow::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Pow::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Pow::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Pow::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Pow::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Pow::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct PowBuilder {
  typedef Pow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Pow::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Pow::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Pow::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Pow::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Pow::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Pow::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Pow::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Pow::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Pow::VT_TAGS, tags);
  }
  explicit PowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pow> CreatePow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  PowBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pow> CreatePowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreatePow(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct PruneAxis FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PruneAxisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::Vector<int64_t> *index() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INDEX);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *PruneAxis::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *PruneAxis::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *PruneAxis::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *PruneAxis::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *PruneAxis::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *PruneAxis::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *PruneAxis::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct PruneAxisBuilder {
  typedef PruneAxis Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> index) {
    fbb_.AddOffset(PruneAxis::VT_INDEX, index);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(PruneAxis::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PruneAxis::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(PruneAxis::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(PruneAxis::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(PruneAxis::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(PruneAxis::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(PruneAxis::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(PruneAxis::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(PruneAxis::VT_TAGS, tags);
  }
  explicit PruneAxisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PruneAxis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PruneAxis>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PruneAxis> CreatePruneAxis(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> index = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  PruneAxisBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_index(index);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PruneAxis> CreatePruneAxisDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *index = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto index__ = index ? _fbb.CreateVector<int64_t>(*index) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreatePruneAxis(
      _fbb,
      index__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct QuantizedScale FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedScaleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN_SCALE = 4
  };
  float origin_scale() const {
    return GetField<float>(VT_ORIGIN_SCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ORIGIN_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct QuantizedScaleBuilder {
  typedef QuantizedScale Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_origin_scale(float origin_scale) {
    fbb_.AddElement<float>(QuantizedScale::VT_ORIGIN_SCALE, origin_scale, 0.0f);
  }
  explicit QuantizedScaleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedScale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedScale>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedScale> CreateQuantizedScale(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float origin_scale = 0.0f) {
  QuantizedScaleBuilder builder_(_fbb);
  builder_.add_origin_scale(origin_scale);
  return builder_.Finish();
}

struct QuantizedScaleArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedScaleArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ORIGIN_SCALE = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const ::flatbuffers::Vector<float> *origin_scale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ORIGIN_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyOffset(verifier, VT_ORIGIN_SCALE) &&
           verifier.VerifyVector(origin_scale()) &&
           verifier.EndTable();
  }
};

struct QuantizedScaleArrayBuilder {
  typedef QuantizedScaleArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(QuantizedScaleArray::VT_AXIS, axis, 0);
  }
  void add_origin_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> origin_scale) {
    fbb_.AddOffset(QuantizedScaleArray::VT_ORIGIN_SCALE, origin_scale);
  }
  explicit QuantizedScaleArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedScaleArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedScaleArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedScaleArray> CreateQuantizedScaleArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> origin_scale = 0) {
  QuantizedScaleArrayBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_origin_scale(origin_scale);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizedScaleArray> CreateQuantizedScaleArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<float> *origin_scale = nullptr) {
  auto origin_scale__ = origin_scale ? _fbb.CreateVector<float>(*origin_scale) : 0;
  return fbs::CreateQuantizedScaleArray(
      _fbb,
      axis,
      origin_scale__);
}

struct QuantizedType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE_TYPE = 4,
    VT_SCALE = 6,
    VT_ZERO_POINTS = 8,
    VT_STORAGE_DTYPE_TYPE = 10,
    VT_STORAGE_DTYPE = 12,
    VT_EXPRESSED_DTYPE_TYPE = 14,
    VT_EXPRESSED_DTYPE = 16
  };
  fbs::QuantizedScaleArray_box scale_type() const {
    return static_cast<fbs::QuantizedScaleArray_box>(GetField<uint8_t>(VT_SCALE_TYPE, 0));
  }
  const void *scale() const {
    return GetPointer<const void *>(VT_SCALE);
  }
  template<typename T> const T *scale_as() const;
  const fbs::ExpQuantizedScaleArray *scale_as_ExpQuantizedScaleArray() const {
    return scale_type() == fbs::QuantizedScaleArray_box_ExpQuantizedScaleArray ? static_cast<const fbs::ExpQuantizedScaleArray *>(scale()) : nullptr;
  }
  const fbs::QuantizedScaleArray *scale_as_QuantizedScaleArray() const {
    return scale_type() == fbs::QuantizedScaleArray_box_QuantizedScaleArray ? static_cast<const fbs::QuantizedScaleArray *>(scale()) : nullptr;
  }
  const ::flatbuffers::Vector<int64_t> *zero_points() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ZERO_POINTS);
  }
  fbs::ScalarType_box storage_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_STORAGE_DTYPE_TYPE, 0));
  }
  const void *storage_dtype() const {
    return GetPointer<const void *>(VT_STORAGE_DTYPE);
  }
  template<typename T> const T *storage_dtype_as() const;
  const fbs::BoolType *storage_dtype_as_BoolType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(storage_dtype()) : nullptr;
  }
  const fbs::IntegerType *storage_dtype_as_IntegerType() const {
    return storage_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(storage_dtype()) : nullptr;
  }
  const fbs::FloatType *storage_dtype_as_FloatType() const {
    return storage_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(storage_dtype()) : nullptr;
  }
  const fbs::CalibratedType *storage_dtype_as_CalibratedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedType *storage_dtype_as_NormalizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *storage_dtype_as_NormalizedQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::QuantizedType *storage_dtype_as_QuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *storage_dtype_as_BaseQuantizedType() const {
    return storage_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(storage_dtype()) : nullptr;
  }
  const fbs::ScalarType *storage_dtype_as_ScalarType() const {
    return storage_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(storage_dtype()) : nullptr;
  }
  fbs::ScalarType_box expressed_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_EXPRESSED_DTYPE_TYPE, 0));
  }
  const void *expressed_dtype() const {
    return GetPointer<const void *>(VT_EXPRESSED_DTYPE);
  }
  template<typename T> const T *expressed_dtype_as() const;
  const fbs::BoolType *expressed_dtype_as_BoolType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(expressed_dtype()) : nullptr;
  }
  const fbs::IntegerType *expressed_dtype_as_IntegerType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(expressed_dtype()) : nullptr;
  }
  const fbs::FloatType *expressed_dtype_as_FloatType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(expressed_dtype()) : nullptr;
  }
  const fbs::CalibratedType *expressed_dtype_as_CalibratedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedType *expressed_dtype_as_NormalizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *expressed_dtype_as_NormalizedQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::QuantizedType *expressed_dtype_as_QuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *expressed_dtype_as_BaseQuantizedType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(expressed_dtype()) : nullptr;
  }
  const fbs::ScalarType *expressed_dtype_as_ScalarType() const {
    return expressed_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(expressed_dtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCALE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SCALE) &&
           VerifyQuantizedScaleArray_box(verifier, scale(), scale_type()) &&
           VerifyOffset(verifier, VT_ZERO_POINTS) &&
           verifier.VerifyVector(zero_points()) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_DTYPE) &&
           VerifyScalarType_box(verifier, storage_dtype(), storage_dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_EXPRESSED_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_EXPRESSED_DTYPE) &&
           VerifyScalarType_box(verifier, expressed_dtype(), expressed_dtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::ExpQuantizedScaleArray *QuantizedType::scale_as<fbs::ExpQuantizedScaleArray>() const {
  return scale_as_ExpQuantizedScaleArray();
}

template<> inline const fbs::QuantizedScaleArray *QuantizedType::scale_as<fbs::QuantizedScaleArray>() const {
  return scale_as_QuantizedScaleArray();
}

template<> inline const fbs::BoolType *QuantizedType::storage_dtype_as<fbs::BoolType>() const {
  return storage_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *QuantizedType::storage_dtype_as<fbs::IntegerType>() const {
  return storage_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *QuantizedType::storage_dtype_as<fbs::FloatType>() const {
  return storage_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *QuantizedType::storage_dtype_as<fbs::CalibratedType>() const {
  return storage_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *QuantizedType::storage_dtype_as<fbs::NormalizedType>() const {
  return storage_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *QuantizedType::storage_dtype_as<fbs::NormalizedQuantizedType>() const {
  return storage_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *QuantizedType::storage_dtype_as<fbs::QuantizedType>() const {
  return storage_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *QuantizedType::storage_dtype_as<fbs::BaseQuantizedType>() const {
  return storage_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *QuantizedType::storage_dtype_as<fbs::ScalarType>() const {
  return storage_dtype_as_ScalarType();
}

template<> inline const fbs::BoolType *QuantizedType::expressed_dtype_as<fbs::BoolType>() const {
  return expressed_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *QuantizedType::expressed_dtype_as<fbs::IntegerType>() const {
  return expressed_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *QuantizedType::expressed_dtype_as<fbs::FloatType>() const {
  return expressed_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *QuantizedType::expressed_dtype_as<fbs::CalibratedType>() const {
  return expressed_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *QuantizedType::expressed_dtype_as<fbs::NormalizedType>() const {
  return expressed_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *QuantizedType::expressed_dtype_as<fbs::NormalizedQuantizedType>() const {
  return expressed_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *QuantizedType::expressed_dtype_as<fbs::QuantizedType>() const {
  return expressed_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *QuantizedType::expressed_dtype_as<fbs::BaseQuantizedType>() const {
  return expressed_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *QuantizedType::expressed_dtype_as<fbs::ScalarType>() const {
  return expressed_dtype_as_ScalarType();
}

struct QuantizedTypeBuilder {
  typedef QuantizedType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scale_type(fbs::QuantizedScaleArray_box scale_type) {
    fbb_.AddElement<uint8_t>(QuantizedType::VT_SCALE_TYPE, static_cast<uint8_t>(scale_type), 0);
  }
  void add_scale(::flatbuffers::Offset<void> scale) {
    fbb_.AddOffset(QuantizedType::VT_SCALE, scale);
  }
  void add_zero_points(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_points) {
    fbb_.AddOffset(QuantizedType::VT_ZERO_POINTS, zero_points);
  }
  void add_storage_dtype_type(fbs::ScalarType_box storage_dtype_type) {
    fbb_.AddElement<uint8_t>(QuantizedType::VT_STORAGE_DTYPE_TYPE, static_cast<uint8_t>(storage_dtype_type), 0);
  }
  void add_storage_dtype(::flatbuffers::Offset<void> storage_dtype) {
    fbb_.AddOffset(QuantizedType::VT_STORAGE_DTYPE, storage_dtype);
  }
  void add_expressed_dtype_type(fbs::ScalarType_box expressed_dtype_type) {
    fbb_.AddElement<uint8_t>(QuantizedType::VT_EXPRESSED_DTYPE_TYPE, static_cast<uint8_t>(expressed_dtype_type), 0);
  }
  void add_expressed_dtype(::flatbuffers::Offset<void> expressed_dtype) {
    fbb_.AddOffset(QuantizedType::VT_EXPRESSED_DTYPE, expressed_dtype);
  }
  explicit QuantizedTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedType> CreateQuantizedType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> scale = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_points = 0,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  QuantizedTypeBuilder builder_(_fbb);
  builder_.add_expressed_dtype(expressed_dtype);
  builder_.add_storage_dtype(storage_dtype);
  builder_.add_zero_points(zero_points);
  builder_.add_scale(scale);
  builder_.add_expressed_dtype_type(expressed_dtype_type);
  builder_.add_storage_dtype_type(storage_dtype_type);
  builder_.add_scale_type(scale_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizedType> CreateQuantizedTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::QuantizedScaleArray_box scale_type = fbs::QuantizedScaleArray_box_NONE,
    ::flatbuffers::Offset<void> scale = 0,
    const std::vector<int64_t> *zero_points = nullptr,
    fbs::ScalarType_box storage_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> storage_dtype = 0,
    fbs::ScalarType_box expressed_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> expressed_dtype = 0) {
  auto zero_points__ = zero_points ? _fbb.CreateVector<int64_t>(*zero_points) : 0;
  return fbs::CreateQuantizedType(
      _fbb,
      scale_type,
      scale,
      zero_points__,
      storage_dtype_type,
      storage_dtype,
      expressed_dtype_type,
      expressed_dtype);
}

struct ReLU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReLUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_MAX_VALUE = 6,
    VT_THRESHOLD = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float max_value() const {
    return GetField<float>(VT_MAX_VALUE, 0.0f);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_MAX_VALUE, 4) &&
           VerifyField<float>(verifier, VT_THRESHOLD, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *ReLU::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *ReLU::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *ReLU::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *ReLU::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *ReLU::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *ReLU::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *ReLU::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ReLUBuilder {
  typedef ReLU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ReLU::VT_ALPHA, alpha, 0.0f);
  }
  void add_max_value(float max_value) {
    fbb_.AddElement<float>(ReLU::VT_MAX_VALUE, max_value, 0.0f);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(ReLU::VT_THRESHOLD, threshold, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(ReLU::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ReLU::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(ReLU::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(ReLU::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(ReLU::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(ReLU::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(ReLU::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(ReLU::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(ReLU::VT_TAGS, tags);
  }
  explicit ReLUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReLU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReLU> CreateReLU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float max_value = 0.0f,
    float threshold = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ReLUBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_threshold(threshold);
  builder_.add_max_value(max_value);
  builder_.add_alpha(alpha);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReLU> CreateReLUDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float max_value = 0.0f,
    float threshold = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateReLU(
      _fbb,
      alpha,
      max_value,
      threshold,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Reshape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReshapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_LAYOUT = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  const fbs::Layout *layout() const {
    return GetPointer<const fbs::Layout *>(VT_LAYOUT);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Reshape::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Reshape::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Reshape::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Reshape::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Reshape::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Reshape::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Reshape::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ReshapeBuilder {
  typedef Reshape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Reshape::VT_SHAPE, shape);
  }
  void add_layout(::flatbuffers::Offset<fbs::Layout> layout) {
    fbb_.AddOffset(Reshape::VT_LAYOUT, layout);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Reshape::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Reshape::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Reshape::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Reshape::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Reshape::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Reshape::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Reshape::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Reshape::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Reshape::VT_TAGS, tags);
  }
  explicit ReshapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Reshape> CreateReshape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape = 0,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_layout(layout);
  builder_.add_shape(shape);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Reshape> CreateReshapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *shape = nullptr,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateReshape(
      _fbb,
      shape__,
      layout,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Resize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DSIZE = 4,
    VT_INTERPOLATION = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *dsize() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DSIZE);
  }
  const ::flatbuffers::String *interpolation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERPOLATION);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DSIZE) &&
           verifier.VerifyVector(dsize()) &&
           VerifyOffset(verifier, VT_INTERPOLATION) &&
           verifier.VerifyString(interpolation()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Resize::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Resize::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Resize::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Resize::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Resize::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Resize::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Resize::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct ResizeBuilder {
  typedef Resize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dsize(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dsize) {
    fbb_.AddOffset(Resize::VT_DSIZE, dsize);
  }
  void add_interpolation(::flatbuffers::Offset<::flatbuffers::String> interpolation) {
    fbb_.AddOffset(Resize::VT_INTERPOLATION, interpolation);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Resize::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Resize::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Resize::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Resize::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Resize::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Resize::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Resize::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Resize::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Resize::VT_TAGS, tags);
  }
  explicit ResizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Resize> CreateResize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dsize = 0,
    ::flatbuffers::Offset<::flatbuffers::String> interpolation = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  ResizeBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_interpolation(interpolation);
  builder_.add_dsize(dsize);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Resize> CreateResizeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dsize = nullptr,
    const char *interpolation = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto dsize__ = dsize ? _fbb.CreateVector<int64_t>(*dsize) : 0;
  auto interpolation__ = interpolation ? _fbb.CreateString(interpolation) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateResize(
      _fbb,
      dsize__,
      interpolation__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Roll FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RollBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHIFTS = 4,
    VT_DIMS = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *shifts() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SHIFTS);
  }
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHIFTS) &&
           verifier.VerifyVector(shifts()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Roll::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Roll::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Roll::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Roll::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Roll::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Roll::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Roll::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct RollBuilder {
  typedef Roll Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shifts(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shifts) {
    fbb_.AddOffset(Roll::VT_SHIFTS, shifts);
  }
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Roll::VT_DIMS, dims);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Roll::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Roll::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Roll::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Roll::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Roll::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Roll::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Roll::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Roll::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Roll::VT_TAGS, tags);
  }
  explicit RollBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Roll> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Roll>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Roll> CreateRoll(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shifts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  RollBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dims(dims);
  builder_.add_shifts(shifts);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Roll> CreateRollDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *shifts = nullptr,
    const std::vector<int64_t> *dims = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto shifts__ = shifts ? _fbb.CreateVector<int64_t>(*shifts) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateRoll(
      _fbb,
      shifts__,
      dims__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct ScalarImm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarImmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE_TYPE = 4,
    VT_DTYPE = 6,
    VT_MTYPE_TYPE = 8,
    VT_MTYPE = 10
  };
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *ScalarImm::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *ScalarImm::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *ScalarImm::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *ScalarImm::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *ScalarImm::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *ScalarImm::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *ScalarImm::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *ScalarImm::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *ScalarImm::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *ScalarImm::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *ScalarImm::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *ScalarImm::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *ScalarImm::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *ScalarImm::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *ScalarImm::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *ScalarImm::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct ScalarImmBuilder {
  typedef ScalarImm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(ScalarImm::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(ScalarImm::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(ScalarImm::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(ScalarImm::VT_MTYPE, mtype);
  }
  explicit ScalarImmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScalarImm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScalarImm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScalarImm> CreateScalarImm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  ScalarImmBuilder builder_(_fbb);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  return builder_.Finish();
}

struct ScalarType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarTypeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScalarTypeBuilder {
  typedef ScalarType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ScalarTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScalarType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScalarType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScalarType> CreateScalarType(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ScalarTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SiLU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SiLUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *SiLU::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *SiLU::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *SiLU::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *SiLU::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *SiLU::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *SiLU::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *SiLU::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SiLUBuilder {
  typedef SiLU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(SiLU::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SiLU::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(SiLU::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(SiLU::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(SiLU::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(SiLU::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(SiLU::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(SiLU::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(SiLU::VT_TAGS, tags);
  }
  explicit SiLUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SiLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SiLU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SiLU> CreateSiLU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SiLUBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SiLU> CreateSiLUDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSiLU(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Sigmoid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SigmoidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Sigmoid::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Sigmoid::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Sigmoid::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Sigmoid::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Sigmoid::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Sigmoid::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Sigmoid::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SigmoidBuilder {
  typedef Sigmoid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Sigmoid::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Sigmoid::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Sigmoid::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Sigmoid::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Sigmoid::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Sigmoid::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Sigmoid::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Sigmoid::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Sigmoid::VT_TAGS, tags);
  }
  explicit SigmoidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sigmoid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sigmoid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sigmoid> CreateSigmoid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SigmoidBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sigmoid> CreateSigmoidDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSigmoid(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Sin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Sin::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Sin::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Sin::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Sin::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Sin::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Sin::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Sin::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SinBuilder {
  typedef Sin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Sin::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Sin::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Sin::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Sin::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Sin::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Sin::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Sin::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Sin::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Sin::VT_TAGS, tags);
  }
  explicit SinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sin> CreateSin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SinBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sin> CreateSinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSin(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Sinh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SinhBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Sinh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Sinh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Sinh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Sinh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Sinh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Sinh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Sinh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SinhBuilder {
  typedef Sinh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Sinh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Sinh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Sinh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Sinh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Sinh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Sinh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Sinh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Sinh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Sinh::VT_TAGS, tags);
  }
  explicit SinhBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sinh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sinh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sinh> CreateSinh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SinhBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sinh> CreateSinhDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSinh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Slice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN = 4,
    VT_END = 6,
    VT_STRIDE = 8,
    VT_OP_ID = 10,
    VT_NAME = 12,
    VT_INPUTS_TYPE = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS_TYPE = 18,
    VT_OUTPUTS = 20,
    VT_COMPILE_TARGET_TYPE = 22,
    VT_COMPILE_TARGET = 24,
    VT_TAGS = 26
  };
  const ::flatbuffers::Vector<int64_t> *begin() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_BEGIN);
  }
  const ::flatbuffers::Vector<int64_t> *end() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_END);
  }
  const ::flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyVector(end()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Slice::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Slice::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Slice::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Slice::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Slice::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Slice::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Slice::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SliceBuilder {
  typedef Slice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_begin(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> begin) {
    fbb_.AddOffset(Slice::VT_BEGIN, begin);
  }
  void add_end(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> end) {
    fbb_.AddOffset(Slice::VT_END, end);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Slice::VT_STRIDE, stride);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Slice::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Slice::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Slice::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Slice::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Slice::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Slice::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Slice::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Slice::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Slice::VT_TAGS, tags);
  }
  explicit SliceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Slice> CreateSlice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> begin = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> stride = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_stride(stride);
  builder_.add_end(end);
  builder_.add_begin(begin);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Slice> CreateSliceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *begin = nullptr,
    const std::vector<int64_t> *end = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto begin__ = begin ? _fbb.CreateVector<int64_t>(*begin) : 0;
  auto end__ = end ? _fbb.CreateVector<int64_t>(*end) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSlice(
      _fbb,
      begin__,
      end__,
      stride__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoftmaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Softmax::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Softmax::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Softmax::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Softmax::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Softmax::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Softmax::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Softmax::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SoftmaxBuilder {
  typedef Softmax Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Softmax::VT_AXIS, axis, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Softmax::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Softmax::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Softmax::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Softmax::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Softmax::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Softmax::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Softmax::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Softmax::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Softmax::VT_TAGS, tags);
  }
  explicit SoftmaxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Softmax> CreateSoftmax(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_axis(axis);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSoftmax(
      _fbb,
      axis,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Softplus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoftplusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4,
    VT_THRESHOLD = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           VerifyField<float>(verifier, VT_THRESHOLD, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Softplus::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Softplus::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Softplus::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Softplus::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Softplus::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Softplus::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Softplus::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SoftplusBuilder {
  typedef Softplus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(Softplus::VT_BETA, beta, 0.0f);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(Softplus::VT_THRESHOLD, threshold, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Softplus::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Softplus::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Softplus::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Softplus::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Softplus::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Softplus::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Softplus::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Softplus::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Softplus::VT_TAGS, tags);
  }
  explicit SoftplusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Softplus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Softplus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Softplus> CreateSoftplus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f,
    float threshold = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SoftplusBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_threshold(threshold);
  builder_.add_beta(beta);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Softplus> CreateSoftplusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f,
    float threshold = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSoftplus(
      _fbb,
      beta,
      threshold,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Softshrink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoftshrinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAMBDA = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  float lambda() const {
    return GetField<float>(VT_LAMBDA, 0.0f);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LAMBDA, 4) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Softshrink::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Softshrink::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Softshrink::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Softshrink::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Softshrink::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Softshrink::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Softshrink::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SoftshrinkBuilder {
  typedef Softshrink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lambda(float lambda) {
    fbb_.AddElement<float>(Softshrink::VT_LAMBDA, lambda, 0.0f);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Softshrink::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Softshrink::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Softshrink::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Softshrink::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Softshrink::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Softshrink::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Softshrink::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Softshrink::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Softshrink::VT_TAGS, tags);
  }
  explicit SoftshrinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Softshrink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Softshrink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Softshrink> CreateSoftshrink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lambda = 0.0f,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SoftshrinkBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_lambda(lambda);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Softshrink> CreateSoftshrinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lambda = 0.0f,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSoftshrink(
      _fbb,
      lambda,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Softsign FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SoftsignBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Softsign::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Softsign::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Softsign::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Softsign::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Softsign::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Softsign::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Softsign::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SoftsignBuilder {
  typedef Softsign Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Softsign::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Softsign::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Softsign::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Softsign::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Softsign::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Softsign::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Softsign::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Softsign::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Softsign::VT_TAGS, tags);
  }
  explicit SoftsignBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Softsign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Softsign>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Softsign> CreateSoftsign(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SoftsignBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Softsign> CreateSoftsignDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSoftsign(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Split FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SplitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECTIONS = 4,
    VT_AXIS = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *sections() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SECTIONS);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SECTIONS) &&
           verifier.VerifyVector(sections()) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Split::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Split::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Split::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Split::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Split::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Split::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Split::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SplitBuilder {
  typedef Split Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sections(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> sections) {
    fbb_.AddOffset(Split::VT_SECTIONS, sections);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Split::VT_AXIS, axis, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Split::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Split::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Split::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Split::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Split::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Split::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Split::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Split::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Split::VT_TAGS, tags);
  }
  explicit SplitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Split> CreateSplit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> sections = 0,
    int64_t axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_axis(axis);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_sections(sections);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Split> CreateSplitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *sections = nullptr,
    int64_t axis = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto sections__ = sections ? _fbb.CreateVector<int64_t>(*sections) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSplit(
      _fbb,
      sections__,
      axis,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Sqrt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SqrtBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Sqrt::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Sqrt::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Sqrt::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Sqrt::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Sqrt::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Sqrt::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Sqrt::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SqrtBuilder {
  typedef Sqrt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Sqrt::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Sqrt::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Sqrt::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Sqrt::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Sqrt::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Sqrt::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Sqrt::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Sqrt::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Sqrt::VT_TAGS, tags);
  }
  explicit SqrtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sqrt> CreateSqrt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SqrtBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sqrt> CreateSqrtDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSqrt(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Squeeze FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SqueezeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Squeeze::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Squeeze::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Squeeze::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Squeeze::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Squeeze::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Squeeze::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Squeeze::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SqueezeBuilder {
  typedef Squeeze Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Squeeze::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Squeeze::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Squeeze::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Squeeze::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Squeeze::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Squeeze::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Squeeze::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Squeeze::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Squeeze::VT_TAGS, tags);
  }
  explicit SqueezeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Squeeze> CreateSqueeze(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_axis(axis);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSqueeze(
      _fbb,
      axis__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Stack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t dim() const {
    return GetField<int64_t>(VT_DIM, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DIM, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Stack::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Stack::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Stack::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Stack::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Stack::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Stack::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Stack::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct StackBuilder {
  typedef Stack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(int64_t dim) {
    fbb_.AddElement<int64_t>(Stack::VT_DIM, dim, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Stack::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Stack::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Stack::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Stack::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Stack::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Stack::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Stack::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Stack::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Stack::VT_TAGS, tags);
  }
  explicit StackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stack> CreateStack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dim(dim);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Stack> CreateStackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateStack(
      _fbb,
      dim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Sum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIM = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIM);
  }
  bool keepdim() const {
    return GetField<uint8_t>(VT_KEEPDIM, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIM, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Sum::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Sum::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Sum::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Sum::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Sum::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Sum::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Sum::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SumBuilder {
  typedef Sum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dim) {
    fbb_.AddOffset(Sum::VT_DIM, dim);
  }
  void add_keepdim(bool keepdim) {
    fbb_.AddElement<uint8_t>(Sum::VT_KEEPDIM, static_cast<uint8_t>(keepdim), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Sum::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Sum::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Sum::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Sum::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Sum::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Sum::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Sum::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Sum::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Sum::VT_TAGS, tags);
  }
  explicit SumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sum>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sum> CreateSum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dim = 0,
    bool keepdim = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SumBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dim(dim);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_keepdim(keepdim);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sum> CreateSumDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dim = nullptr,
    bool keepdim = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<int64_t>(*dim) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSum(
      _fbb,
      dim__,
      keepdim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct SwapOrder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4,
    VT_AXIS = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *order() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ORDER);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           VerifyField<int64_t>(verifier, VT_AXIS, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *SwapOrder::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *SwapOrder::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *SwapOrder::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *SwapOrder::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *SwapOrder::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *SwapOrder::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *SwapOrder::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct SwapOrderBuilder {
  typedef SwapOrder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_order(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> order) {
    fbb_.AddOffset(SwapOrder::VT_ORDER, order);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(SwapOrder::VT_AXIS, axis, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(SwapOrder::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SwapOrder::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(SwapOrder::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(SwapOrder::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(SwapOrder::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(SwapOrder::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(SwapOrder::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(SwapOrder::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(SwapOrder::VT_TAGS, tags);
  }
  explicit SwapOrderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapOrder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapOrder> CreateSwapOrder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> order = 0,
    int64_t axis = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  SwapOrderBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_axis(axis);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_order(order);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapOrder> CreateSwapOrderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *order = nullptr,
    int64_t axis = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto order__ = order ? _fbb.CreateVector<int64_t>(*order) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateSwapOrder(
      _fbb,
      order__,
      axis,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Tan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Tan::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Tan::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Tan::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Tan::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Tan::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Tan::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Tan::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct TanBuilder {
  typedef Tan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Tan::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tan::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Tan::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Tan::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Tan::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Tan::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Tan::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Tan::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Tan::VT_TAGS, tags);
  }
  explicit TanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tan> CreateTan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  TanBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tan> CreateTanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateTan(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Tanh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TanhBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Tanh::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Tanh::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Tanh::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Tanh::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Tanh::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Tanh::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Tanh::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct TanhBuilder {
  typedef Tanh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Tanh::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tanh::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Tanh::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Tanh::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Tanh::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Tanh::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Tanh::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Tanh::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Tanh::VT_TAGS, tags);
  }
  explicit TanhBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tanh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tanh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tanh> CreateTanh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  TanhBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tanh> CreateTanhDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateTanh(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Tanhshrink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TanhshrinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Tanhshrink::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Tanhshrink::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Tanhshrink::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Tanhshrink::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Tanhshrink::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Tanhshrink::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Tanhshrink::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct TanhshrinkBuilder {
  typedef Tanhshrink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Tanhshrink::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tanhshrink::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Tanhshrink::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Tanhshrink::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Tanhshrink::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Tanhshrink::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Tanhshrink::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Tanhshrink::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Tanhshrink::VT_TAGS, tags);
  }
  explicit TanhshrinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tanhshrink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tanhshrink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tanhshrink> CreateTanhshrink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  TanhshrinkBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tanhshrink> CreateTanhshrinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateTanhshrink(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct TensorType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE_TYPE = 4,
    VT_ELEMENT_DTYPE = 6,
    VT_SHAPE = 8,
    VT_LAYOUT = 10,
    VT_MERGED_DISTRS = 12
  };
  fbs::ScalarType_box element_dtype_type() const {
    return static_cast<fbs::ScalarType_box>(GetField<uint8_t>(VT_ELEMENT_DTYPE_TYPE, 0));
  }
  const void *element_dtype() const {
    return GetPointer<const void *>(VT_ELEMENT_DTYPE);
  }
  template<typename T> const T *element_dtype_as() const;
  const fbs::BoolType *element_dtype_as_BoolType() const {
    return element_dtype_type() == fbs::ScalarType_box_BoolType ? static_cast<const fbs::BoolType *>(element_dtype()) : nullptr;
  }
  const fbs::IntegerType *element_dtype_as_IntegerType() const {
    return element_dtype_type() == fbs::ScalarType_box_IntegerType ? static_cast<const fbs::IntegerType *>(element_dtype()) : nullptr;
  }
  const fbs::FloatType *element_dtype_as_FloatType() const {
    return element_dtype_type() == fbs::ScalarType_box_FloatType ? static_cast<const fbs::FloatType *>(element_dtype()) : nullptr;
  }
  const fbs::CalibratedType *element_dtype_as_CalibratedType() const {
    return element_dtype_type() == fbs::ScalarType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(element_dtype()) : nullptr;
  }
  const fbs::NormalizedType *element_dtype_as_NormalizedType() const {
    return element_dtype_type() == fbs::ScalarType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(element_dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *element_dtype_as_NormalizedQuantizedType() const {
    return element_dtype_type() == fbs::ScalarType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(element_dtype()) : nullptr;
  }
  const fbs::QuantizedType *element_dtype_as_QuantizedType() const {
    return element_dtype_type() == fbs::ScalarType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(element_dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *element_dtype_as_BaseQuantizedType() const {
    return element_dtype_type() == fbs::ScalarType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(element_dtype()) : nullptr;
  }
  const fbs::ScalarType *element_dtype_as_ScalarType() const {
    return element_dtype_type() == fbs::ScalarType_box_ScalarType ? static_cast<const fbs::ScalarType *>(element_dtype()) : nullptr;
  }
  const ::flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  const fbs::Layout *layout() const {
    return GetPointer<const fbs::Layout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::MergedAxisDistr>> *merged_distrs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fbs::MergedAxisDistr>> *>(VT_MERGED_DISTRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_ELEMENT_DTYPE) &&
           VerifyScalarType_box(verifier, element_dtype(), element_dtype_type()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffset(verifier, VT_MERGED_DISTRS) &&
           verifier.VerifyVector(merged_distrs()) &&
           verifier.VerifyVectorOfTables(merged_distrs()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *TensorType::element_dtype_as<fbs::BoolType>() const {
  return element_dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *TensorType::element_dtype_as<fbs::IntegerType>() const {
  return element_dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *TensorType::element_dtype_as<fbs::FloatType>() const {
  return element_dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *TensorType::element_dtype_as<fbs::CalibratedType>() const {
  return element_dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *TensorType::element_dtype_as<fbs::NormalizedType>() const {
  return element_dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *TensorType::element_dtype_as<fbs::NormalizedQuantizedType>() const {
  return element_dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *TensorType::element_dtype_as<fbs::QuantizedType>() const {
  return element_dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *TensorType::element_dtype_as<fbs::BaseQuantizedType>() const {
  return element_dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *TensorType::element_dtype_as<fbs::ScalarType>() const {
  return element_dtype_as_ScalarType();
}

struct TensorTypeBuilder {
  typedef TensorType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_element_dtype_type(fbs::ScalarType_box element_dtype_type) {
    fbb_.AddElement<uint8_t>(TensorType::VT_ELEMENT_DTYPE_TYPE, static_cast<uint8_t>(element_dtype_type), 0);
  }
  void add_element_dtype(::flatbuffers::Offset<void> element_dtype) {
    fbb_.AddOffset(TensorType::VT_ELEMENT_DTYPE, element_dtype);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(TensorType::VT_SHAPE, shape);
  }
  void add_layout(::flatbuffers::Offset<fbs::Layout> layout) {
    fbb_.AddOffset(TensorType::VT_LAYOUT, layout);
  }
  void add_merged_distrs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::MergedAxisDistr>>> merged_distrs) {
    fbb_.AddOffset(TensorType::VT_MERGED_DISTRS, merged_distrs);
  }
  explicit TensorTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorType> CreateTensorType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::ScalarType_box element_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> element_dtype = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape = 0,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fbs::MergedAxisDistr>>> merged_distrs = 0) {
  TensorTypeBuilder builder_(_fbb);
  builder_.add_merged_distrs(merged_distrs);
  builder_.add_layout(layout);
  builder_.add_shape(shape);
  builder_.add_element_dtype(element_dtype);
  builder_.add_element_dtype_type(element_dtype_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorType> CreateTensorTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    fbs::ScalarType_box element_dtype_type = fbs::ScalarType_box_NONE,
    ::flatbuffers::Offset<void> element_dtype = 0,
    const std::vector<int64_t> *shape = nullptr,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    const std::vector<::flatbuffers::Offset<fbs::MergedAxisDistr>> *merged_distrs = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  auto merged_distrs__ = merged_distrs ? _fbb.CreateVector<::flatbuffers::Offset<fbs::MergedAxisDistr>>(*merged_distrs) : 0;
  return fbs::CreateTensorType(
      _fbb,
      element_dtype_type,
      element_dtype,
      shape__,
      layout,
      merged_distrs__);
}

struct Tile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Tile::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Tile::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Tile::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Tile::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Tile::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Tile::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Tile::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct TileBuilder {
  typedef Tile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Tile::VT_DIMS, dims);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Tile::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tile::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Tile::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Tile::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Tile::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Tile::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Tile::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Tile::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Tile::VT_TAGS, tags);
  }
  explicit TileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tile> CreateTile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  TileBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_dims(dims);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tile> CreateTileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dims = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateTile(
      _fbb,
      dims__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Transpose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransposeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_LAYOUT = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  const fbs::Layout *layout() const {
    return GetPointer<const fbs::Layout *>(VT_LAYOUT);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Transpose::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Transpose::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Transpose::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Transpose::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Transpose::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Transpose::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Transpose::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct TransposeBuilder {
  typedef Transpose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Transpose::VT_DIMS, dims);
  }
  void add_layout(::flatbuffers::Offset<fbs::Layout> layout) {
    fbb_.AddOffset(Transpose::VT_LAYOUT, layout);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Transpose::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Transpose::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Transpose::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Transpose::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Transpose::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Transpose::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Transpose::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Transpose::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Transpose::VT_TAGS, tags);
  }
  explicit TransposeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Transpose> CreateTranspose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> dims = 0,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  TransposeBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_layout(layout);
  builder_.add_dims(dims);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Transpose> CreateTransposeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dims = nullptr,
    ::flatbuffers::Offset<fbs::Layout> layout = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateTranspose(
      _fbb,
      dims__,
      layout,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Unfold FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnfoldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_WIDTH = 4,
    VT_KERNEL_HEIGHT = 6,
    VT_STRIDE_WIDTH = 8,
    VT_STRIDE_HEIGHT = 10,
    VT_PAD_TOP = 12,
    VT_PAD_BOTTOM = 14,
    VT_PAD_LEFT = 16,
    VT_PAD_RIGHT = 18,
    VT_DILATION_WIDTH = 20,
    VT_DILATION_HEIGHT = 22,
    VT_OP_ID = 24,
    VT_NAME = 26,
    VT_INPUTS_TYPE = 28,
    VT_INPUTS = 30,
    VT_OUTPUTS_TYPE = 32,
    VT_OUTPUTS = 34,
    VT_COMPILE_TARGET_TYPE = 36,
    VT_COMPILE_TARGET = 38,
    VT_TAGS = 40
  };
  int64_t kernel_width() const {
    return GetField<int64_t>(VT_KERNEL_WIDTH, 0);
  }
  int64_t kernel_height() const {
    return GetField<int64_t>(VT_KERNEL_HEIGHT, 0);
  }
  int64_t stride_width() const {
    return GetField<int64_t>(VT_STRIDE_WIDTH, 0);
  }
  int64_t stride_height() const {
    return GetField<int64_t>(VT_STRIDE_HEIGHT, 0);
  }
  int64_t pad_top() const {
    return GetField<int64_t>(VT_PAD_TOP, 0);
  }
  int64_t pad_bottom() const {
    return GetField<int64_t>(VT_PAD_BOTTOM, 0);
  }
  int64_t pad_left() const {
    return GetField<int64_t>(VT_PAD_LEFT, 0);
  }
  int64_t pad_right() const {
    return GetField<int64_t>(VT_PAD_RIGHT, 0);
  }
  int64_t dilation_width() const {
    return GetField<int64_t>(VT_DILATION_WIDTH, 0);
  }
  int64_t dilation_height() const {
    return GetField<int64_t>(VT_DILATION_HEIGHT, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_KERNEL_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_STRIDE_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_TOP, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_BOTTOM, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_LEFT, 8) &&
           VerifyField<int64_t>(verifier, VT_PAD_RIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_WIDTH, 8) &&
           VerifyField<int64_t>(verifier, VT_DILATION_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Unfold::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Unfold::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Unfold::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Unfold::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Unfold::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Unfold::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Unfold::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct UnfoldBuilder {
  typedef Unfold Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kernel_width(int64_t kernel_width) {
    fbb_.AddElement<int64_t>(Unfold::VT_KERNEL_WIDTH, kernel_width, 0);
  }
  void add_kernel_height(int64_t kernel_height) {
    fbb_.AddElement<int64_t>(Unfold::VT_KERNEL_HEIGHT, kernel_height, 0);
  }
  void add_stride_width(int64_t stride_width) {
    fbb_.AddElement<int64_t>(Unfold::VT_STRIDE_WIDTH, stride_width, 0);
  }
  void add_stride_height(int64_t stride_height) {
    fbb_.AddElement<int64_t>(Unfold::VT_STRIDE_HEIGHT, stride_height, 0);
  }
  void add_pad_top(int64_t pad_top) {
    fbb_.AddElement<int64_t>(Unfold::VT_PAD_TOP, pad_top, 0);
  }
  void add_pad_bottom(int64_t pad_bottom) {
    fbb_.AddElement<int64_t>(Unfold::VT_PAD_BOTTOM, pad_bottom, 0);
  }
  void add_pad_left(int64_t pad_left) {
    fbb_.AddElement<int64_t>(Unfold::VT_PAD_LEFT, pad_left, 0);
  }
  void add_pad_right(int64_t pad_right) {
    fbb_.AddElement<int64_t>(Unfold::VT_PAD_RIGHT, pad_right, 0);
  }
  void add_dilation_width(int64_t dilation_width) {
    fbb_.AddElement<int64_t>(Unfold::VT_DILATION_WIDTH, dilation_width, 0);
  }
  void add_dilation_height(int64_t dilation_height) {
    fbb_.AddElement<int64_t>(Unfold::VT_DILATION_HEIGHT, dilation_height, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Unfold::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Unfold::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Unfold::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Unfold::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Unfold::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Unfold::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Unfold::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Unfold::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Unfold::VT_TAGS, tags);
  }
  explicit UnfoldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unfold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unfold>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unfold> CreateUnfold(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t kernel_width = 0,
    int64_t kernel_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  UnfoldBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dilation_height(dilation_height);
  builder_.add_dilation_width(dilation_width);
  builder_.add_pad_right(pad_right);
  builder_.add_pad_left(pad_left);
  builder_.add_pad_bottom(pad_bottom);
  builder_.add_pad_top(pad_top);
  builder_.add_stride_height(stride_height);
  builder_.add_stride_width(stride_width);
  builder_.add_kernel_height(kernel_height);
  builder_.add_kernel_width(kernel_width);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unfold> CreateUnfoldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t kernel_width = 0,
    int64_t kernel_height = 0,
    int64_t stride_width = 0,
    int64_t stride_height = 0,
    int64_t pad_top = 0,
    int64_t pad_bottom = 0,
    int64_t pad_left = 0,
    int64_t pad_right = 0,
    int64_t dilation_width = 0,
    int64_t dilation_height = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateUnfold(
      _fbb,
      kernel_width,
      kernel_height,
      stride_width,
      stride_height,
      pad_top,
      pad_bottom,
      pad_left,
      pad_right,
      dilation_width,
      dilation_height,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Unknown FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnknownBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_INFO = 4,
    VT_JSON_INFO = 6,
    VT_OP_ID = 8,
    VT_NAME = 10,
    VT_INPUTS_TYPE = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS_TYPE = 16,
    VT_OUTPUTS = 18,
    VT_COMPILE_TARGET_TYPE = 20,
    VT_COMPILE_TARGET = 22,
    VT_TAGS = 24
  };
  const ::flatbuffers::String *msg_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG_INFO);
  }
  const ::flatbuffers::String *json_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSON_INFO);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG_INFO) &&
           verifier.VerifyString(msg_info()) &&
           VerifyOffset(verifier, VT_JSON_INFO) &&
           verifier.VerifyString(json_info()) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Unknown::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Unknown::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Unknown::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Unknown::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Unknown::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Unknown::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Unknown::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct UnknownBuilder {
  typedef Unknown Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_info(::flatbuffers::Offset<::flatbuffers::String> msg_info) {
    fbb_.AddOffset(Unknown::VT_MSG_INFO, msg_info);
  }
  void add_json_info(::flatbuffers::Offset<::flatbuffers::String> json_info) {
    fbb_.AddOffset(Unknown::VT_JSON_INFO, json_info);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Unknown::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Unknown::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Unknown::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Unknown::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Unknown::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Unknown::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Unknown::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Unknown::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Unknown::VT_TAGS, tags);
  }
  explicit UnknownBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unknown> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unknown>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unknown> CreateUnknown(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> msg_info = 0,
    ::flatbuffers::Offset<::flatbuffers::String> json_info = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  UnknownBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_json_info(json_info);
  builder_.add_msg_info(msg_info);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unknown> CreateUnknownDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg_info = nullptr,
    const char *json_info = nullptr,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto msg_info__ = msg_info ? _fbb.CreateString(msg_info) : 0;
  auto json_info__ = json_info ? _fbb.CreateString(json_info) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateUnknown(
      _fbb,
      msg_info__,
      json_info__,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Unstack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnstackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_OP_ID = 6,
    VT_NAME = 8,
    VT_INPUTS_TYPE = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS_TYPE = 14,
    VT_OUTPUTS = 16,
    VT_COMPILE_TARGET_TYPE = 18,
    VT_COMPILE_TARGET = 20,
    VT_TAGS = 22
  };
  int64_t dim() const {
    return GetField<int64_t>(VT_DIM, 0);
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DIM, 8) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Unstack::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Unstack::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Unstack::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Unstack::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Unstack::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Unstack::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Unstack::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct UnstackBuilder {
  typedef Unstack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(int64_t dim) {
    fbb_.AddElement<int64_t>(Unstack::VT_DIM, dim, 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Unstack::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Unstack::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Unstack::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Unstack::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Unstack::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Unstack::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Unstack::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Unstack::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Unstack::VT_TAGS, tags);
  }
  explicit UnstackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unstack> CreateUnstack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim = 0,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_dim(dim);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unstack> CreateUnstackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t dim = 0,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateUnstack(
      _fbb,
      dim,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Unsupport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsupportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Unsupport::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Unsupport::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Unsupport::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Unsupport::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Unsupport::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Unsupport::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Unsupport::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct UnsupportBuilder {
  typedef Unsupport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Unsupport::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Unsupport::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Unsupport::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Unsupport::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Unsupport::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Unsupport::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Unsupport::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Unsupport::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Unsupport::VT_TAGS, tags);
  }
  explicit UnsupportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unsupport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unsupport>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unsupport> CreateUnsupport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  UnsupportBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unsupport> CreateUnsupportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateUnsupport(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Upsample FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpsampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_INTERPOLATION = 8,
    VT_ALIGN_CORNERS = 10,
    VT_OP_ID = 12,
    VT_NAME = 14,
    VT_INPUTS_TYPE = 16,
    VT_INPUTS = 18,
    VT_OUTPUTS_TYPE = 20,
    VT_OUTPUTS = 22,
    VT_COMPILE_TARGET_TYPE = 24,
    VT_COMPILE_TARGET = 26,
    VT_TAGS = 28
  };
  int64_t height() const {
    return GetField<int64_t>(VT_HEIGHT, 0);
  }
  int64_t width() const {
    return GetField<int64_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::String *interpolation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERPOLATION);
  }
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_HEIGHT, 8) &&
           VerifyField<int64_t>(verifier, VT_WIDTH, 8) &&
           VerifyOffset(verifier, VT_INTERPOLATION) &&
           verifier.VerifyString(interpolation()) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Upsample::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Upsample::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Upsample::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Upsample::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Upsample::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Upsample::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Upsample::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct UpsampleBuilder {
  typedef Upsample Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_height(int64_t height) {
    fbb_.AddElement<int64_t>(Upsample::VT_HEIGHT, height, 0);
  }
  void add_width(int64_t width) {
    fbb_.AddElement<int64_t>(Upsample::VT_WIDTH, width, 0);
  }
  void add_interpolation(::flatbuffers::Offset<::flatbuffers::String> interpolation) {
    fbb_.AddOffset(Upsample::VT_INTERPOLATION, interpolation);
  }
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(Upsample::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Upsample::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Upsample::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Upsample::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Upsample::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Upsample::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Upsample::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Upsample::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Upsample::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Upsample::VT_TAGS, tags);
  }
  explicit UpsampleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Upsample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Upsample>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Upsample> CreateUpsample(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::String> interpolation = 0,
    bool align_corners = false,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  UpsampleBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_interpolation(interpolation);
  builder_.add_compile_target_type(compile_target_type);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Upsample> CreateUpsampleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t height = 0,
    int64_t width = 0,
    const char *interpolation = nullptr,
    bool align_corners = false,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto interpolation__ = interpolation ? _fbb.CreateString(interpolation) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateUpsample(
      _fbb,
      height,
      width,
      interpolation__,
      align_corners,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V_ID = 4,
    VT_NAME = 6,
    VT_TAGS = 8,
    VT_DTYPE_TYPE = 10,
    VT_DTYPE = 12,
    VT_MTYPE_TYPE = 14,
    VT_MTYPE = 16
  };
  int64_t v_id() const {
    return GetField<int64_t>(VT_V_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  fbs::DataType_box dtype_type() const {
    return static_cast<fbs::DataType_box>(GetField<uint8_t>(VT_DTYPE_TYPE, 0));
  }
  const void *dtype() const {
    return GetPointer<const void *>(VT_DTYPE);
  }
  template<typename T> const T *dtype_as() const;
  const fbs::BoolType *dtype_as_BoolType() const {
    return dtype_type() == fbs::DataType_box_BoolType ? static_cast<const fbs::BoolType *>(dtype()) : nullptr;
  }
  const fbs::IntegerType *dtype_as_IntegerType() const {
    return dtype_type() == fbs::DataType_box_IntegerType ? static_cast<const fbs::IntegerType *>(dtype()) : nullptr;
  }
  const fbs::FloatType *dtype_as_FloatType() const {
    return dtype_type() == fbs::DataType_box_FloatType ? static_cast<const fbs::FloatType *>(dtype()) : nullptr;
  }
  const fbs::CalibratedType *dtype_as_CalibratedType() const {
    return dtype_type() == fbs::DataType_box_CalibratedType ? static_cast<const fbs::CalibratedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedType *dtype_as_NormalizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedType ? static_cast<const fbs::NormalizedType *>(dtype()) : nullptr;
  }
  const fbs::NormalizedQuantizedType *dtype_as_NormalizedQuantizedType() const {
    return dtype_type() == fbs::DataType_box_NormalizedQuantizedType ? static_cast<const fbs::NormalizedQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::QuantizedType *dtype_as_QuantizedType() const {
    return dtype_type() == fbs::DataType_box_QuantizedType ? static_cast<const fbs::QuantizedType *>(dtype()) : nullptr;
  }
  const fbs::BaseQuantizedType *dtype_as_BaseQuantizedType() const {
    return dtype_type() == fbs::DataType_box_BaseQuantizedType ? static_cast<const fbs::BaseQuantizedType *>(dtype()) : nullptr;
  }
  const fbs::ScalarType *dtype_as_ScalarType() const {
    return dtype_type() == fbs::DataType_box_ScalarType ? static_cast<const fbs::ScalarType *>(dtype()) : nullptr;
  }
  const fbs::TensorType *dtype_as_TensorType() const {
    return dtype_type() == fbs::DataType_box_TensorType ? static_cast<const fbs::TensorType *>(dtype()) : nullptr;
  }
  const fbs::DataType *dtype_as_DataType() const {
    return dtype_type() == fbs::DataType_box_DataType ? static_cast<const fbs::DataType *>(dtype()) : nullptr;
  }
  fbs::MemType_box mtype_type() const {
    return static_cast<fbs::MemType_box>(GetField<uint8_t>(VT_MTYPE_TYPE, 0));
  }
  const void *mtype() const {
    return GetPointer<const void *>(VT_MTYPE);
  }
  template<typename T> const T *mtype_as() const;
  const fbs::HostMem *mtype_as_HostMem() const {
    return mtype_type() == fbs::MemType_box_HostMem ? static_cast<const fbs::HostMem *>(mtype()) : nullptr;
  }
  const fbs::OnChipMem *mtype_as_OnChipMem() const {
    return mtype_type() == fbs::MemType_box_OnChipMem ? static_cast<const fbs::OnChipMem *>(mtype()) : nullptr;
  }
  const fbs::ExternalMem *mtype_as_ExternalMem() const {
    return mtype_type() == fbs::MemType_box_ExternalMem ? static_cast<const fbs::ExternalMem *>(mtype()) : nullptr;
  }
  const fbs::ChunkMem *mtype_as_ChunkMem() const {
    return mtype_type() == fbs::MemType_box_ChunkMem ? static_cast<const fbs::ChunkMem *>(mtype()) : nullptr;
  }
  const fbs::MemType *mtype_as_MemType() const {
    return mtype_type() == fbs::MemType_box_MemType ? static_cast<const fbs::MemType *>(mtype()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DTYPE) &&
           VerifyDataType_box(verifier, dtype(), dtype_type()) &&
           VerifyField<uint8_t>(verifier, VT_MTYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MTYPE) &&
           VerifyMemType_box(verifier, mtype(), mtype_type()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::BoolType *Value::dtype_as<fbs::BoolType>() const {
  return dtype_as_BoolType();
}

template<> inline const fbs::IntegerType *Value::dtype_as<fbs::IntegerType>() const {
  return dtype_as_IntegerType();
}

template<> inline const fbs::FloatType *Value::dtype_as<fbs::FloatType>() const {
  return dtype_as_FloatType();
}

template<> inline const fbs::CalibratedType *Value::dtype_as<fbs::CalibratedType>() const {
  return dtype_as_CalibratedType();
}

template<> inline const fbs::NormalizedType *Value::dtype_as<fbs::NormalizedType>() const {
  return dtype_as_NormalizedType();
}

template<> inline const fbs::NormalizedQuantizedType *Value::dtype_as<fbs::NormalizedQuantizedType>() const {
  return dtype_as_NormalizedQuantizedType();
}

template<> inline const fbs::QuantizedType *Value::dtype_as<fbs::QuantizedType>() const {
  return dtype_as_QuantizedType();
}

template<> inline const fbs::BaseQuantizedType *Value::dtype_as<fbs::BaseQuantizedType>() const {
  return dtype_as_BaseQuantizedType();
}

template<> inline const fbs::ScalarType *Value::dtype_as<fbs::ScalarType>() const {
  return dtype_as_ScalarType();
}

template<> inline const fbs::TensorType *Value::dtype_as<fbs::TensorType>() const {
  return dtype_as_TensorType();
}

template<> inline const fbs::DataType *Value::dtype_as<fbs::DataType>() const {
  return dtype_as_DataType();
}

template<> inline const fbs::HostMem *Value::mtype_as<fbs::HostMem>() const {
  return mtype_as_HostMem();
}

template<> inline const fbs::OnChipMem *Value::mtype_as<fbs::OnChipMem>() const {
  return mtype_as_OnChipMem();
}

template<> inline const fbs::ExternalMem *Value::mtype_as<fbs::ExternalMem>() const {
  return mtype_as_ExternalMem();
}

template<> inline const fbs::ChunkMem *Value::mtype_as<fbs::ChunkMem>() const {
  return mtype_as_ChunkMem();
}

template<> inline const fbs::MemType *Value::mtype_as<fbs::MemType>() const {
  return mtype_as_MemType();
}

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v_id(int64_t v_id) {
    fbb_.AddElement<int64_t>(Value::VT_V_ID, v_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Value::VT_NAME, name);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Value::VT_TAGS, tags);
  }
  void add_dtype_type(fbs::DataType_box dtype_type) {
    fbb_.AddElement<uint8_t>(Value::VT_DTYPE_TYPE, static_cast<uint8_t>(dtype_type), 0);
  }
  void add_dtype(::flatbuffers::Offset<void> dtype) {
    fbb_.AddOffset(Value::VT_DTYPE, dtype);
  }
  void add_mtype_type(fbs::MemType_box mtype_type) {
    fbb_.AddElement<uint8_t>(Value::VT_MTYPE_TYPE, static_cast<uint8_t>(mtype_type), 0);
  }
  void add_mtype(::flatbuffers::Offset<void> mtype) {
    fbb_.AddOffset(Value::VT_MTYPE, mtype);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_v_id(v_id);
  builder_.add_mtype(mtype);
  builder_.add_dtype(dtype);
  builder_.add_tags(tags);
  builder_.add_name(name);
  builder_.add_mtype_type(mtype_type);
  builder_.add_dtype_type(dtype_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Value> CreateValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v_id = 0,
    const char *name = nullptr,
    const char *tags = nullptr,
    fbs::DataType_box dtype_type = fbs::DataType_box_NONE,
    ::flatbuffers::Offset<void> dtype = 0,
    fbs::MemType_box mtype_type = fbs::MemType_box_NONE,
    ::flatbuffers::Offset<void> mtype = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateValue(
      _fbb,
      v_id,
      name__,
      tags__,
      dtype_type,
      dtype,
      mtype_type,
      mtype);
}

struct Where FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhereBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_NAME = 6,
    VT_INPUTS_TYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS_TYPE = 12,
    VT_OUTPUTS = 14,
    VT_COMPILE_TARGET_TYPE = 16,
    VT_COMPILE_TARGET = 18,
    VT_TAGS = 20
  };
  int64_t op_id() const {
    return GetField<int64_t>(VT_OP_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *inputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint8_t> *outputs_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OUTPUTS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_OUTPUTS);
  }
  fbs::CompileTarget_box compile_target_type() const {
    return static_cast<fbs::CompileTarget_box>(GetField<uint8_t>(VT_COMPILE_TARGET_TYPE, 0));
  }
  const void *compile_target() const {
    return GetPointer<const void *>(VT_COMPILE_TARGET);
  }
  template<typename T> const T *compile_target_as() const;
  const fbs::HostTarget *compile_target_as_HostTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_HostTarget ? static_cast<const fbs::HostTarget *>(compile_target()) : nullptr;
  }
  const fbs::FPGATarget *compile_target_as_FPGATarget() const {
    return compile_target_type() == fbs::CompileTarget_box_FPGATarget ? static_cast<const fbs::FPGATarget *>(compile_target()) : nullptr;
  }
  const fbs::CustomTarget *compile_target_as_CustomTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CustomTarget ? static_cast<const fbs::CustomTarget *>(compile_target()) : nullptr;
  }
  const fbs::BuyiTarget *compile_target_as_BuyiTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_BuyiTarget ? static_cast<const fbs::BuyiTarget *>(compile_target()) : nullptr;
  }
  const fbs::ZhugeTarget *compile_target_as_ZhugeTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_ZhugeTarget ? static_cast<const fbs::ZhugeTarget *>(compile_target()) : nullptr;
  }
  const fbs::WolongTarget *compile_target_as_WolongTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_WolongTarget ? static_cast<const fbs::WolongTarget *>(compile_target()) : nullptr;
  }
  const fbs::CompileTarget *compile_target_as_CompileTarget() const {
    return compile_target_type() == fbs::CompileTarget_box_CompileTarget ? static_cast<const fbs::CompileTarget *>(compile_target()) : nullptr;
  }
  const ::flatbuffers::String *tags() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OP_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS_TYPE) &&
           verifier.VerifyVector(inputs_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyValue_boxVector(verifier, inputs(), inputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS_TYPE) &&
           verifier.VerifyVector(outputs_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyValue_boxVector(verifier, outputs(), outputs_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE_TARGET_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPILE_TARGET) &&
           VerifyCompileTarget_box(verifier, compile_target(), compile_target_type()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyString(tags()) &&
           verifier.EndTable();
  }
};

template<> inline const fbs::HostTarget *Where::compile_target_as<fbs::HostTarget>() const {
  return compile_target_as_HostTarget();
}

template<> inline const fbs::FPGATarget *Where::compile_target_as<fbs::FPGATarget>() const {
  return compile_target_as_FPGATarget();
}

template<> inline const fbs::CustomTarget *Where::compile_target_as<fbs::CustomTarget>() const {
  return compile_target_as_CustomTarget();
}

template<> inline const fbs::BuyiTarget *Where::compile_target_as<fbs::BuyiTarget>() const {
  return compile_target_as_BuyiTarget();
}

template<> inline const fbs::ZhugeTarget *Where::compile_target_as<fbs::ZhugeTarget>() const {
  return compile_target_as_ZhugeTarget();
}

template<> inline const fbs::WolongTarget *Where::compile_target_as<fbs::WolongTarget>() const {
  return compile_target_as_WolongTarget();
}

template<> inline const fbs::CompileTarget *Where::compile_target_as<fbs::CompileTarget>() const {
  return compile_target_as_CompileTarget();
}

struct WhereBuilder {
  typedef Where Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_id(int64_t op_id) {
    fbb_.AddElement<int64_t>(Where::VT_OP_ID, op_id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Where::VT_NAME, name);
  }
  void add_inputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type) {
    fbb_.AddOffset(Where::VT_INPUTS_TYPE, inputs_type);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs) {
    fbb_.AddOffset(Where::VT_INPUTS, inputs);
  }
  void add_outputs_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type) {
    fbb_.AddOffset(Where::VT_OUTPUTS_TYPE, outputs_type);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs) {
    fbb_.AddOffset(Where::VT_OUTPUTS, outputs);
  }
  void add_compile_target_type(fbs::CompileTarget_box compile_target_type) {
    fbb_.AddElement<uint8_t>(Where::VT_COMPILE_TARGET_TYPE, static_cast<uint8_t>(compile_target_type), 0);
  }
  void add_compile_target(::flatbuffers::Offset<void> compile_target) {
    fbb_.AddOffset(Where::VT_COMPILE_TARGET, compile_target);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::String> tags) {
    fbb_.AddOffset(Where::VT_TAGS, tags);
  }
  explicit WhereBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Where> CreateWhere(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> inputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> outputs_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> outputs = 0,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tags = 0) {
  WhereBuilder builder_(_fbb);
  builder_.add_op_id(op_id);
  builder_.add_tags(tags);
  builder_.add_compile_target(compile_target);
  builder_.add_outputs(outputs);
  builder_.add_outputs_type(outputs_type);
  builder_.add_inputs(inputs);
  builder_.add_inputs_type(inputs_type);
  builder_.add_name(name);
  builder_.add_compile_target_type(compile_target_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Where> CreateWhereDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t op_id = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *inputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *inputs = nullptr,
    const std::vector<uint8_t> *outputs_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *outputs = nullptr,
    fbs::CompileTarget_box compile_target_type = fbs::CompileTarget_box_NONE,
    ::flatbuffers::Offset<void> compile_target = 0,
    const char *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs_type__ = inputs_type ? _fbb.CreateVector<uint8_t>(*inputs_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*inputs) : 0;
  auto outputs_type__ = outputs_type ? _fbb.CreateVector<uint8_t>(*outputs_type) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*outputs) : 0;
  auto tags__ = tags ? _fbb.CreateString(tags) : 0;
  return fbs::CreateWhere(
      _fbb,
      op_id,
      name__,
      inputs_type__,
      inputs__,
      outputs_type__,
      outputs__,
      compile_target_type,
      compile_target,
      tags__);
}

struct WolongTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WolongTargetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WolongTargetBuilder {
  typedef WolongTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit WolongTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WolongTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WolongTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WolongTarget> CreateWolongTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  WolongTargetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZhugeTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZhugeTargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORE = 4
  };
  const ::flatbuffers::String *core() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CORE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CORE) &&
           verifier.VerifyString(core()) &&
           verifier.EndTable();
  }
};

struct ZhugeTargetBuilder {
  typedef ZhugeTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_core(::flatbuffers::Offset<::flatbuffers::String> core) {
    fbb_.AddOffset(ZhugeTarget::VT_CORE, core);
  }
  explicit ZhugeTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZhugeTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZhugeTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZhugeTarget> CreateZhugeTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> core = 0) {
  ZhugeTargetBuilder builder_(_fbb);
  builder_.add_core(core);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ZhugeTarget> CreateZhugeTargetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *core = nullptr) {
  auto core__ = core ? _fbb.CreateString(core) : 0;
  return fbs::CreateZhugeTarget(
      _fbb,
      core__);
}

inline bool VerifyAxisName_box(::flatbuffers::Verifier &verifier, const void *obj, AxisName_box type) {
  switch (type) {
    case AxisName_box_NONE: {
      return true;
    }
    case AxisName_box_AxisUnit: {
      auto ptr = reinterpret_cast<const fbs::AxisUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AxisName_box_AxisName: {
      auto ptr = reinterpret_cast<const fbs::AxisName *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAxisName_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAxisName_box(
        verifier,  values->Get(i), types->GetEnum<AxisName_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBaseQuantizedType_box(::flatbuffers::Verifier &verifier, const void *obj, BaseQuantizedType_box type) {
  switch (type) {
    case BaseQuantizedType_box_NONE: {
      return true;
    }
    case BaseQuantizedType_box_CalibratedType: {
      auto ptr = reinterpret_cast<const fbs::CalibratedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BaseQuantizedType_box_NormalizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BaseQuantizedType_box_NormalizedQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BaseQuantizedType_box_QuantizedType: {
      auto ptr = reinterpret_cast<const fbs::QuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BaseQuantizedType_box_BaseQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::BaseQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBaseQuantizedType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBaseQuantizedType_box(
        verifier,  values->Get(i), types->GetEnum<BaseQuantizedType_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCompileTarget_box(::flatbuffers::Verifier &verifier, const void *obj, CompileTarget_box type) {
  switch (type) {
    case CompileTarget_box_NONE: {
      return true;
    }
    case CompileTarget_box_HostTarget: {
      auto ptr = reinterpret_cast<const fbs::HostTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_FPGATarget: {
      auto ptr = reinterpret_cast<const fbs::FPGATarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_CustomTarget: {
      auto ptr = reinterpret_cast<const fbs::CustomTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_BuyiTarget: {
      auto ptr = reinterpret_cast<const fbs::BuyiTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_ZhugeTarget: {
      auto ptr = reinterpret_cast<const fbs::ZhugeTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_WolongTarget: {
      auto ptr = reinterpret_cast<const fbs::WolongTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompileTarget_box_CompileTarget: {
      auto ptr = reinterpret_cast<const fbs::CompileTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCompileTarget_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCompileTarget_box(
        verifier,  values->Get(i), types->GetEnum<CompileTarget_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyData_box(::flatbuffers::Verifier &verifier, const void *obj, Data_box type) {
  switch (type) {
    case Data_box_NONE: {
      return true;
    }
    case Data_box_Bool: {
      auto ptr = reinterpret_cast<const fbs::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_IntImm: {
      auto ptr = reinterpret_cast<const fbs::IntImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_FloatImm: {
      auto ptr = reinterpret_cast<const fbs::FloatImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_ScalarImm: {
      auto ptr = reinterpret_cast<const fbs::ScalarImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_Params: {
      auto ptr = reinterpret_cast<const fbs::Params *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_Value: {
      auto ptr = reinterpret_cast<const fbs::Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_box_Data: {
      auto ptr = reinterpret_cast<const fbs::Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyData_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData_box(
        verifier,  values->Get(i), types->GetEnum<Data_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDataType_box(::flatbuffers::Verifier &verifier, const void *obj, DataType_box type) {
  switch (type) {
    case DataType_box_NONE: {
      return true;
    }
    case DataType_box_BoolType: {
      auto ptr = reinterpret_cast<const fbs::BoolType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_IntegerType: {
      auto ptr = reinterpret_cast<const fbs::IntegerType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_FloatType: {
      auto ptr = reinterpret_cast<const fbs::FloatType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_CalibratedType: {
      auto ptr = reinterpret_cast<const fbs::CalibratedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_NormalizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_NormalizedQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_QuantizedType: {
      auto ptr = reinterpret_cast<const fbs::QuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_BaseQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::BaseQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_ScalarType: {
      auto ptr = reinterpret_cast<const fbs::ScalarType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_TensorType: {
      auto ptr = reinterpret_cast<const fbs::TensorType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataType_box_DataType: {
      auto ptr = reinterpret_cast<const fbs::DataType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataType_box(
        verifier,  values->Get(i), types->GetEnum<DataType_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMemType_box(::flatbuffers::Verifier &verifier, const void *obj, MemType_box type) {
  switch (type) {
    case MemType_box_NONE: {
      return true;
    }
    case MemType_box_HostMem: {
      auto ptr = reinterpret_cast<const fbs::HostMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MemType_box_OnChipMem: {
      auto ptr = reinterpret_cast<const fbs::OnChipMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MemType_box_ExternalMem: {
      auto ptr = reinterpret_cast<const fbs::ExternalMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MemType_box_ChunkMem: {
      auto ptr = reinterpret_cast<const fbs::ChunkMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MemType_box_MemType: {
      auto ptr = reinterpret_cast<const fbs::MemType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMemType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMemType_box(
        verifier,  values->Get(i), types->GetEnum<MemType_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyNetworkBase_box(::flatbuffers::Verifier &verifier, const void *obj, NetworkBase_box type) {
  switch (type) {
    case NetworkBase_box_NONE: {
      return true;
    }
    case NetworkBase_box_Network: {
      auto ptr = reinterpret_cast<const fbs::Network *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NetworkBase_box_NetworkBase: {
      auto ptr = reinterpret_cast<const fbs::NetworkBase *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNetworkBase_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNetworkBase_box(
        verifier,  values->Get(i), types->GetEnum<NetworkBase_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyObjectRef_box(::flatbuffers::Verifier &verifier, const void *obj, ObjectRef_box type) {
  switch (type) {
    case ObjectRef_box_NONE: {
      return true;
    }
    case ObjectRef_box_HostTarget: {
      auto ptr = reinterpret_cast<const fbs::HostTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_FPGATarget: {
      auto ptr = reinterpret_cast<const fbs::FPGATarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_CustomTarget: {
      auto ptr = reinterpret_cast<const fbs::CustomTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BuyiTarget: {
      auto ptr = reinterpret_cast<const fbs::BuyiTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ZhugeTarget: {
      auto ptr = reinterpret_cast<const fbs::ZhugeTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_WolongTarget: {
      auto ptr = reinterpret_cast<const fbs::WolongTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_CompileTarget: {
      auto ptr = reinterpret_cast<const fbs::CompileTarget *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Bool: {
      auto ptr = reinterpret_cast<const fbs::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_IntImm: {
      auto ptr = reinterpret_cast<const fbs::IntImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_FloatImm: {
      auto ptr = reinterpret_cast<const fbs::FloatImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ScalarImm: {
      auto ptr = reinterpret_cast<const fbs::ScalarImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Params: {
      auto ptr = reinterpret_cast<const fbs::Params *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Value: {
      auto ptr = reinterpret_cast<const fbs::Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Data: {
      auto ptr = reinterpret_cast<const fbs::Data *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BoolType: {
      auto ptr = reinterpret_cast<const fbs::BoolType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_IntegerType: {
      auto ptr = reinterpret_cast<const fbs::IntegerType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_FloatType: {
      auto ptr = reinterpret_cast<const fbs::FloatType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_CalibratedType: {
      auto ptr = reinterpret_cast<const fbs::CalibratedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_NormalizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_NormalizedQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_QuantizedType: {
      auto ptr = reinterpret_cast<const fbs::QuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BaseQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::BaseQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ScalarType: {
      auto ptr = reinterpret_cast<const fbs::ScalarType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_TensorType: {
      auto ptr = reinterpret_cast<const fbs::TensorType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_DataType: {
      auto ptr = reinterpret_cast<const fbs::DataType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_MergedAxisDistr: {
      auto ptr = reinterpret_cast<const fbs::MergedAxisDistr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_NormratioArray: {
      auto ptr = reinterpret_cast<const fbs::NormratioArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ExpQuantizedScale: {
      auto ptr = reinterpret_cast<const fbs::ExpQuantizedScale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_QuantizedScale: {
      auto ptr = reinterpret_cast<const fbs::QuantizedScale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ExpQuantizedScaleArray: {
      auto ptr = reinterpret_cast<const fbs::ExpQuantizedScaleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_QuantizedScaleArray: {
      auto ptr = reinterpret_cast<const fbs::QuantizedScaleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AxisUnit: {
      auto ptr = reinterpret_cast<const fbs::AxisUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AxisName: {
      auto ptr = reinterpret_cast<const fbs::AxisName *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Layout: {
      auto ptr = reinterpret_cast<const fbs::Layout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_HostMem: {
      auto ptr = reinterpret_cast<const fbs::HostMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_OnChipMem: {
      auto ptr = reinterpret_cast<const fbs::OnChipMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ExternalMem: {
      auto ptr = reinterpret_cast<const fbs::ExternalMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ChunkMem: {
      auto ptr = reinterpret_cast<const fbs::ChunkMem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_MemType: {
      auto ptr = reinterpret_cast<const fbs::MemType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Network: {
      auto ptr = reinterpret_cast<const fbs::Network *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_NetworkBase: {
      auto ptr = reinterpret_cast<const fbs::NetworkBase *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Input: {
      auto ptr = reinterpret_cast<const fbs::Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Output: {
      auto ptr = reinterpret_cast<const fbs::Output *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Abs: {
      auto ptr = reinterpret_cast<const fbs::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ACos: {
      auto ptr = reinterpret_cast<const fbs::ACos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ACosh: {
      auto ptr = reinterpret_cast<const fbs::ACosh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Add: {
      auto ptr = reinterpret_cast<const fbs::Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AlignAxis: {
      auto ptr = reinterpret_cast<const fbs::AlignAxis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Argmax: {
      auto ptr = reinterpret_cast<const fbs::Argmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Argmin: {
      auto ptr = reinterpret_cast<const fbs::Argmin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ASin: {
      auto ptr = reinterpret_cast<const fbs::ASin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ASinh: {
      auto ptr = reinterpret_cast<const fbs::ASinh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ATan: {
      auto ptr = reinterpret_cast<const fbs::ATan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ATanh: {
      auto ptr = reinterpret_cast<const fbs::ATanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AvgPool1d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AvgPool2d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AvgPool3d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BatchNorm1d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BatchNorm2d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_BatchNorm3d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Cast: {
      auto ptr = reinterpret_cast<const fbs::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ChannelShuffle: {
      auto ptr = reinterpret_cast<const fbs::ChannelShuffle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ClampScalar: {
      auto ptr = reinterpret_cast<const fbs::ClampScalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Concat: {
      auto ptr = reinterpret_cast<const fbs::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Conv1d: {
      auto ptr = reinterpret_cast<const fbs::Conv1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Conv2d: {
      auto ptr = reinterpret_cast<const fbs::Conv2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Conv3d: {
      auto ptr = reinterpret_cast<const fbs::Conv3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ConvTranspose1d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ConvTranspose2d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ConvTranspose3d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Copy: {
      auto ptr = reinterpret_cast<const fbs::Copy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Cos: {
      auto ptr = reinterpret_cast<const fbs::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Cosh: {
      auto ptr = reinterpret_cast<const fbs::Cosh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Div: {
      auto ptr = reinterpret_cast<const fbs::Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_DivideScalar: {
      auto ptr = reinterpret_cast<const fbs::DivideScalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Einsum: {
      auto ptr = reinterpret_cast<const fbs::Einsum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ELU: {
      auto ptr = reinterpret_cast<const fbs::ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Equal: {
      auto ptr = reinterpret_cast<const fbs::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Expand: {
      auto ptr = reinterpret_cast<const fbs::Expand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_GELU: {
      auto ptr = reinterpret_cast<const fbs::GELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Greater: {
      auto ptr = reinterpret_cast<const fbs::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_GreaterEqual: {
      auto ptr = reinterpret_cast<const fbs::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_HardOp: {
      auto ptr = reinterpret_cast<const fbs::HardOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Hardshrink: {
      auto ptr = reinterpret_cast<const fbs::Hardshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Hardsigmoid: {
      auto ptr = reinterpret_cast<const fbs::Hardsigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Hardswish: {
      auto ptr = reinterpret_cast<const fbs::Hardswish *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Hardtanh: {
      auto ptr = reinterpret_cast<const fbs::Hardtanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_InstanceNorm1d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_InstanceNorm2d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_InstanceNorm3d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_LayerNorm: {
      auto ptr = reinterpret_cast<const fbs::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Less: {
      auto ptr = reinterpret_cast<const fbs::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_LessEqual: {
      auto ptr = reinterpret_cast<const fbs::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Log: {
      auto ptr = reinterpret_cast<const fbs::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_LogSigmoid: {
      auto ptr = reinterpret_cast<const fbs::LogSigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_LogSoftmax: {
      auto ptr = reinterpret_cast<const fbs::LogSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Matmul: {
      auto ptr = reinterpret_cast<const fbs::Matmul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Max: {
      auto ptr = reinterpret_cast<const fbs::Max *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Maximum: {
      auto ptr = reinterpret_cast<const fbs::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_MaxPool1d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_MaxPool2d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_MaxPool3d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Mean: {
      auto ptr = reinterpret_cast<const fbs::Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Min: {
      auto ptr = reinterpret_cast<const fbs::Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Minimum: {
      auto ptr = reinterpret_cast<const fbs::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Mish: {
      auto ptr = reinterpret_cast<const fbs::Mish *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Multiply: {
      auto ptr = reinterpret_cast<const fbs::Multiply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Neg: {
      auto ptr = reinterpret_cast<const fbs::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Normalize: {
      auto ptr = reinterpret_cast<const fbs::Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Not: {
      auto ptr = reinterpret_cast<const fbs::Not *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_NotEqual: {
      auto ptr = reinterpret_cast<const fbs::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Pad: {
      auto ptr = reinterpret_cast<const fbs::Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_PixelShuffle: {
      auto ptr = reinterpret_cast<const fbs::PixelShuffle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Pow: {
      auto ptr = reinterpret_cast<const fbs::Pow *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_PReLU: {
      auto ptr = reinterpret_cast<const fbs::PReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_PruneAxis: {
      auto ptr = reinterpret_cast<const fbs::PruneAxis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ReLU: {
      auto ptr = reinterpret_cast<const fbs::ReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Reshape: {
      auto ptr = reinterpret_cast<const fbs::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Resize: {
      auto ptr = reinterpret_cast<const fbs::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Roll: {
      auto ptr = reinterpret_cast<const fbs::Roll *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Sigmoid: {
      auto ptr = reinterpret_cast<const fbs::Sigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_SiLU: {
      auto ptr = reinterpret_cast<const fbs::SiLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Sin: {
      auto ptr = reinterpret_cast<const fbs::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Sinh: {
      auto ptr = reinterpret_cast<const fbs::Sinh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Slice: {
      auto ptr = reinterpret_cast<const fbs::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Softmax: {
      auto ptr = reinterpret_cast<const fbs::Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Softplus: {
      auto ptr = reinterpret_cast<const fbs::Softplus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Softshrink: {
      auto ptr = reinterpret_cast<const fbs::Softshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Softsign: {
      auto ptr = reinterpret_cast<const fbs::Softsign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Split: {
      auto ptr = reinterpret_cast<const fbs::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Sqrt: {
      auto ptr = reinterpret_cast<const fbs::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Squeeze: {
      auto ptr = reinterpret_cast<const fbs::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Stack: {
      auto ptr = reinterpret_cast<const fbs::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Sum: {
      auto ptr = reinterpret_cast<const fbs::Sum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_SwapOrder: {
      auto ptr = reinterpret_cast<const fbs::SwapOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Tan: {
      auto ptr = reinterpret_cast<const fbs::Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Tanh: {
      auto ptr = reinterpret_cast<const fbs::Tanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Tanhshrink: {
      auto ptr = reinterpret_cast<const fbs::Tanhshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Tile: {
      auto ptr = reinterpret_cast<const fbs::Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Transpose: {
      auto ptr = reinterpret_cast<const fbs::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Unfold: {
      auto ptr = reinterpret_cast<const fbs::Unfold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Unknown: {
      auto ptr = reinterpret_cast<const fbs::Unknown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Unstack: {
      auto ptr = reinterpret_cast<const fbs::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Unsupport: {
      auto ptr = reinterpret_cast<const fbs::Unsupport *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Upsample: {
      auto ptr = reinterpret_cast<const fbs::Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Where: {
      auto ptr = reinterpret_cast<const fbs::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_Operation: {
      auto ptr = reinterpret_cast<const fbs::Operation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_AlignedUnit: {
      auto ptr = reinterpret_cast<const fbs::AlignedUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectRef_box_ObjectRef: {
      auto ptr = reinterpret_cast<const fbs::ObjectRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectRef_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectRef_box(
        verifier,  values->Get(i), types->GetEnum<ObjectRef_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOperation_box(::flatbuffers::Verifier &verifier, const void *obj, Operation_box type) {
  switch (type) {
    case Operation_box_NONE: {
      return true;
    }
    case Operation_box_Input: {
      auto ptr = reinterpret_cast<const fbs::Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Output: {
      auto ptr = reinterpret_cast<const fbs::Output *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Abs: {
      auto ptr = reinterpret_cast<const fbs::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ACos: {
      auto ptr = reinterpret_cast<const fbs::ACos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ACosh: {
      auto ptr = reinterpret_cast<const fbs::ACosh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Add: {
      auto ptr = reinterpret_cast<const fbs::Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_AlignAxis: {
      auto ptr = reinterpret_cast<const fbs::AlignAxis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Argmax: {
      auto ptr = reinterpret_cast<const fbs::Argmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Argmin: {
      auto ptr = reinterpret_cast<const fbs::Argmin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ASin: {
      auto ptr = reinterpret_cast<const fbs::ASin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ASinh: {
      auto ptr = reinterpret_cast<const fbs::ASinh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ATan: {
      auto ptr = reinterpret_cast<const fbs::ATan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ATanh: {
      auto ptr = reinterpret_cast<const fbs::ATanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_AvgPool1d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_AvgPool2d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_AvgPool3d: {
      auto ptr = reinterpret_cast<const fbs::AvgPool3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_BatchNorm1d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_BatchNorm2d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_BatchNorm3d: {
      auto ptr = reinterpret_cast<const fbs::BatchNorm3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Cast: {
      auto ptr = reinterpret_cast<const fbs::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ChannelShuffle: {
      auto ptr = reinterpret_cast<const fbs::ChannelShuffle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ClampScalar: {
      auto ptr = reinterpret_cast<const fbs::ClampScalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Concat: {
      auto ptr = reinterpret_cast<const fbs::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Conv1d: {
      auto ptr = reinterpret_cast<const fbs::Conv1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Conv2d: {
      auto ptr = reinterpret_cast<const fbs::Conv2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Conv3d: {
      auto ptr = reinterpret_cast<const fbs::Conv3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ConvTranspose1d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ConvTranspose2d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ConvTranspose3d: {
      auto ptr = reinterpret_cast<const fbs::ConvTranspose3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Copy: {
      auto ptr = reinterpret_cast<const fbs::Copy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Cos: {
      auto ptr = reinterpret_cast<const fbs::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Cosh: {
      auto ptr = reinterpret_cast<const fbs::Cosh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Div: {
      auto ptr = reinterpret_cast<const fbs::Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_DivideScalar: {
      auto ptr = reinterpret_cast<const fbs::DivideScalar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Einsum: {
      auto ptr = reinterpret_cast<const fbs::Einsum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ELU: {
      auto ptr = reinterpret_cast<const fbs::ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Equal: {
      auto ptr = reinterpret_cast<const fbs::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Expand: {
      auto ptr = reinterpret_cast<const fbs::Expand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_GELU: {
      auto ptr = reinterpret_cast<const fbs::GELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Greater: {
      auto ptr = reinterpret_cast<const fbs::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_GreaterEqual: {
      auto ptr = reinterpret_cast<const fbs::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_HardOp: {
      auto ptr = reinterpret_cast<const fbs::HardOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Hardshrink: {
      auto ptr = reinterpret_cast<const fbs::Hardshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Hardsigmoid: {
      auto ptr = reinterpret_cast<const fbs::Hardsigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Hardswish: {
      auto ptr = reinterpret_cast<const fbs::Hardswish *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Hardtanh: {
      auto ptr = reinterpret_cast<const fbs::Hardtanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_InstanceNorm1d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_InstanceNorm2d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_InstanceNorm3d: {
      auto ptr = reinterpret_cast<const fbs::InstanceNorm3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_LayerNorm: {
      auto ptr = reinterpret_cast<const fbs::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Less: {
      auto ptr = reinterpret_cast<const fbs::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_LessEqual: {
      auto ptr = reinterpret_cast<const fbs::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Log: {
      auto ptr = reinterpret_cast<const fbs::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_LogSigmoid: {
      auto ptr = reinterpret_cast<const fbs::LogSigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_LogSoftmax: {
      auto ptr = reinterpret_cast<const fbs::LogSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Matmul: {
      auto ptr = reinterpret_cast<const fbs::Matmul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Max: {
      auto ptr = reinterpret_cast<const fbs::Max *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Maximum: {
      auto ptr = reinterpret_cast<const fbs::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_MaxPool1d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool1d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_MaxPool2d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool2d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_MaxPool3d: {
      auto ptr = reinterpret_cast<const fbs::MaxPool3d *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Mean: {
      auto ptr = reinterpret_cast<const fbs::Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Min: {
      auto ptr = reinterpret_cast<const fbs::Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Minimum: {
      auto ptr = reinterpret_cast<const fbs::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Mish: {
      auto ptr = reinterpret_cast<const fbs::Mish *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Multiply: {
      auto ptr = reinterpret_cast<const fbs::Multiply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Neg: {
      auto ptr = reinterpret_cast<const fbs::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Normalize: {
      auto ptr = reinterpret_cast<const fbs::Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Not: {
      auto ptr = reinterpret_cast<const fbs::Not *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_NotEqual: {
      auto ptr = reinterpret_cast<const fbs::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Pad: {
      auto ptr = reinterpret_cast<const fbs::Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_PixelShuffle: {
      auto ptr = reinterpret_cast<const fbs::PixelShuffle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Pow: {
      auto ptr = reinterpret_cast<const fbs::Pow *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_PReLU: {
      auto ptr = reinterpret_cast<const fbs::PReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_PruneAxis: {
      auto ptr = reinterpret_cast<const fbs::PruneAxis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_ReLU: {
      auto ptr = reinterpret_cast<const fbs::ReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Reshape: {
      auto ptr = reinterpret_cast<const fbs::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Resize: {
      auto ptr = reinterpret_cast<const fbs::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Roll: {
      auto ptr = reinterpret_cast<const fbs::Roll *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Sigmoid: {
      auto ptr = reinterpret_cast<const fbs::Sigmoid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_SiLU: {
      auto ptr = reinterpret_cast<const fbs::SiLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Sin: {
      auto ptr = reinterpret_cast<const fbs::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Sinh: {
      auto ptr = reinterpret_cast<const fbs::Sinh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Slice: {
      auto ptr = reinterpret_cast<const fbs::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Softmax: {
      auto ptr = reinterpret_cast<const fbs::Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Softplus: {
      auto ptr = reinterpret_cast<const fbs::Softplus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Softshrink: {
      auto ptr = reinterpret_cast<const fbs::Softshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Softsign: {
      auto ptr = reinterpret_cast<const fbs::Softsign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Split: {
      auto ptr = reinterpret_cast<const fbs::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Sqrt: {
      auto ptr = reinterpret_cast<const fbs::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Squeeze: {
      auto ptr = reinterpret_cast<const fbs::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Stack: {
      auto ptr = reinterpret_cast<const fbs::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Sum: {
      auto ptr = reinterpret_cast<const fbs::Sum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_SwapOrder: {
      auto ptr = reinterpret_cast<const fbs::SwapOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Tan: {
      auto ptr = reinterpret_cast<const fbs::Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Tanh: {
      auto ptr = reinterpret_cast<const fbs::Tanh *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Tanhshrink: {
      auto ptr = reinterpret_cast<const fbs::Tanhshrink *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Tile: {
      auto ptr = reinterpret_cast<const fbs::Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Transpose: {
      auto ptr = reinterpret_cast<const fbs::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Unfold: {
      auto ptr = reinterpret_cast<const fbs::Unfold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Unknown: {
      auto ptr = reinterpret_cast<const fbs::Unknown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Unstack: {
      auto ptr = reinterpret_cast<const fbs::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Unsupport: {
      auto ptr = reinterpret_cast<const fbs::Unsupport *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Upsample: {
      auto ptr = reinterpret_cast<const fbs::Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Where: {
      auto ptr = reinterpret_cast<const fbs::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Operation_box_Operation: {
      auto ptr = reinterpret_cast<const fbs::Operation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOperation_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOperation_box(
        verifier,  values->Get(i), types->GetEnum<Operation_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyQuantizedScale_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedScale_box type) {
  switch (type) {
    case QuantizedScale_box_NONE: {
      return true;
    }
    case QuantizedScale_box_ExpQuantizedScale: {
      auto ptr = reinterpret_cast<const fbs::ExpQuantizedScale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QuantizedScale_box_QuantizedScale: {
      auto ptr = reinterpret_cast<const fbs::QuantizedScale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizedScale_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizedScale_box(
        verifier,  values->Get(i), types->GetEnum<QuantizedScale_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyQuantizedScaleArray_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedScaleArray_box type) {
  switch (type) {
    case QuantizedScaleArray_box_NONE: {
      return true;
    }
    case QuantizedScaleArray_box_ExpQuantizedScaleArray: {
      auto ptr = reinterpret_cast<const fbs::ExpQuantizedScaleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QuantizedScaleArray_box_QuantizedScaleArray: {
      auto ptr = reinterpret_cast<const fbs::QuantizedScaleArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizedScaleArray_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizedScaleArray_box(
        verifier,  values->Get(i), types->GetEnum<QuantizedScaleArray_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyQuantizedType_box(::flatbuffers::Verifier &verifier, const void *obj, QuantizedType_box type) {
  switch (type) {
    case QuantizedType_box_NONE: {
      return true;
    }
    case QuantizedType_box_NormalizedQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QuantizedType_box_QuantizedType: {
      auto ptr = reinterpret_cast<const fbs::QuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQuantizedType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizedType_box(
        verifier,  values->Get(i), types->GetEnum<QuantizedType_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScalarImm_box(::flatbuffers::Verifier &verifier, const void *obj, ScalarImm_box type) {
  switch (type) {
    case ScalarImm_box_NONE: {
      return true;
    }
    case ScalarImm_box_Bool: {
      auto ptr = reinterpret_cast<const fbs::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarImm_box_IntImm: {
      auto ptr = reinterpret_cast<const fbs::IntImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarImm_box_FloatImm: {
      auto ptr = reinterpret_cast<const fbs::FloatImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarImm_box_ScalarImm: {
      auto ptr = reinterpret_cast<const fbs::ScalarImm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarImm_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarImm_box(
        verifier,  values->Get(i), types->GetEnum<ScalarImm_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScalarType_box(::flatbuffers::Verifier &verifier, const void *obj, ScalarType_box type) {
  switch (type) {
    case ScalarType_box_NONE: {
      return true;
    }
    case ScalarType_box_BoolType: {
      auto ptr = reinterpret_cast<const fbs::BoolType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_IntegerType: {
      auto ptr = reinterpret_cast<const fbs::IntegerType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_FloatType: {
      auto ptr = reinterpret_cast<const fbs::FloatType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_CalibratedType: {
      auto ptr = reinterpret_cast<const fbs::CalibratedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_NormalizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_NormalizedQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::NormalizedQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_QuantizedType: {
      auto ptr = reinterpret_cast<const fbs::QuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_BaseQuantizedType: {
      auto ptr = reinterpret_cast<const fbs::BaseQuantizedType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarType_box_ScalarType: {
      auto ptr = reinterpret_cast<const fbs::ScalarType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarType_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarType_box(
        verifier,  values->Get(i), types->GetEnum<ScalarType_box>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyValue_box(::flatbuffers::Verifier &verifier, const void *obj, Value_box type) {
  switch (type) {
    case Value_box_NONE: {
      return true;
    }
    case Value_box_Params: {
      auto ptr = reinterpret_cast<const fbs::Params *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_box_Value: {
      auto ptr = reinterpret_cast<const fbs::Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValue_boxVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue_box(
        verifier,  values->Get(i), types->GetEnum<Value_box>(i))) {
      return false;
    }
  }
  return true;
}

inline const fbs::Network *GetNetwork(const void *buf) {
  return ::flatbuffers::GetRoot<fbs::Network>(buf);
}

inline const fbs::Network *GetSizePrefixedNetwork(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fbs::Network>(buf);
}

inline bool VerifyNetworkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbs::Network>(nullptr);
}

inline bool VerifySizePrefixedNetworkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbs::Network>(nullptr);
}

inline void FinishNetworkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::Network> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetworkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::Network> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_XIR_FBS_H_
</pre>
```
